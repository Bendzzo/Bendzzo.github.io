<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flash Cards</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            padding: 20px;
            box-sizing: border-box;
            font-size: 16px; /* ZÃ¡kladnÃ¡ veÄ¾kosÅ¥ pÃ­sma */
        }

        .flashcard-container {
            perspective: 1000px;
            width: 90%;
            min-width: 320px; /* MinimÃ¡lna Å¡Ã­rka pre menÅ¡ie obrazovky */
            max-width: 750px; /* ZvÃ¤ÄÅ¡enÃ¡ maximÃ¡lna Å¡Ã­rka */
            
            height: 65vh; /* VÃ½Å¡ka ako percento vÃ½Å¡ky okna */
            min-height: 400px; /* MinimÃ¡lna vÃ½Å¡ka karty */
            max-height: 550px; /* MaximÃ¡lna vÃ½Å¡ka karty */
            
            margin-bottom: 20px;
        }

        .flashcard {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .flashcard.flipped {
            transform: rotateY(180deg);
        }

        .flashcard-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 25px; /* Trochu zvÃ¤ÄÅ¡enÃ½ padding */
            box-sizing: border-box;
            text-align: center;
            overflow-y: auto; /* UmoÅ¾nÃ­ skrolovanie, ak je text dlhÅ¡Ã­ */
            border-radius: 10px;
        }

        .flashcard-front {
            background-color: #e0f7fa;
            font-size: 1.25em; /* ZvÃ¤ÄÅ¡enÃ© pÃ­smo pre otÃ¡zku (16px * 1.25 = 20px) */
        }

        .flashcard-back {
            background-color: #fff9c4;
            transform: rotateY(180deg);
            font-size: 1em; /* PÃ­smo pre odpoveÄ (16px * 1 = 16px) */
            white-space: pre-wrap; /* ZachovÃ¡ formÃ¡tovanie textu vrÃ¡tane novÃ½ch riadkov */
        }
        
        .flashcard-back ul, .flashcard-back ol {
            text-align: left;
            padding-left: 20px;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        .flashcard-back li {
            margin-bottom: 8px; /* Trochu vÃ¤ÄÅ¡Ã­ odstup medzi poloÅ¾kami zoznamu */
        }

        .controls button {
            font-size: 28px; /* ZvÃ¤ÄÅ¡enÃ© tlaÄidlÃ¡ */
            padding: 12px 24px; /* ZvÃ¤ÄÅ¡enÃ½ padding tlaÄidiel */
            margin: 0 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #correct-btn {
            background-color: #a5d6a7;
        }
        #correct-btn:hover {
            background-color: #81c784;
        }

        #incorrect-btn {
            background-color: #ef9a9a;
        }
        #incorrect-btn:hover {
            background-color: #e57373;
        }

        #status {
            margin-top: 15px;
            font-size: 1.1em;
            color: #555;
        }

        #completion-message {
            font-size: 1.5em;
            color: green;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="flashcard-container">
        <div class="flashcard">
            <div class="flashcard-face flashcard-front"></div>
            <div class="flashcard-face flashcard-back"></div>
        </div>
    </div>

    <div id="controls" style="display: none;">
        <button id="correct-btn" title="SprÃ¡vne">âœ”ï¸</button>
        <button id="incorrect-btn" title="NesprÃ¡vne">âŒ</button>
    </div>

    <div id="status"></div>
    <div id="completion-message" style="display:none;">
        VÃ½borne! VÅ¡etky kartiÄky si ÃºspeÅ¡ne preÅ¡iel! ğŸ‰
    </div>

    <script>
        const initialCardsData = [
            {
                question: "Rozdiel medzi AUT a APT:",
                answer: `AUT (AbstraktnÃ½ ÃºdajovÃ½ typ):
â€¢ UrÄuje domÃ©nu prvkov (prÃ­padne viac domÃ©n)
â€¢ Definuje operÃ¡cie na prvkoch domÃ©ny
â€¢ Je nezÃ¡vislÃ½ na konkrÃ©tnej implementÃ¡cii
â€¢ Je realizovateÄ¾nÃ½ viacerÃ½mi abstraktnÃ½mi ÃºdajovÃ½mi Å¡truktÃºrami (AUS)

APT (AbstraktnÃ½ pamÃ¤Å¥ovÃ½ typ):
â€¢ UrÄuje ako ÃºdajovÃ¡ Å¡truktÃºra organizuje bloky pamÃ¤te v pamÃ¤ti
â€¢ Definuje operÃ¡cie typickÃ© pre danÃ© pamÃ¤Å¥ovÃ© usporiadanie
â€¢ Å pecifikuje poÅ¾iadavky na bloky pamÃ¤te
â€¢ Je typicky implementovanÃ½ ako rozhranie
â€¢ Je realizovateÄ¾nÃ½ viacerÃ½mi spÃ´sobmi s odliÅ¡nou organizÃ¡ciou blokov pamÃ¤te

Oba typy sÃº abstraktnÃ© a fungujÃº ako "Äierne skrinky". HlavnÃ½ rozdiel je v tom, Å¾e AUT sa zameriava na Ãºdaje a operÃ¡cie s nimi, zatiaÄ¾ Äo APT sa zameriava na organizÃ¡ciu pamÃ¤te a operÃ¡cie s Åˆou.`
            },
            {
                question: "ÄŒo je to endianita a jej 2 typy:",
                answer: `Endianita sa tÃ½ka spÃ´sobu, akÃ½m sa viacbajtovÃ© Ãºdaje ukladajÃº v pamÃ¤ti poÄÃ­taÄa. ExistujÃº dva hlavnÃ© typy endianity:
1. Big-endian:
   â€¢ Najviac vÃ½znamnÃ½ bajt sa ukladÃ¡ na niÅ¾Å¡iu adresu.
   â€¢ Najmenej vÃ½znamnÃ½ bajt sa ukladÃ¡ na vyÅ¡Å¡iu adresu.
   â€¢ OznaÄuje sa ako "sieÅ¥ovÃ© poradie bajtov", pretoÅ¾e sa v tomto poradÃ­ posielajÃº Ãºdaje vo vÃ¤ÄÅ¡ine sieÅ¥ovÃ½ch protokolov.
2. Little-endian:
   â€¢ Najmenej vÃ½znamnÃ½ bajt sa ukladÃ¡ na niÅ¾Å¡iu adresu.
   â€¢ Najviac vÃ½znamnÃ½ bajt sa ukladÃ¡ na vyÅ¡Å¡iu adresu.
   â€¢ Tento typ endianity sa pouÅ¾Ã­va v architektÃºre PC.`
            },
            {
                question: "AkÃ½ je rozdiel medzi Implicitnou Sekvenciou a Explicitnou Sekvenciou:",
                answer: `PoznÃ¡mka: VÃ¡Å¡ text uvÃ¡dza ImplicitnÃº/ExplicitnÃº hierarchiu, nie sekvenciu. OdpoveÄ je podÄ¾a textu pre hierarchie.

ImplicitnÃ¡ hierarchia:
1. MusÃ­ byÅ¥ v kompaktnej pamÃ¤ti
2. MoÅ¾nÃ© len pre usporiadanÃ© K-cestnÃ© hierarchie
3. VzÅ¥ahy medzi vrcholmi (otec-syn) sa vypoÄÃ­tavajÃº
4. LimitovanÃ¡ mnoÅ¾ina modifikÃ¡torov - musÃ­ zostaÅ¥ kompletnÃ¡
5. EfektÃ­vna z hÄ¾adiska pamÃ¤te, ale menej flexibilnÃ¡
6. VhodnÃ¡ pre kompletnÃ© a vyvÃ¡Å¾enÃ© hierarchie

ExplicitnÃ¡ hierarchia:
1. MÃ´Å¾e byÅ¥ v Ä¾ubovoÄ¾nej pamÃ¤ti (vrÃ¡tane externej)
2. MoÅ¾nÃ¡ pre vÅ¡etky typy hierarchiÃ­
3. VzÅ¥ahy medzi vrcholmi sÃº explicitne uloÅ¾enÃ© (referencie)
4. VÃ¤ÄÅ¡ia flexibilita pri modifikÃ¡cii Å¡truktÃºry
5. VyÅ¡Å¡ia pamÃ¤Å¥ovÃ¡ nÃ¡roÄnosÅ¥ kvÃ´li ukladaniu referenciÃ­
6. VhodnÃ¡ pre dynamickÃ© a nepravidelnÃ© hierarchie

ImplicitnÃ¡ hierarchia je pamÃ¤Å¥ovo efektÃ­vnejÅ¡ia, ale menej flexibilnÃ¡. ExplicitnÃ¡ hierarchia je flexibilnejÅ¡ia, ale nÃ¡roÄnejÅ¡ia na pamÃ¤Å¥.`
            },
            {
                question: "VypÃ­saÅ¥ 3 druhy O-notÃ¡cie a jej nÃ¡zvy:",
                answer: `1. O(f(n)) - HornÃ½ asymptotickÃ½ odhad: Funkcia z(n) je asymptoticky menÅ¡ia alebo rovnÃ¡ ako c*f(n) pre nejakÃ© kladnÃ© konÅ¡tanty c a k.
2. Î©(f(n)) - DolnÃ½ asymptotickÃ½ odhad: Funkcia z(n) je asymptoticky vÃ¤ÄÅ¡ia alebo rovnÃ¡ ako c*f(n) pre nejakÃ© kladnÃ© konÅ¡tanty c a k.
3. Î˜(f(n)) - TesnÃ½ asymptotickÃ½ odhad: Funkcia z(n) je asymptoticky rovnÃ¡ ako c*f(n) pre nejakÃ© kladnÃ© konÅ¡tanty c a k.
(PoznÃ¡mka: PÃ´vodnÃ½ text mal ÄÃ­slovanie 3,4,5, tu upravenÃ© na 1,2,3 pre prehÄ¾adnosÅ¥)`
            },
            {
                question: "ZoradiÅ¥ tabuÄ¾ky podÄ¾a operÃ¡cie odober s danÃ½m kÄ¾ÃºÄom:",
                answer: `1. TabuÄ¾ka s rozptÃ½lenÃ½mi zÃ¡znamami (bez rieÅ¡enia kolÃ­ziÃ­): O(1)
2. TabuÄ¾ka s rozptÃ½lenÃ½mi zÃ¡znamami (zreÅ¥azovanie): O(1)
3. TabuÄ¾ka s rozptÃ½lenÃ½mi zÃ¡znamami (preplÅˆovacia oblasÅ¥): O(1)
4. BinÃ¡rny vyhÄ¾adÃ¡vacÃ­ strom: O(log n) v priemernom prÃ­pade, O(n) v najhorÅ¡om prÃ­pade`
            },
            {
                question: "VysvetliÅ¥ akÃ¡ je to perfektnÃ¡ hierarchia, a nakresliÅ¥ ju s 13timi vrcholmi:",
                answer: `PerfektnÃ¡ hierarchia:
â€¢ VÅ¡etky listy sÃº v rovnakej hÄºbke. To znamenÃ¡, Å¾e vÅ¡etky vrcholy bez synov (listy) sÃº vzdialenÃ© od koreÅˆa rovnakÃ½ poÄet ÃºrovnÃ­.
â€¢ VÅ¡etky vnÃºtornÃ© vrcholy majÃº stupeÅˆ n (pre n-Ã¡rnu hierarchiu). To znamenÃ¡, Å¾e kaÅ¾dÃ½ vrchol s aspoÅˆ jednÃ½m synom mÃ¡ presne n synov.

NÃ¡kres s 13 vrcholmi (napr. pre binÃ¡rnu perfektnÃº hierarchiu, kde n=2):
(NÃ¡kres tu nie je moÅ¾nÃ© zobraziÅ¥ textovo, ale predstavte si:)
ÃšroveÅˆ 0: 1 vrchol (koreÅˆ)
ÃšroveÅˆ 1: 2 vrcholy (synovia koreÅˆa)
ÃšroveÅˆ 2: 4 vrcholy (synovia vrcholov z Ãºrovne 1)
ÃšroveÅˆ 3: 6 vrcholov (synovia 3 vrcholov z Ãºrovne 2, aby bol sÃºÄet 1+2+4+6 = 13. Ak by mala byÅ¥ striktne perfektnÃ¡ a kompletnÃ¡, tak by poslednÃ¡ ÃºroveÅˆ mala 8 vrcholov, celkovo 15).
Ak mÃ¡ maÅ¥ *presne* 13 vrcholov a byÅ¥ perfektnÃ¡, musÃ­ byÅ¥ n-Ã¡rna, kde n je voliteÄ¾nÃ©. Pre binÃ¡rny strom (n=2) by to nebola Ãºplne perfektnÃ¡ po poslednÃº ÃºroveÅˆ ak mÃ¡ presne 13 vrcholov. PerfektnÃ½ binÃ¡rny strom mÃ¡ 2^h - 1 vrcholov. Pre 13 vrcholov by to znamenalo, Å¾e nie vÅ¡etky vnÃºtornÃ© vrcholy na predposlednej Ãºrovni majÃº plnÃ½ poÄet synov.
Pre K-cestnÃº perfektnÃº hierarchu:
- Ak K=3 (ternÃ¡rny strom):
  - ÃšroveÅˆ 0: 1
  - ÃšroveÅˆ 1: 3 (spolu 4)
  - ÃšroveÅˆ 2: 9 (spolu 13)
  Toto by bola perfektnÃ¡ ternÃ¡rna hierarchia s hÄºbkou 2 a 13 vrcholmi.

  PrÃ­klad (TernÃ¡rna, K=3):
        O  (1)
       /|\
      O O O (3)
     /|\/|\/|\
    O O O O O O O O O (9)
    Spolu: 1 + 3 + 9 = 13 vrcholov. VÅ¡etky listy na Ãºrovni 2. VÅ¡etky vnÃºtornÃ© vrcholy (na Ãºrovni 0 a 1) majÃº 3 synov.`
            },
            {
                question: "BVS popis, akÃº implementÃ¡ciu hierarchie pouÅ¾Ã­va, a popÃ­saÅ¥ logiku operÃ¡ciÃ­ vloÅ¾ a vyber:",
                answer: `ImplementÃ¡cia hierarchie:
â€¢ BVS pouÅ¾Ã­va explicitnÃº binÃ¡rnu hierarchiu.
â€¢ KaÅ¾dÃ½ vrchol je reprezentovanÃ½ samostatnÃ½m objektom v pamÃ¤ti.
â€¢ Vrchol obsahuje: KÄ¾ÃºÄ, Ãºdaje, odkaz na otca (voliteÄ¾ne), Ä¾avÃ©ho syna a pravÃ©ho syna.

Logika operÃ¡cie vloÅ¾:
1. PokÃºsi sa nÃ¡jsÅ¥ vrchol s vkladanÃ½m kÄ¾ÃºÄom:
   â€¢ Testuje unikÃ¡tnosÅ¥ kÄ¾ÃºÄa (ak je vyÅ¾adovanÃ¡).
   â€¢ ZÃ­ska vrchol (rodiÄa), ku ktorÃ©mu mÃ¡ byÅ¥ novÃ½ vrchol pripojenÃ½ ako syn.
2. Ak sa vrchol s danÃ½m kÄ¾ÃºÄom nenÃ¡jde (alebo ak duplikÃ¡ty nie sÃº povolenÃ© a kÄ¾ÃºÄ je unikÃ¡tny):
   â€¢ VytvorÃ­ novÃ½ vrchol.
   â€¢ VloÅ¾Ã­ ho do hierarchie tak, aby nebolo poruÅ¡enÃ© usporiadanie BVS (menÅ¡ie kÄ¾ÃºÄe vÄ¾avo od rodiÄa, vÃ¤ÄÅ¡ie kÄ¾ÃºÄe vpravo od rodiÄa).
   â€¢ PriradÃ­ doÅˆ Ãºdaje.
   â€¢ ZvÃ½Å¡i poÄet prvkov.

Logika operÃ¡cie vyber:
1. NÃ¡jde vrchol s danÃ½m kÄ¾ÃºÄom. Ak sa nenÃ¡jde, operÃ¡cia konÄÃ­.
2. Ak sa vrchol nÃ¡jde, odstrÃ¡ni ho z hierarchie tak, aby nebolo poruÅ¡enÃ© usporiadanie BVS. RozliÅ¡ujÃº sa prÃ­pady:
   a) Vrchol nemÃ¡ synov (je list): Jednoducho sa odstrÃ¡ni.
   b) Vrchol mÃ¡ jednÃ©ho syna: Vrchol sa nahradÃ­ jeho jedinÃ½m synom.
   c) Vrchol mÃ¡ dvoch synov: NÃ¡jde sa jeho inorder nÃ¡slednÃ­k (najmenÅ¡Ã­ prvok v pravom podstrome) alebo inorder predchodca (najvÃ¤ÄÅ¡Ã­ prvok v Ä¾avom podstrome). Hodnota nÃ¡slednÃ­ka/predchodcu sa skopÃ­ruje do odstraÅˆovanÃ©ho vrcholu a nÃ¡sledne sa rekurzÃ­vne odstrÃ¡ni tento nÃ¡slednÃ­k/predchodca (ktorÃ½ mÃ¡ najviac jednÃ©ho syna).
3. VrÃ¡ti Ãºdaje z odstrÃ¡nenÃ©ho vrcholu (voliteÄ¾ne).
4. Dealokuje pamÃ¤Å¥ vrcholu, znÃ­Å¾i poÄet prvkov.`
            },
            {
                question: "Rozdiel medzi AUT a AUÅ , po jednom prÃ­klade:",
                answer: `AUT (AbstraktnÃ½ ÃºdajovÃ½ typ):
â€¢ UrÄuje domÃ©nu prvkov (prÃ­padne viac domÃ©n).
â€¢ Definuje operÃ¡cie na prvkoch domÃ©ny ("Äo" sa dÃ¡ robiÅ¥).
â€¢ Je nezÃ¡vislÃ½ na konkrÃ©tnej implementÃ¡cii.
â€¢ Je realizovateÄ¾nÃ½ viacerÃ½mi abstraktnÃ½mi ÃºdajovÃ½mi Å¡truktÃºrami (AUS).
â€¢ PrÃ­klad AUT: ZÃ¡sobnÃ­k (operÃ¡cie: push, pop, top, isEmpty).

AUÅ  (AbstraktnÃ¡ ÃºdajovÃ¡ Å¡truktÃºra):
â€¢ Je to konkrÃ©tna implementÃ¡cia AUT.
â€¢ Definuje, ako sÃº dÃ¡ta organizovanÃ© v pamÃ¤ti.
â€¢ Poskytuje konkrÃ©tne algoritmy pre operÃ¡cie definovanÃ© v AUT.
â€¢ Popisuje "ako" Å¡truktÃºra funguje interne.
â€¢ PrÃ­klad AUÅ : ZÃ¡sobnÃ­k implementovanÃ½ pomocou poÄ¾a (array-based stack) alebo ZÃ¡sobnÃ­k implementovanÃ½ pomocou zreÅ¥azenÃ©ho zoznamu (linked-list-based stack).

HlavnÃ½ rozdiel je teda v Ãºrovni abstrakcie: AUT poskytuje abstraktnÃ½ pohÄ¾ad na Å¡truktÃºru a jej sprÃ¡vanie (Äo robÃ­), zatiaÄ¾ Äo AUÅ  poskytuje konkrÃ©tnu implementÃ¡ciu tohto sprÃ¡vania (ako to robÃ­).`
            },
            {
                question: "Riadiaci blok explicitnej hierarchie, z Äoho sa skladÃ¡, teda atribÃºty a eÅ¡te nieÄo k tomu asi popis na Äo sÃº tie atribÃºty:",
                answer: `Riadiaci blok explicitnej hierarchie typicky obsahuje nasledujÃºce atribÃºty:
1. Referencia na koreÅˆ:
   â€¢ AtribÃºt: napr. \`koren\` (typu referencia na blok pamÃ¤te/vrchol)
   â€¢ Popis: UchovÃ¡va referenciu na koreÅˆovÃ½ vrchol hierarchie. UmoÅ¾Åˆuje prÃ­stup k celej Å¡truktÃºre, keÄÅ¾e vÅ¡etky ostatnÃ© vrcholy sÃº dostupnÃ© cez koreÅˆ. Je to vstupnÃ½ bod do hierarchie.
2. Referencia na poslednÃ½ pouÅ¾itÃ½ vrchol (current/active node):
   â€¢ AtribÃºt: napr. \`poslednyVrchol\`, \`aktualnyVrchol\` (typu referencia na blok pamÃ¤te/vrchol)
   â€¢ Popis: UchovÃ¡va referenciu na vrchol, s ktorÃ½m sa naposledy pracovalo (napr. vÃ½sledok operÃ¡cie nÃ¡jdi, vloÅ¾). MÃ´Å¾e zrÃ½chliÅ¥ niektorÃ© sekvenÄnÃ© operÃ¡cie alebo operÃ¡cie vyÅ¾adujÃºce kontext predchÃ¡dzajÃºceho prÃ­stupu. Nie je vÅ¾dy povinnÃ½.
3. PoÄet prvkov (mohutnosÅ¥):
   â€¢ AtribÃºt: napr. \`pocetPrvkov\` (typu integer)
   â€¢ Popis: UchovÃ¡va aktuÃ¡lny poÄet vrcholov v hierarchii. UÅ¾itoÄnÃ© pre rÃ½chle zistenie veÄ¾kosti Å¡truktÃºry bez potreby prechÃ¡dzania vÅ¡etkÃ½ch vrcholov.
ÄalÅ¡ie moÅ¾nÃ© atribÃºty (v zÃ¡vislosti od Å¡pecifickej implementÃ¡cie a potrieb):
4. Referencia na Predchodcu (ak je hierarchia Å¡pecificky Å¡truktÃºrovanÃ¡, napr. pre explicitnÃ© sekvencie v rÃ¡mci hierarchie, alebo ak ide o obojsmerne zreÅ¥azenÃº Å¡truktÃºru na nejakej Ãºrovni). VÅ¡eobecne pre hierarchiu ako takÃº to nie je typickÃ© pre riadiaci blok, skÃ´r pre samotnÃ© vrcholy (ukazovateÄ¾ na rodiÄa).
5. Referencia na NasledovnÃ­ka (podobne ako predchodca, relevantnÃ© pre Å¡pecifickÃ© Å¡truktÃºry).

PrimÃ¡rne sÃº to referencia na koreÅˆ a poÄet prvkov. OstatnÃ© sÃº doplnkovÃ© a zÃ¡visia od konkrÃ©tneho nÃ¡vrhu.`
            },
            {
                question: "Z Äoho sa skladÃ¡ Bitonic sort:",
                answer: `Bitonic sorter (BitonickÃ¡ triediaca sieÅ¥) sa skladÃ¡ z kaskÃ¡dovo zapojenÃ½ch jednoduchÅ¡Ã­ch komponentov, konkrÃ©tne:
1.  **PorovnÃ¡vaÄ (Comparator):** ZÃ¡kladnÃ½ stavebnÃ½ blok. Je to zariadenie s dvoma vstupmi a dvoma vÃ½stupmi. Na vÃ½stup dÃ¡va hodnoty zo vstupu usporiadanÃ© (napr. menÅ¡ia hore, vÃ¤ÄÅ¡ia dole, alebo naopak).
2.  **Bitonic Sequence (BitonickÃ¡ sekvencia):** Toto nie je komponent siete, ale typ sekvencie, s ktorou sieÅ¥ pracuje. Je to sekvencia, ktorÃ¡ najprv monotÃ³nne neklesÃ¡ (rastie alebo stagnuje) a potom monotÃ³nne nerastie (klesÃ¡ alebo stagnuje), alebo naopak (po cyklickom posune). NaprÃ­klad: (1, 2, 5, 8, 6, 4, 3) alebo (8, 6, 4, 1, 2, 5, 7).
3.  **Half-Cleaner (PoloviÄnÃ½ ÄistiÄ / Bitonic Splitter):**
    *   TÃ¡to ÄasÅ¥ siete berie na vstup bitonickÃº sekvenciu o dÄºÅ¾ke N.
    *   PozostÃ¡va z N/2 porovnÃ¡vaÄov. KaÅ¾dÃ½ porovnÃ¡vaÄ spÃ¡ja prvok i s prvkom i+N/2.
    *   Na vÃ½stupe produkuje dve bitonickÃ© sekvencie, kaÅ¾dÃº o dÄºÅ¾ke N/2. VÅ¡etky prvky v jednej sekvencii sÃº menÅ¡ie alebo rovnÃ© vÅ¡etkÃ½m prvkom v druhej sekvencii.
4.  **Merger (ZluÄovaÄ / Bitonic Merger):**
    *   TÃ¡to ÄasÅ¥ siete berie na vstup bitonickÃº sekvenciu a na vÃ½stupe dÃ¡va utriedenÃº sekvenciu.
    *   Realizuje sa rekurzÃ­vnym pouÅ¾itÃ­m Half-Cleaneru. Po prvom Half-Cleaneri dostaneme dve menÅ¡ie bitonickÃ© sekvencie, na ktorÃ© opÃ¤Å¥ aplikujeme Merger (ktorÃ½ v sebe pouÅ¾ije Half-Cleaner atÄ.), aÅ¾ kÃ½m nezostanÃº sekvencie dÄºÅ¾ky 1.
5.  **Bitonic Sorter (CelÃ¡ triediaca sieÅ¥):**
    *   Na vytvorenie utriedenej sekvencie z Ä¾ubovoÄ¾nej vstupnej sekvencie sa najprv vstupnÃ¡ sekvencia transformuje na bitonickÃº sekvenciu.
    *   Toto sa robÃ­ tak, Å¾e sa najprv utriedia menÅ¡ie podsiete (napr. dvojice prvkov, ÄÃ­m vzniknÃº bitonickÃ© sekvencie dÄºÅ¾ky 2).
    *   Potom sa tieto bitonickÃ© sekvencie zluÄujÃº pomocou Mergerov tak, aby vznikali vÃ¤ÄÅ¡ie bitonickÃ© sekvencie (napr. dve utriedenÃ© sekvencie dÄºÅ¾ky 2 sa spoja do bitonickej sekvencie dÄºÅ¾ky 4 â€“ jedna sa obrÃ¡ti a pripojÃ­).
    *   Nakoniec sa na vÃ½slednÃº bitonickÃº sekvenciu plnej dÄºÅ¾ky aplikuje Merger, ktorÃ½ ju utriedi.

V skratke, Bitonic Sort sa skladÃ¡ z viacerÃ½ch stupÅˆov Mergerov, kde kaÅ¾dÃ½ Merger je postavenÃ½ z Half-Cleanerov a tie sÃº postavenÃ© z porovnÃ¡vaÄov.`
            },
            {
                question: "BinÃ¡rny vyhÄ¾adÃ¡vacÃ­ strom ako fungujÃº metÃ³dy vloÅ¾, vyhÄ¾adaj a vyber a ich zloÅ¾itosti a dÃ´vod danej zloÅ¾itosti, kedy BVS zdegeneruje a prÃ­klad a zloÅ¾itosti danÃ½ch operÃ¡ciÃ­ pri zdegenerovanÃ­ a mechanizmus na predÃ­denie zdegenerovania:",
                answer: `**MetÃ³da vyhÄ¾adaj (search):**
*   Fungovanie: ZaÄÃ­na v koreni. PorovnÃ¡va hÄ¾adanÃ½ kÄ¾ÃºÄ s kÄ¾ÃºÄom aktuÃ¡lneho vrcholu. Ak sa rovnajÃº, vrchol je nÃ¡jdenÃ½. Ak je hÄ¾adanÃ½ kÄ¾ÃºÄ menÅ¡Ã­, pokraÄuje v Ä¾avom podstrome. Ak je vÃ¤ÄÅ¡Ã­, pokraÄuje v pravom podstrome. Opakuje, kÃ½m nenÃ¡jde kÄ¾ÃºÄ alebo nedosiahne NULL (list).
*   ZloÅ¾itosÅ¥: O(h), kde h je vÃ½Å¡ka stromu.
    *   PriemernÃ½ prÃ­pad (vyvÃ¡Å¾enÃ½ strom): O(log n), pretoÅ¾e vÃ½Å¡ka je logaritmickÃ¡ k poÄtu prvkov n.
    *   NajhorÅ¡Ã­ prÃ­pad (zdegenerovanÃ½ strom): O(n), pretoÅ¾e vÃ½Å¡ka je lineÃ¡rna.

**MetÃ³da vloÅ¾ (insert):**
*   Fungovanie: Podobne ako vyhÄ¾adÃ¡vanie, nÃ¡jde sa miesto, kam novÃ½ prvok patrÃ­ (NULL referencia, kde by mal byÅ¥). Na tomto mieste sa vytvorÃ­ novÃ½ vrchol s danÃ½m kÄ¾ÃºÄom a Ãºdajmi.
*   ZloÅ¾itosÅ¥: O(h).
    *   PriemernÃ½ prÃ­pad: O(log n).
    *   NajhorÅ¡Ã­ prÃ­pad: O(n).

**MetÃ³da vyber (delete/remove):**
*   Fungovanie: Najprv vyhÄ¾adÃ¡ vrchol na vymazanie.
    1.  Ak vrchol nemÃ¡ synov (je list): Jednoducho sa odstrÃ¡ni (referencia rodiÄa naÅˆ sa nastavÃ­ na NULL).
    2.  Ak vrchol mÃ¡ jednÃ©ho syna: RodiÄ odstraÅˆovanÃ©ho vrcholu sa prepojÃ­ priamo na jedinÃ©ho syna odstraÅˆovanÃ©ho vrcholu.
    3.  Ak vrchol mÃ¡ dvoch synov: NÃ¡jde sa jeho inorder nÃ¡slednÃ­k (najmenÅ¡Ã­ prvok v pravom podstrome) alebo inorder predchodca (najvÃ¤ÄÅ¡Ã­ prvok v Ä¾avom podstrome). Hodnota (kÄ¾ÃºÄ a Ãºdaje) nÃ¡slednÃ­ka/predchodcu sa skopÃ­ruje do odstraÅˆovanÃ©ho vrcholu. NÃ¡sledne sa rekurzÃ­vne odstrÃ¡ni tento nÃ¡slednÃ­k/predchodca (ktorÃ½ mÃ¡ uÅ¾ najviac jednÃ©ho syna, takÅ¾e spadÃ¡ pod prÃ­pady 1 alebo 2).
*   ZloÅ¾itosÅ¥: O(h).
    *   PriemernÃ½ prÃ­pad: O(log n).
    *   NajhorÅ¡Ã­ prÃ­pad: O(n).

**DÃ´vod zloÅ¾itosti:** OperÃ¡cie typicky postupujÃº od koreÅˆa smerom k listu, priÄom na kaÅ¾dej Ãºrovni urobia konÅ¡tantnÃ½ poÄet operÃ¡ciÃ­. MaximÃ¡lny poÄet ÃºrovnÃ­ je vÃ½Å¡ka stromu h.

**DegenerÃ¡cia BVS:**
*   Kedy zdegeneruje: BVS zdegeneruje, keÄ sa jeho Å¡truktÃºra stane podobnou lineÃ¡rnemu zoznamu (kaÅ¾dÃ½ vrchol mÃ¡ len jednÃ©ho syna, alebo Å¾iadneho).
*   PrÃ­klad: Vkladanie uÅ¾ usporiadanÃ½ch dÃ¡t (napr. 1, 2, 3, 4, 5...) alebo vkladanie dÃ¡t v opaÄnom usporiadanÃ­ (5, 4, 3, 2, 1...).
*   ZloÅ¾itosti pri zdegenerovanÃ­: VÅ¡etky operÃ¡cie (vyhÄ¾adaj, vloÅ¾, vyber) majÃº zloÅ¾itosÅ¥ O(n), pretoÅ¾e strom sa sprÃ¡va ako lineÃ¡rny zoznam a je potrebnÃ© prejsÅ¥ potenciÃ¡lne vÅ¡etky prvky.

**Mechanizmy na predÃ­denie degenerÃ¡cie (Samo-vyvaÅ¾ovacie stromy):**
1.  **AVL stromy:** Po kaÅ¾dej operÃ¡cii vloÅ¾enia alebo vymazania kontrolujÃº "faktor vyvÃ¡Å¾enia" kaÅ¾dÃ©ho vrcholu (rozdiel vÃ½Å¡ok Ä¾avÃ©ho a pravÃ©ho podstromu). Ak je rozdiel vÃ¤ÄÅ¡Ã­ ako 1, vykonajÃº rotÃ¡cie na obnovenie vyvÃ¡Å¾enia. ZaruÄujÃº vÃ½Å¡ku O(log n).
2.  **Red-Black stromy (ÄŒerveno-Äierne stromy):** PouÅ¾Ã­vajÃº farbenie vrcholov (ÄervenÃ¡/Äierna) a Å¡pecifickÃ© pravidlÃ¡ na udrÅ¾anie stromu pribliÅ¾ne vyvÃ¡Å¾enÃ©ho. ZaruÄujÃº vÃ½Å¡ku O(log n).
3.  **B-stromy (a ich varianty, napr. B+ stromy):** PouÅ¾Ã­vanÃ© hlavne pre databÃ¡zy a sÃºborovÃ© systÃ©my. UdrÅ¾iavajÃº vyvÃ¡Å¾enie tÃ½m, Å¾e vrcholy mÃ´Å¾u maÅ¥ viac synov a kÄ¾ÃºÄov.
4.  **Treap (RandomizovanÃ½ BVS):** KaÅ¾dÃ©mu vrcholu priradÃ­ nÃ¡hodnÃº prioritu a udrÅ¾iava strom tak, aby bol BVS vzhÄ¾adom na kÄ¾ÃºÄe a haldou vzhÄ¾adom na priority. OÄakÃ¡vanÃ¡ vÃ½Å¡ka je O(log n).
5.  **Splay stromy:** Po kaÅ¾dom prÃ­stupe k vrcholu presunÃº tento vrchol do koreÅˆa pomocou sÃ©rie rotÃ¡ciÃ­ ("splaying"). NemajÃº striktnÃº O(log n) zÃ¡ruku pre jednu operÃ¡ciu, ale amortizovanÃ¡ zloÅ¾itosÅ¥ operÃ¡ciÃ­ je O(log n).
6.  **PeriodickÃ© preusporiadanie:** ObÄasnÃ© kompletnÃ© prebudovanie celÃ©ho stromu do dokonale vyvÃ¡Å¾enej formy (napr. ak vÃ½Å¡ka prekroÄÃ­ urÄitÃ½ nÃ¡sobok log n).`
            },
            {
                question: "ÄŒo je to hÄºbka a Äo mohutnosÅ¥ hierarchie:",
                answer: `1.  **HÄºbka hierarchie (Depth/Height of a tree):**
    *   DefinÃ­cia: HÄºbka hierarchie je maximÃ¡lna ÃºroveÅˆ ktorÃ©hokoÄ¾vek vrcholu v hierarchii. ÃšroveÅˆ koreÅˆa sa Äasto definuje ako 0 (alebo niekedy 1). Ak je koreÅˆ na Ãºrovni 0, potom hÄºbka je dÄºÅ¾ka najdlhÅ¡ej cesty od koreÅˆa k niektorÃ©mu listu (poÄet hrÃ¡n).
    *   InÃ½mi slovami, je to najvÃ¤ÄÅ¡ia vzdialenosÅ¥ (poÄet hrÃ¡n) od koreÅˆa k akÃ©mukoÄ¾vek listu v strome.
    *   PrÃ­klad: Ak mÃ¡ strom koreÅˆ na Ãºrovni 0, jeho synovia sÃº na Ãºrovni 1, ich synovia na Ãºrovni 2, atÄ. Ak najvzdialenejÅ¡Ã­ list je na Ãºrovni 3, hÄºbka stromu je 3.

2.  **MohutnosÅ¥ hierarchie (Size/Order of a tree):**
    *   DefinÃ­cia: MohutnosÅ¥ hierarchie je celkovÃ½ poÄet vrcholov v hierarchii.
    *   ZahÅ•Åˆa vÅ¡etky vrcholy - koreÅˆ, vnÃºtornÃ© vrcholy aj listy.
    *   PrÃ­klad: Strom s koreÅˆom, dvoma jeho synmi a kaÅ¾dÃ½ z tÃ½chto synov mÃ¡ jednÃ©ho syna (list), mÃ¡ mohutnosÅ¥ 1 (koreÅˆ) + 2 (synovia koreÅˆa) + 2 (listy) = 5 vrcholov.`
            },
            {
                question: "4 implementÃ¡cie prioritnÃ©ho frontu a zoraÄ ich na zÃ¡klade operÃ¡cie VLOÅ½ (od najlepÅ¡ej):",
                answer: `Zoradenie implementÃ¡ciÃ­ prioritnÃ©ho frontu podÄ¾a zloÅ¾itosti operÃ¡cie **VLOÅ½** (od najlepÅ¡ej po najhorÅ¡iu):

1.  **NeutriedenÃ½ sekvenÄnÃ½ prioritnÃ½ front (implementovanÃ½ ako pole alebo zreÅ¥azenÃ½ zoznam):**
    *   ZloÅ¾itosÅ¥ operÃ¡cie VLOÅ½: **O(1)**
    *   Vysvetlenie: Prvok sa jednoducho pridÃ¡ na koniec sekvencie (alebo na zaÄiatok, ak je to vÃ½hodnejÅ¡ie pre implementÃ¡ciu). NevyÅ¾aduje sa Å¾iadne usporadÃºvanie ani hÄ¾adanie pozÃ­cie.

2.  **Dvojzoznam (AUMS Dvojzoznam):**
    *   ZloÅ¾itosÅ¥ operÃ¡cie VLOÅ½: **O(1) amortizovane**
    *   Vysvetlenie: VkladÃ¡ sa do krÃ¡tkej sekvencie (O(1)), pokiaÄ¾ nie je plnÃ¡. Ak je plnÃ¡, jej obsah sa zlÃºÄi s dlhou sekvenciou, Äo mÃ´Å¾e byÅ¥ O(N), ale tÃ¡to drahÅ¡ia operÃ¡cia sa nedeje Äasto, takÅ¾e amortizovanÃ¡ zloÅ¾itosÅ¥ je O(1).

3.  **Ä½avostrannÃ¡ halda (BinÃ¡rna halda):**
    *   ZloÅ¾itosÅ¥ operÃ¡cie VLOÅ½: **O(log n)**
    *   Vysvetlenie: NovÃ½ prvok sa pridÃ¡ na koniec haldy (ako poslednÃ½ list) a potom sa "prebublÃ¡va" nahor (operÃ¡cia heapify-up alebo sift-up), aby sa obnovila vlastnosÅ¥ haldy. VÃ½Å¡ka binÃ¡rneho stromu s n prvkami je O(log n).

4.  **BinÃ¡rny vyhÄ¾adÃ¡vacÃ­ strom (BVS) ako prioritnÃ½ front:**
    *   ZloÅ¾itosÅ¥ operÃ¡cie VLOÅ½: **O(log n) v priemere, O(n) v najhorÅ¡om prÃ­pade**
    *   Vysvetlenie: Vkladanie do BVS je v priemere logaritmickÃ©, ale ak strom zdegeneruje (napr. pri vkladanÃ­ usporiadanÃ½ch prvkov), zloÅ¾itosÅ¥ sa stane lineÃ¡rnou. Pre prioritnÃ½ front by sa musel pouÅ¾iÅ¥ vyvaÅ¾ovanÃ½ BVS (napr. AVL, Red-Black) na zaruÄenie O(log n).

5.  **UtriedenÃ½ sekvenÄnÃ½ prioritnÃ½ front (implementovanÃ½ ako pole alebo zreÅ¥azenÃ½ zoznam):**
    *   ZloÅ¾itosÅ¥ operÃ¡cie VLOÅ½: **O(n)**
    *   Vysvetlenie: Pri kaÅ¾dom vkladanÃ­ je potrebnÃ© nÃ¡jsÅ¥ sprÃ¡vne miesto v utriedenej sekvencii, aby sa zachovalo usporiadanie podÄ¾a priority. To mÃ´Å¾e vyÅ¾adovaÅ¥ posun aÅ¾ n prvkov v poli, alebo prechod aÅ¾ n prvkami v zreÅ¥azenom zozname.

PoznÃ¡mka: PÃ´vodnÃ¡ otÃ¡zka Å¾iadala 4, text ich uvÃ¡dzal. Pridal som Ä½avostrannÃº haldu ako typickÃº implementÃ¡ciu PF a BVS pre porovnanie. Ak sa mÃ¡me drÅ¾aÅ¥ striktne len 4 z textu (ak tam boli len 4), tak vyberte relevantnÃ©. Poradie je podÄ¾a VLOÅ½.`
            },
            {
                question: "Ä½avostrannÃ¡ halda, opÃ­saÅ¥, napÃ­saÅ¥ APS, operÃ¡cie vÅ¡etky 3 popÃ­saÅ¥ a zloÅ¾itosti k nim aj vysvetliÅ¥ ich:",
                answer: `**Ä½avostrannÃ¡ halda (Leftist Heap/Tree) - PoznÃ¡mka:**
VÃ¡Å¡ text pravdepodobne myslÃ­ **BinÃ¡rnu haldu (Binary Heap)** implementovanÃº pomocou implicitnej binÃ¡rnej hierarchie, ktorÃ¡ sa niekedy (aj keÄ nie Ãºplne presne v akademickom kontexte) oznaÄuje ako "Ä¾avostrannÃ¡" kvÃ´li spÃ´sobu, akÃ½m sa vypÄºÅˆa (ÃºplnÃ½ binÃ¡rny strom sa vypÄºÅˆa zÄ¾ava doprava na poslednej Ãºrovni). Å tandardnÃ¡ "Ä½avostrannÃ¡ halda" (Leftist Heap) je inÃ¡ dÃ¡tovÃ¡ Å¡truktÃºra (typ zlÃºÄiteÄ¾nej haldy). Budem predpokladaÅ¥, Å¾e ide o **BinÃ¡rnu haldu**.

**BinÃ¡rna halda (Binary Heap):**
*   **Opis:** BinÃ¡rna halda je ÃºplnÃ½ binÃ¡rny strom (vÅ¡etky Ãºrovne okrem poslednej sÃº Ãºplne zaplnenÃ© a poslednÃ¡ ÃºroveÅˆ je zaplnenÃ¡ zÄ¾ava doprava), kde kaÅ¾dÃ½ vrchol spÄºÅˆa vlastnosÅ¥ haldy. Pre max-haldu platÃ­, Å¾e hodnota (priorita) v kaÅ¾dom vrchole je vÃ¤ÄÅ¡ia alebo rovnÃ¡ hodnotÃ¡m v jeho synoch. Pre min-haldu je to naopak. Prvok s najvyÅ¡Å¡ou (max-halda) alebo najniÅ¾Å¡ou (min-halda) prioritou je vÅ¾dy v koreni.
*   **ImplementÃ¡cia:** VeÄ¾mi efektÃ­vna implementÃ¡cia pomocou implicitnej binÃ¡rnej hierarchie, typicky v poli. VzÅ¥ahy otec-syn sa vypoÄÃ­tavajÃº pomocou indexov poÄ¾a.
    *   Ä½avÃ½ syn vrcholu na indexe \`i\`: \`2*i + 1\` (ak indexujeme od 0)
    *   PravÃ½ syn vrcholu na indexe \`i\`: \`2*i + 2\` (ak indexujeme od 0)
    *   RodiÄ vrcholu na indexe \`i\`: \`floor((i-1)/2)\` (ak indexujeme od 0)

**APS (AbstraktnÃ¡ pamÃ¤Å¥ovÃ¡ Å¡truktÃºra) pre BinÃ¡rnu haldu:**
*   ImplicitnÃ¡ binÃ¡rna hierarchia uloÅ¾enÃ¡ v kompaktnej pamÃ¤ti (typicky pole).
*   Å truktÃºra: \`Haldy <P, T>\` kde P je typ priority, T je typ Ãºdajov.
    *   Ãšdaje: pole prvkov (kaÅ¾dÃ½ prvok obsahuje prioritu P a Ãºdaje T)
    *   AtribÃºty: \`pocetPrvkov\`, \`kapacitaPola\`

**AUS (AbstraktnÃ¡ ÃºdajovÃ¡ Å¡truktÃºra) pre PrioritnÃ½ front implementovanÃ½ BinÃ¡rnou haldou:**
*   PrioritnÃ½ front <P, T> -> BinÃ¡rna halda <P, T> -> ImplicitnÃ¡ binÃ¡rna hierarchia (pole)

**OperÃ¡cie (pre Max-Haldu):**
1.  **Vrchol (Top/Peek):**
    *   Popis: VrÃ¡ti prvok s najvyÅ¡Å¡ou prioritou (koreÅˆ haldy) bez jeho odstrÃ¡nenia.
    *   ZloÅ¾itosÅ¥: **O(1)**
    *   Vysvetlenie: Prvok s najvyÅ¡Å¡ou prioritou je vÅ¾dy v koreni haldy (prvÃ½ prvok poÄ¾a). PrÃ­stup k nemu je priamy.

2.  **VloÅ¾ (Insert):**
    *   Popis:
        1.  VloÅ¾Ã­ novÃ½ prvok na prvÃ© voÄ¾nÃ© miesto na konci haldy (ako poslednÃ½ list), aby sa zachovala vlastnosÅ¥ ÃºplnÃ©ho binÃ¡rneho stromu. TÃ½m sa zvÃ½Å¡i \`pocetPrvkov\`.
        2.  PorovnÃ¡ vloÅ¾enÃ½ prvok s jeho rodiÄom. Ak mÃ¡ vloÅ¾enÃ½ prvok vyÅ¡Å¡iu prioritu, vymenÃ­ sa s rodiÄom.
        3.  Tento proces vÃ½meny ("prebublÃ¡vanie nahor", sift-up, heapify-up) sa opakuje, kÃ½m prvok nedosiahne koreÅˆ alebo kÃ½m jeho priorita nie je menÅ¡ia alebo rovnÃ¡ priorite jeho rodiÄa (vlastnosÅ¥ haldy je obnovenÃ¡).
    *   ZloÅ¾itosÅ¥: **O(log n)**, kde n je poÄet prvkov v halde.
    *   Vysvetlenie: V najhorÅ¡om prÃ­pade novÃ½ prvok "vystÃºpa" od listu aÅ¾ do koreÅˆa. DÄºÅ¾ka tejto cesty je vÃ½Å¡ka stromu, ktorÃ¡ je O(log n) pre ÃºplnÃ½ binÃ¡rny strom.

3.  **Vyber (Extract-Max/Pop):**
    *   Popis:
        1.  OdstrÃ¡ni a vrÃ¡ti prvok s najvyÅ¡Å¡ou prioritou (koreÅˆ haldy).
        2.  Na miesto koreÅˆa sa presunie poslednÃ½ prvok z haldy (najpravejÅ¡Ã­ list na najniÅ¾Å¡ej Ãºrovni). TÃ½m sa znÃ­Å¾i \`pocetPrvkov\`.
        3.  Tento novÃ½ koreÅˆ sa porovnÃ¡ so svojimi synmi. Ak mÃ¡ niÅ¾Å¡iu prioritu ako niektorÃ½ z jeho synov (vyberie sa syn s vyÅ¡Å¡ou prioritou), vymenÃ­ sa s tÃ½mto synom.
        4.  Tento proces vÃ½meny ("klesanie nadol", sift-down, heapify-down) sa opakuje, kÃ½m prvok nedosiahne pozÃ­ciu listu alebo kÃ½m jeho priorita nie je vÃ¤ÄÅ¡ia alebo rovnÃ¡ prioritÃ¡m oboch jeho synov (vlastnosÅ¥ haldy je obnovenÃ¡).
    *   ZloÅ¾itosÅ¥: **O(log n)**
    *   Vysvetlenie: V najhorÅ¡om prÃ­pade novÃ½ koreÅˆ "klesne" od koreÅˆa aÅ¾ na ÃºroveÅˆ listu. DÄºÅ¾ka tejto cesty je vÃ½Å¡ka stromu, O(log n).`
            },
            {
                question: "Rozdiel medzi hornÃ½m a dolnÃ½m asymptotickÃ½m odhadom a ktorÃ½ je pre programÃ¡tora viac podstatnÃ½ a preÄo:",
                answer: `1.  **HornÃ½ asymptotickÃ½ odhad (O-notÃ¡cia, "Big O"):**
    *   OznaÄuje sa ako O(f(n)).
    *   Vyjadruje **hornÃº hranicu** rastu funkcie Äasovej alebo pamÃ¤Å¥ovej zloÅ¾itosti algoritmu.
    *   ZnamenÃ¡, Å¾e funkcia zloÅ¾itosti T(n) rastie **nanajvÃ½Å¡ tak rÃ½chlo** ako nÃ¡sobok funkcie f(n) pre dostatoÄne veÄ¾kÃ© n. (T(n) â‰¤ c * f(n) pre n â‰¥ nâ‚€).
    *   Popisuje najhorÅ¡Ã­ moÅ¾nÃ½ scenÃ¡r vÃ½konu algoritmu.

2.  **DolnÃ½ asymptotickÃ½ odhad (Î©-notÃ¡cia, "Big Omega"):**
    *   OznaÄuje sa ako Î©(f(n)).
    *   Vyjadruje **dolnÃº hranicu** rastu funkcie Äasovej alebo pamÃ¤Å¥ovej zloÅ¾itosti algoritmu.
    *   ZnamenÃ¡, Å¾e funkcia zloÅ¾itosti T(n) rastie **aspoÅˆ tak rÃ½chlo** ako nÃ¡sobok funkcie f(n) pre dostatoÄne veÄ¾kÃ© n. (T(n) â‰¥ c * f(n) pre n â‰¥ nâ‚€).
    *   Popisuje najlepÅ¡Ã­ moÅ¾nÃ½ scenÃ¡r vÃ½konu algoritmu (algoritmus nemÃ´Å¾e byÅ¥ rÃ½chlejÅ¡Ã­ neÅ¾ toto).

**KtorÃ½ je pre programÃ¡tora viac podstatnÃ½ a preÄo:**

Pre programÃ¡tora je vo vÅ¡eobecnosti **viac podstatnÃ½ hornÃ½ asymptotickÃ½ odhad (O-notÃ¡cia)**, a to z nasledujÃºcich dÃ´vodov:

1.  **Garantuje maximÃ¡lny vÃ½kon (Worst-case scenario):** O-notÃ¡cia poskytuje zÃ¡ruku, Å¾e algoritmus nebude pracovaÅ¥ horÅ¡ie (pomalÅ¡ie, nÃ¡roÄnejÅ¡ie na pamÃ¤Å¥) neÅ¾ danÃ¡ hornÃ¡ hranica, bez ohÄ¾adu na konkrÃ©tne vstupnÃ© dÃ¡ta (pre dostatoÄne veÄ¾kÃ© n). Toto je kÄ¾ÃºÄovÃ© pre predvÃ­dateÄ¾nosÅ¥ a spoÄ¾ahlivosÅ¥ softvÃ©ru, najmÃ¤ v kritickÃ½ch aplikÃ¡ciÃ¡ch.
2.  **OptimalizÃ¡cia a vÃ½ber algoritmu:** ProgramÃ¡tori sa snaÅ¾ia minimalizovaÅ¥ hornÃº hranicu zloÅ¾itosti. Pri porovnÃ¡vanÃ­ dvoch algoritmov pre rovnakÃ½ problÃ©m sa Äasto uprednostnÃ­ ten s lepÅ¡ou (niÅ¾Å¡ou) O-notÃ¡ciou, pretoÅ¾e to znamenÃ¡ lepÅ¡Ã­ vÃ½kon v najhorÅ¡om prÃ­pade.
3.  **PlÃ¡novanie zdrojov:** UmoÅ¾Åˆuje lepÅ¡ie plÃ¡novaÅ¥ potrebnÃ© vÃ½poÄtovÃ© zdroje (Äas CPU, pamÃ¤Å¥) a odhadovaÅ¥ Äas behu programu pre veÄ¾kÃ© vstupy. Ak vieme, Å¾e algoritmus je O(nÂ²), mÃ´Å¾eme oÄakÃ¡vaÅ¥ vÃ½raznÃ© spomalenie pri zdvojnÃ¡sobenÃ­ veÄ¾kosti vstupu.
4.  **KomunikÃ¡cia a analÃ½za:** O-notÃ¡cia je Å¡tandardnÃ½ spÃ´sob, ako diskutovaÅ¥ a porovnÃ¡vaÅ¥ efektivitu algoritmov v informatike.

Aj keÄ Î©-notÃ¡cia je tieÅ¾ dÃ´leÅ¾itÃ¡ (napr. na preukÃ¡zanie, Å¾e algoritmus je optimÃ¡lny, ak sa jeho O-notÃ¡cia zhoduje s Î©-notÃ¡ciou problÃ©mu), O-notÃ¡cia je praktickejÅ¡ia pre kaÅ¾dodennÃ© rozhodovanie programÃ¡tora o vÃ½kone a Å¡kÃ¡lovateÄ¾nosti. ProgramÃ¡tora zaujÃ­ma, ako sa bude jeho kÃ³d sprÃ¡vaÅ¥, keÄ veci "pÃ´jdu zle" alebo keÄ bude musieÅ¥ spracovaÅ¥ veÄ¾kÃ© mnoÅ¾stvo dÃ¡t.`
            },
            {
                question: "Rozdiel medzi primitÃ­vnymi a odvodenÃ½mi typmi:",
                answer: `**PrimitÃ­vne typy (Primitive Types):**
1.  SÃº to zÃ¡kladnÃ©, najjednoduchÅ¡ie ÃºdajovÃ© typy, ktorÃ© sÃº priamo vstavanÃ© do programovacieho jazyka.
2.  Nie sÃº odvodenÃ© od Å¾iadnych inÃ½ch typov.
3.  Typicky zahÅ•ÅˆajÃº:
    *   **CelÃ© ÄÃ­sla** (napr. \`int\`, \`short\`, \`long\`, \`byte\`)
    *   **ReÃ¡lne ÄÃ­sla** (ÄÃ­sla s pohyblivou desatinnou Äiarkou, napr. \`float\`, \`double\`)
    *   **Typ znak** (napr. \`char\`)
    *   **BooleovskÃ½ typ** (logickÃ¡ hodnota, napr. \`boolean\`, \`bool\`, reprezentujÃºci pravda/nepravda)
    *   Niekedy sa sem zaraÄujÃº aj **referencie/ukazovatele** (ako typ schopnÃ½ uchovaÅ¥ adresu), aj keÄ ich povaha je trochu odliÅ¡nÃ¡.
4.  SÃº to Äasto **skalÃ¡rne typy**: ich hodnoty je moÅ¾nÃ© navzÃ¡jom jednoducho porovnÃ¡vaÅ¥ (napr. menÅ¡Ã­, vÃ¤ÄÅ¡Ã­, rovnÃ½ sa).
5.  OperÃ¡cie s nimi sÃº zvyÄajne priamo podporovanÃ© hardvÃ©rom (napr. aritmetickÃ© operÃ¡cie).

**OdvodenÃ© typy (Derived Types / Composite Types / User-Defined Types):**
1.  SÃº to zloÅ¾itejÅ¡ie ÃºdajovÃ© typy, ktorÃ© sÃº vytvorenÃ© programÃ¡torom z primitÃ­vnych typov alebo inÃ½ch odvodenÃ½ch typov.
2.  UmoÅ¾ÅˆujÃº Å¡truktÃºrovaÅ¥ a organizovaÅ¥ dÃ¡ta komplexnejÅ¡Ã­m spÃ´sobom.
3.  ExistujÃº rÃ´zne spÃ´soby vytvÃ¡rania odvodenÃ½ch typov, najÄastejÅ¡ie:
    *   **AgregÃ¡cia (Aggregation / Structuring):** ZlÃºÄenie viacerÃ½ch existujÃºcich typov (primitÃ­vnych alebo odvodenÃ½ch) do jednÃ©ho novÃ©ho typu. PrÃ­klady:
        *   **Å truktÃºry** (struct v C/C++, record v Pascale)
        *   **Triedy** (class v objektovo-orientovanÃ½ch jazykoch ako Java, C++, Python) â€“ triedy sÃº viac neÅ¾ len agregÃ¡cia, zahÅ•ÅˆajÃº aj sprÃ¡vanie (metÃ³dy).
        *   **Polia** (arrays): homogÃ©nna kolekcia prvkov rovnakÃ©ho typu.
        *   **N-tice** (tuples): heterogÃ©nna, usporiadanÃ¡ kolekcia prvkov.
    *   **EnumerÃ¡cia (Enumeration):** Vymenovanie vÅ¡etkÃ½ch moÅ¾nÃ½ch hodnÃ´t, ktorÃ© mÃ´Å¾e typ nadobÃºdaÅ¥. Hodnoty sÃº zvyÄajne symbolickÃ© konÅ¡tanty. PrÃ­klad: \`enum Day { MONDAY, TUESDAY, ..., SUNDAY }\`.
    *   **Ukazovatele/Referencie na inÃ© typy:** Napr. \`int*\` (ukazovateÄ¾ na celÃ© ÄÃ­slo).
    *   **Uniony:** UmoÅ¾ÅˆujÃº uchovÃ¡vaÅ¥ rÃ´zne typy dÃ¡t v tom istom pamÃ¤Å¥ovom mieste (ale vÅ¾dy len jeden typ naraz).

**KÄ¾ÃºÄovÃ© rozdiely:**
*   **ZÃ¡klad vs. KonÅ¡trukcia:** PrimitÃ­vne typy sÃº zÃ¡kladnÃ© stavebnÃ© bloky, odvodenÃ© typy sÃº z nich konÅ¡truovanÃ©.
*   **ZloÅ¾itosÅ¥:** PrimitÃ­vne typy sÃº jednoduchÃ©, odvodenÃ© mÃ´Å¾u byÅ¥ Ä¾ubovoÄ¾ne zloÅ¾itÃ©.
*   **VstavanosÅ¥:** PrimitÃ­vne sÃº zvyÄajne vstavanÃ© v jazyku, odvodenÃ© definuje programÃ¡tor (aj keÄ niektorÃ© odvodenÃ©, ako pole, mÃ´Å¾u maÅ¥ Å¡peciÃ¡lnu syntax v jazyku).`
            },
            {
                question: "ÄŒo sa ukladÃ¡ v halde, ako sa tam alokuje a dealokuje, Äo je ukazovateÄ¾ a Äo je visiaci ukazovateÄ¾ a Äo je to a kedy vznikÃ¡ Ãºnik pamÃ¤te:",
                answer: `**Halda (Heap):**
ÄŒasÅ¥ pamÃ¤te programu urÄenÃ¡ na dynamickÃº alokÃ¡ciu pamÃ¤te.

1.  **ÄŒo sa ukladÃ¡ v halde:**
    *   **Dynamicky alokovanÃ© premennÃ©/objekty:** PremennÃ©, ktorÃ½ch veÄ¾kosÅ¥ alebo Å¾ivotnosÅ¥ nie je znÃ¡ma v Äase kompilÃ¡cie, alebo ktorÃ© majÃº pretrvÃ¡vaÅ¥ medzi volaniami funkciÃ­.
    *   Objekty vytvorenÃ© pomocou operÃ¡tora \`new\` (v C++, Java, C#) alebo funkciÃ­ ako \`malloc\`, \`calloc\`, \`realloc\` (v C/C++).
    *   PremennÃ©, ktorÃ© sÃº prÃ­liÅ¡ veÄ¾kÃ© na to, aby sa zmestili na zÃ¡sobnÃ­k (stack).

2.  **Ako sa alokuje v halde:**
    *   ProgramÃ¡tor explicitne Å¾iada o blok pamÃ¤te urÄitej veÄ¾kosti.
    *   V C: pomocou funkciÃ­ \`malloc(size)\`, \`calloc(num, size)\`, \`realloc(ptr, new_size)\`.
    *   V C++: pomocou operÃ¡tora \`new\` (pre objekty volÃ¡ aj konÅ¡truktor) alebo spomÃ­nanÃ½ch C funkciÃ­.
    *   VÃ½sledkom alokÃ¡cie je **ukazovateÄ¾** (adresa) na zaÄiatok alokovanÃ©ho bloku pamÃ¤te v halde. Ak alokÃ¡cia zlyhÃ¡ (napr. nedostatok pamÃ¤te), vrÃ¡ti sa NULL (pre C funkcie) alebo sa vyhodÃ­ vÃ½nimka (pre C++ \`new\`).

3.  **Ako sa dealokuje z haldy:**
    *   ProgramÃ¡tor musÃ­ explicitne uvoÄ¾niÅ¥ alokovanÃº pamÃ¤Å¥, keÄ ju uÅ¾ nepotrebuje.
    *   V C: pomocou funkcie \`free(pointer)\`.
    *   V C++: pomocou operÃ¡tora \`delete pointer\` (pre jednotlivÃ© objekty, volÃ¡ aj deÅ¡truktor) alebo \`delete[] pointer\` (pre polia objektov).
    *   Ako parameter sa poÅ¾aduje ukazovateÄ¾ na zaÄiatok bloku pamÃ¤te, ktorÃ½ mÃ¡ byÅ¥ uvoÄ¾nenÃ½.

4.  **UkazovateÄ¾ (Pointer):**
    *   PremennÃ¡, ktorej hodnota je **adresa inÃ©ho miesta v pamÃ¤ti**.
    *   UmoÅ¾Åˆuje nepriamy prÃ­stup k dÃ¡tam uloÅ¾enÃ½m na tejto adrese (tzv. dereferencovanie).
    *   V kontexte haldy ukazovatele uchovÃ¡vajÃº adresy dynamicky alokovanÃ½ch blokov pamÃ¤te.

5.  **Visiaci ukazovateÄ¾ (Dangling Pointer):**
    *   UkazovateÄ¾, ktorÃ½ ukazuje na adresu v pamÃ¤ti, ktorÃ¡ uÅ¾ bola **dealokovanÃ¡** (uvoÄ¾nenÃ¡) alebo ktorej obsah uÅ¾ nie je platnÃ½ (napr. ukazovateÄ¾ na lokÃ¡lnu premennÃº funkcie, ktorÃ¡ uÅ¾ skonÄila).
    *   PouÅ¾itie (dereferencovanie) visiaceho ukazovateÄ¾a vedie k nedefinovanÃ©mu sprÃ¡vaniu, Äasto k pÃ¡du programu alebo poÅ¡kodeniu dÃ¡t.
    *   PrÃ­klad:
        \`\`\`c
        int *p;
        {
            int x = 10;
            p = &x;
        } // x zanikÃ¡, p je teraz visiaci ukazovateÄ¾
        // *p = 20; // Chyba! NedefinovanÃ© sprÃ¡vanie
        \`\`\`
        Alebo:
        \`\`\`c
        int *ptr = (int*)malloc(sizeof(int));
        free(ptr);
        // ptr je teraz visiaci ukazovateÄ¾
        // *ptr = 5; // Chyba!
        \`\`\`

6.  **Ãšnik pamÃ¤te (Memory Leak):**
    *   VznikÃ¡, keÄ program **stratÃ­ vÅ¡etky referencie (ukazovatele) na dynamicky alokovanÃ½ blok pamÃ¤te v halde bez toho, aby tÃºto pamÃ¤Å¥ predtÃ½m uvoÄ¾nil.**
    *   AlokovanÃ¡ pamÃ¤Å¥ zostÃ¡va obsadenÃ¡, ale program k nej uÅ¾ nemÃ¡ prÃ­stup, a teda ju nemÃ´Å¾e ani pouÅ¾iÅ¥, ani uvoÄ¾niÅ¥.
    *   DÃ´sledok: PostupnÃ© vyÄerpÃ¡vanie dostupnej pamÃ¤te, Äo mÃ´Å¾e viesÅ¥ k spomaleniu alebo pÃ¡du programu, prÃ­padne celÃ©ho systÃ©mu.
    *   PrÃ­klad:
        \`\`\`c
        void memory_leak_example() {
            int *ptr = (int*)malloc(sizeof(int));
            // ... nejakÃ¡ prÃ¡ca s ptr ...
            // Zabudli sme zavolaÅ¥ free(ptr)
            // KeÄ funkcia skonÄÃ­, ukazovateÄ¾ ptr zanikne,
            // ale alokovanÃ¡ pamÃ¤Å¥ zostane obsadenÃ¡.
        }

        // Alebo
        int *global_ptr = (int*)malloc(sizeof(int));
        global_ptr = (int*)malloc(sizeof(int)); // Adresa prvÃ©ho bloku sa stratila
        \`\`\`
    *   **Prevencia:**
        *   DÃ´slednÃ© uvoÄ¾Åˆovanie pamÃ¤te (\`free\`, \`delete\`).
        *   PouÅ¾Ã­vanie technÃ­k ako RAII (Resource Acquisition Is Initialization) v C++.
        *   InteligentnÃ© ukazovatele (smart pointers ako \`std::unique_ptr\`, \`std::shared_ptr\` v C++), ktorÃ© automatizujÃº sprÃ¡vu pamÃ¤te.
        *   V jazykoch s automatickou sprÃ¡vou pamÃ¤te (Garbage Collector - GC), ako Java alebo C#, sa GC starÃ¡ o uvoÄ¾Åˆovanie nedosiahnuteÄ¾nej pamÃ¤te, ÄÃ­m predchÃ¡dza vÃ¤ÄÅ¡ine Ãºnikov pamÃ¤te (aj keÄ nie vÅ¡etkÃ½m typom Ãºnikov zdrojov).`
            },
            {
                question: "3 prÃ­klady APT a k nim APS:",
                answer: `APT (AbstraktnÃ½ PamÃ¤Å¥ovÃ½ Typ) definuje, ako ÃºdajovÃ¡ Å¡truktÃºra organizuje bloky pamÃ¤te a operÃ¡cie s nimi. APS (AbstraktnÃ¡ PamÃ¤Å¥ovÃ¡ Å truktÃºra) je konkrÃ©tna realizÃ¡cia APT.

1.  **APT: Sekvencia (Sequence)**
    *   Popis: Bloky pamÃ¤te sÃº usporiadanÃ© lineÃ¡rne, kaÅ¾dÃ½ blok (okrem prÃ­padne prvÃ©ho/poslednÃ©ho) mÃ¡ svojho predchodcu a/alebo nasledovnÃ­ka.
    *   **PrÃ­klady APS pre Sekvenciu:**
        *   **ImplicitnÃ¡ sekvencia (Implicit Sequence):**
            *   Bloky pamÃ¤te sÃº uloÅ¾enÃ© v sÃºvislom bloku pamÃ¤te (napr. pole).
            *   VzÅ¥ahy medzi blokmi (nasledovnÃ­k, predchodca) sÃº vyjadrenÃ© matematicky pomocou indexov (napr. nasledovnÃ­k bloku na indexe \`i\` je na indexe \`i+1\`).
            *   Bloky pamÃ¤te nemajÃº explicitnÃº vzÅ¥ahovÃº ÄasÅ¥ pre tieto zÃ¡kladnÃ© sekvenÄnÃ© vzÅ¥ahy.
        *   **ExplicitnÃ¡ sekvencia v kompaktnej pamÃ¤ti (Explicit Sequence in Compact Memory):**
            *   Bloky pamÃ¤te majÃº explicitne uloÅ¾enÃº vzÅ¥ahovÃº ÄasÅ¥ (ukazovateÄ¾/referenciu na nasledovnÃ­ka, prÃ­padne aj predchodcu).
            *   Tieto bloky sÃº vÅ¡ak stÃ¡le alokovanÃ© v jednom sÃºvislom bloku pamÃ¤te (napr. pole Å¡truktÃºr, kde kaÅ¾dÃ¡ Å¡truktÃºra mÃ¡ dÃ¡tovÃº a vzÅ¥ahovÃº ÄasÅ¥).
        *   **ExplicitnÃ¡ sekvencia v dynamickej pamÃ¤ti (Explicit Sequence in Dynamic Memory - napr. zreÅ¥azenÃ½ zoznam):**
            *   Bloky pamÃ¤te sÃº alokovanÃ© jednotlivo v dynamickej pamÃ¤ti (halde).
            *   KaÅ¾dÃ½ blok obsahuje dÃ¡tovÃº ÄasÅ¥ a vzÅ¥ahovÃº ÄasÅ¥ (ukazovateÄ¾ na nasledovnÃ­ka, prÃ­padne aj predchodcu).

2.  **APT: Hierarchia (Hierarchy)**
    *   Popis: Bloky pamÃ¤te sÃº usporiadanÃ© hierarchicky (stromovo), s jednÃ½m koreÅˆovÃ½m blokom. KaÅ¾dÃ½ blok (okrem koreÅˆa) mÃ¡ jednÃ©ho rodiÄa a mÃ´Å¾e maÅ¥ nula alebo viac synov.
    *   **PrÃ­klady APS pre Hierarchiu:**
        *   **ImplicitnÃ¡ hierarchia (Implicit Hierarchy):**
            *   Typicky pre kompletnÃ© k-cestnÃ© stromy, uloÅ¾enÃ© v sÃºvislom bloku pamÃ¤te (napr. pole pre binÃ¡rnu haldu).
            *   VzÅ¥ahy medzi blokmi (rodiÄ, synovia) sÃº vyjadrenÃ© matematicky pomocou indexov.
        *   **ExplicitnÃ¡ hierarchia v kompaktnej pamÃ¤ti (Explicit Hierarchy in Compact Memory):**
            *   Bloky pamÃ¤te (vrcholy) majÃº explicitne uloÅ¾enÃ© referencie na synov (a prÃ­padne rodiÄa).
            *   Tieto bloky sÃº alokovanÃ© v sÃºvislom bloku pamÃ¤te (napr. pole vrcholov, kde kaÅ¾dÃ½ vrchol je Å¡truktÃºra s dÃ¡tami a referenciami).
        *   **ExplicitnÃ¡ hierarchia v dynamickej pamÃ¤ti (Explicit Hierarchy in Dynamic Memory - napr. dynamicky alokovanÃ½ strom):**
            *   KaÅ¾dÃ½ vrchol je samostatne alokovanÃ½ v dynamickej pamÃ¤ti.
            *   Vrcholy obsahujÃº dÃ¡ta a explicitnÃ© referencie (ukazovatele) na svojich synov (a prÃ­padne rodiÄa).

3.  **APT: SieÅ¥ (Network / Graph)**
    *   Popis: Bloky pamÃ¤te (vrcholy) mÃ´Å¾u byÅ¥ Ä¾ubovoÄ¾ne prepojenÃ© s inÃ½mi blokmi (hranami). VzÅ¥ahy nie sÃº nutne lineÃ¡rne ani hierarchickÃ©.
    *   **PrÃ­klady APS pre SieÅ¥:**
        *   **Matica susednosti (Adjacency Matrix):**
            *   ReprezentovanÃ¡ 2D poÄ¾om, kde prvok \`M[i][j]\` indikuje existenciu (a prÃ­padne vÃ¡hu) hrany medzi vrcholom \`i\` a vrcholom \`j\`. VhodnÃ¡ pre hustÃ© grafy.
            *   PamÃ¤Å¥ovÃ¡ Å¡truktÃºra: implicitnÃ¡ sekvencia (pole) polÃ­.
        *   **Zoznamy susednosti (Adjacency Lists):**
            *   Pre kaÅ¾dÃ½ vrchol sa udrÅ¾iava zoznam (napr. zreÅ¥azenÃ½ zoznam alebo dynamickÃ© pole) jeho susedov. VhodnÃ© pre riedke grafy.
            *   PamÃ¤Å¥ovÃ¡ Å¡truktÃºra: pole (implicitnÃ¡ sekvencia) zreÅ¥azenÃ½ch zoznamov (explicitnÃ© sekvencie).
        *   **StatickÃ¡ sieÅ¥ (Static Network):**
            *   PoÄet vrcholov a hrÃ¡n je fixnÃ½ a znÃ¡my vopred. MÃ´Å¾e byÅ¥ implementovanÃ¡ pomocou matice susednosti alebo statickÃ½ch zoznamov susednosti.
            *   BrÃ¡na (ak je pouÅ¾itÃ¡ na prÃ­stup k vrcholom) mÃ´Å¾e byÅ¥ implicitnÃ¡ sekvencia.
        *   **DynamickÃ¡ sieÅ¥ (Dynamic Network):**
            *   PoÄet vrcholov a hrÃ¡n sa mÃ´Å¾e meniÅ¥ poÄas behu. Typicky implementovanÃ¡ pomocou zoznamov susednosti s dynamickou alokÃ¡ciou.
            *   BrÃ¡na (ak je pouÅ¾itÃ¡) je Äasto explicitnÃ¡ sekvencia (napr. zreÅ¥azenÃ½ zoznam referenciÃ­ na vrcholy).`
            },
            {
                question: "Rozdiel medzi dynamickÃ½mi a statickÃ½mi sieÅ¥ami:",
                answer: `Rozdiel medzi dynamickÃ½mi a statickÃ½mi sieÅ¥ami (grafmi) sa tÃ½ka najmÃ¤ ich schopnosti meniÅ¥ Å¡truktÃºru (poÄet vrcholov a hrÃ¡n) poÄas behu programu a spÃ´sobu ich implementÃ¡cie.

**StatickÃ¡ sieÅ¥ (Static Network):**
1.  **Å truktÃºra:**
    *   PoÄet vrcholov a hrÃ¡n je **fixnÃ½** a znÃ¡my v Äase kompilÃ¡cie alebo inicializÃ¡cie.
    *   Å truktÃºra siete sa poÄas behu programu **nemenÃ­** (nie je moÅ¾nÃ© pridÃ¡vaÅ¥ ani odoberaÅ¥ vrcholy Äi hrany).
2.  **ImplementÃ¡cia:**
    *   ÄŒasto implementovanÃ¡ pomocou **matice susednosti** (2D pole), kde veÄ¾kosÅ¥ matice je urÄenÃ¡ maximÃ¡lnym poÄtom vrcholov.
    *   MÃ´Å¾e byÅ¥ implementovanÃ¡ aj pomocou **zoznamov susednosti**, ak sÃº tieto zoznamy statickej veÄ¾kosti alebo alokovanÃ© naraz.
    *   **ImplementÃ¡cia brÃ¡ny** (ak sa pouÅ¾Ã­va na prÃ­stup k vrcholom, napr. zoznam vÅ¡etkÃ½ch vrcholov): Typicky **implicitnÃ¡ sekvencia** (napr. pole referenciÃ­ na vrcholy), pretoÅ¾e poÄet vrcholov je fixnÃ½.
3.  **Efektivita modifikÃ¡torov:**
    *   ModifikÃ¡tory (operÃ¡cie na pridanie/odobratie vrcholu/hrany) **nie sÃº podporovanÃ©** alebo sÃº veÄ¾mi neefektÃ­vne (vyÅ¾adovali by vytvorenie novej statickej siete).
4.  **Flexibilita:**
    *   **NÃ­zka flexibilita**, keÄÅ¾e Å¡truktÃºra je pevne danÃ¡.
5.  **PamÃ¤Å¥ovÃ¡ nÃ¡roÄnosÅ¥:**
    *   MÃ´Å¾e byÅ¥ predvÃ­dateÄ¾nÃ¡. Matica susednosti mÃ¡ vÅ¾dy O(VÂ²) pamÃ¤Å¥ovÃº nÃ¡roÄnosÅ¥ (V je poÄet vrcholov), aj keÄ je graf riedky.
    *   Pri pouÅ¾itÃ­ statickÃ½ch zoznamov susednosti je nÃ¡roÄnosÅ¥ O(V+E) (E je poÄet hrÃ¡n).
6.  **PouÅ¾itie:** VhodnÃ¡ pre problÃ©my, kde je Å¡truktÃºra grafu nemennÃ¡ a znÃ¡ma vopred (napr. mapy ciest, ktorÃ© sa nemenia, pevnÃ© komunikaÄnÃ© siete).

**DynamickÃ¡ sieÅ¥ (Dynamic Network):**
1.  **Å truktÃºra:**
    *   PoÄet vrcholov a hrÃ¡n sa **mÃ´Å¾e meniÅ¥** poÄas behu programu.
    *   Je moÅ¾nÃ© dynamicky **pridÃ¡vaÅ¥ a odoberaÅ¥** vrcholy a hrany.
2.  **ImplementÃ¡cia:**
    *   Typicky implementovanÃ¡ pomocou **zoznamov susednosti**, kde kaÅ¾dÃ½ zoznam je dynamickÃ¡ Å¡truktÃºra (napr. zreÅ¥azenÃ½ zoznam, dynamickÃ© pole/vector).
    *   Menej Äasto pomocou matice susednosti, ak sa maximÃ¡lny poÄet vrcholov neustÃ¡le menÃ­ (vyÅ¾adovalo by to realokÃ¡ciu matice).
    *   **ImplementÃ¡cia brÃ¡ny:** Typicky **explicitnÃ¡ sekvencia** (napr. zreÅ¥azenÃ½ zoznam alebo dynamickÃ© pole referenciÃ­ na vrcholy), pretoÅ¾e poÄet vrcholov sa menÃ­.
3.  **Efektivita modifikÃ¡torov:**
    *   **EfektÃ­vne modifikÃ¡tory** pre pridÃ¡vanie a odoberanie vrcholov a hrÃ¡n (v zÃ¡vislosti od konkrÃ©tnej implementÃ¡cie zoznamov susednosti).
4.  **Flexibilita:**
    *   **VysokÃ¡ flexibilita**, umoÅ¾Åˆuje adaptovaÅ¥ sa na meniace sa podmienky.
5.  **PamÃ¤Å¥ovÃ¡ nÃ¡roÄnosÅ¥:**
    *   PamÃ¤Å¥ovÃ¡ nÃ¡roÄnosÅ¥ je typicky O(V+E), Äo je efektÃ­vne pre riedke grafy.
    *   MÃ´Å¾e byÅ¥ menej predvÃ­dateÄ¾nÃ¡, keÄÅ¾e zÃ¡visÃ­ od aktuÃ¡lneho poÄtu vrcholov a hrÃ¡n. Potreba dynamickej alokÃ¡cie mÃ´Å¾e priniesÅ¥ urÄitÃº rÃ©Å¾iu.
6.  **PouÅ¾itie:** VhodnÃ¡ pre problÃ©my, kde sa Å¡truktÃºra grafu vyvÃ­ja v Äase (napr. sociÃ¡lne siete, modelovanie dynamickÃ½ch systÃ©mov, smerovacie protokoly).

**Zhrnutie kÄ¾ÃºÄovÃ½ch rozdielov:**
*   **Zmena Å¡truktÃºry:** StatickÃ¡ - nemennÃ¡, DynamickÃ¡ - meniteÄ¾nÃ¡.
*   **ModifikÃ¡tory:** StatickÃ¡ - neefektÃ­vne/nepodporovanÃ©, DynamickÃ¡ - efektÃ­vne.
*   **ImplementÃ¡cia brÃ¡ny:** StatickÃ¡ - Äasto implicitnÃ¡ sekvencia, DynamickÃ¡ - Äasto explicitnÃ¡ sekvencia.
*   **Flexibilita:** StatickÃ¡ - nÃ­zka, DynamickÃ¡ - vysokÃ¡.`
            },
            {
                question: "ÄŒo je to kvadratickÃ¡ zloÅ¾itosÅ¥ a 3 prÃ­klady:",
                answer: `**KvadratickÃ¡ zloÅ¾itosÅ¥ (Quadratic Complexity):**
KvadratickÃ¡ zloÅ¾itosÅ¥ je trieda Äasovej alebo pamÃ¤Å¥ovej zloÅ¾itosti algoritmu, kde poÄet operÃ¡ciÃ­ (alebo potrebnÃ¡ pamÃ¤Å¥) rastie Ãºmerne **druhej mocnine veÄ¾kosti vstupu**. V asymptotickej notÃ¡cii sa oznaÄuje ako **O(nÂ²)**, kde 'n' je veÄ¾kosÅ¥ vstupu.

To znamenÃ¡, Å¾e ak sa veÄ¾kosÅ¥ vstupu zdvojnÃ¡sobÃ­, Äas potrebnÃ½ na vykonanie algoritmu sa pribliÅ¾ne zoÅ¡tvornÃ¡sobÃ­ (2Â² = 4). Ak sa vstup zdesaÅ¥nÃ¡sobÃ­, Äas sa pribliÅ¾ne zostonÃ¡sobÃ­ (10Â² = 100). Algoritmy s kvadratickou zloÅ¾itosÅ¥ou sa stÃ¡vajÃº neprakticky pomalÃ½mi pre veÄ¾kÃ© vstupy.

**PrÃ­klady algoritmov alebo operÃ¡ciÃ­ s kvadratickou zloÅ¾itosÅ¥ou O(nÂ²):**

1.  **JednoduchÃ© triediace algoritmy (v najhorÅ¡om alebo priemernom prÃ­pade):**
    *   **Bubble Sort:** V kaÅ¾dom prechode porovnÃ¡va susednÃ© prvky a vymieÅˆa ich, ak nie sÃº v sprÃ¡vnom poradÃ­. VyÅ¾aduje n prechodov a v kaÅ¾dom prechode aÅ¾ n-1 porovnanÃ­.
    *   **Selection Sort:** V kaÅ¾dom prechode nÃ¡jde minimÃ¡lny (alebo maximÃ¡lny) prvok zo zostÃ¡vajÃºcej netriedenej Äasti a umiestni ho na sprÃ¡vnu pozÃ­ciu. VyÅ¾aduje n prechodov a v kaÅ¾dom prechode hÄ¾adanie minima v zmenÅ¡ujÃºcej sa Äasti poÄ¾a.
    *   **Insertion Sort:** V najhorÅ¡om prÃ­pade (napr. pole utriedenÃ© opaÄne) kaÅ¾dÃ½ prvok musÃ­ byÅ¥ posunutÃ½ cez uÅ¾ utriedenÃº ÄasÅ¥ poÄ¾a.
    *   *DÃ´vod:* Tieto algoritmy Äasto zahÅ•ÅˆajÃº vnorenÃ© cykly, kde vonkajÅ¡Ã­ cyklus prechÃ¡dza n-krÃ¡t a vnÃºtornÃ½ cyklus tieÅ¾ prechÃ¡dza pribliÅ¾ne n-krÃ¡t pre kaÅ¾dÃ½ prechod vonkajÅ¡ieho cyklu.

2.  **PrechÃ¡dzanie vÅ¡etkÃ½ch pÃ¡rov prvkov v kolekcii:**
    *   Ãšloha: NÃ¡jsÅ¥ vÅ¡etky moÅ¾nÃ© dvojice prvkov v poli alebo zozname veÄ¾kosti n.
    *   PrÃ­klad: Overenie, Äi v poli existujÃº duplicitnÃ© prvky, porovnanÃ­m kaÅ¾dÃ©ho prvku s kaÅ¾dÃ½m inÃ½m prvkom.
        \`\`\`python
        # PrÃ­klad kÃ³du (Python)
        def find_duplicates_quadratic(arr):
            n = len(arr)
            for i in range(n):
                for j in range(i + 1, n): # VnÃºtornÃ½ cyklus
                    if arr[i] == arr[j]:
                        return True # NaÅ¡iel sa duplikÃ¡t
            return False
        \`\`\`
    *   *DÃ´vod:* Dva vnorenÃ© cykly, kde vonkajÅ¡Ã­ iteruje \`n\` krÃ¡t a vnÃºtornÃ½ v priemere \`n/2\` krÃ¡t, Äo vedie k O(nÂ²) operÃ¡ciÃ¡m.

3.  **NiektorÃ© operÃ¡cie s maticami (ak n reprezentuje rozmer matice n x n):**
    *   **SÄÃ­tanie alebo odÄÃ­tanie dvoch matÃ­c n x n:** KaÅ¾dÃ½ z nÂ² prvkov jednej matice sa sÄÃ­ta/odÄÃ­ta s koreÅ¡pondujÃºcim prvkom druhej matice. OperÃ¡cia pre kaÅ¾dÃ½ prvok je O(1), celkovo O(nÂ²).
    *   **Priama implementÃ¡cia nÃ¡sobenia dvoch matÃ­c n x n** mÃ¡ zloÅ¾itosÅ¥ O(nÂ³). AvÅ¡ak, ak by sme mali operÃ¡ciu, ktorÃ¡ vyÅ¾aduje prÃ­stup ku kaÅ¾dÃ©mu prvku jednej matice n x n a pre kaÅ¾dÃ½ z nich vykonala O(1) operÃ¡ciu, bola by to O(nÂ²).
    *   **Vytvorenie matice susednosti pre graf s V vrcholmi:** Ak inicializujeme maticu V x V, je to O(VÂ²).
    *   V dokumente sa spomÃ­na: "Porovnanie v sieÅ¥ach: Dokument uvÃ¡dza, Å¾e operÃ¡cia 'Porovnaj' v sieÅ¥ach mÃ¡ zloÅ¾itosÅ¥ O(vÂ²)." Toto by mohlo znamenaÅ¥ naprÃ­klad porovnanie vÅ¡etkÃ½ch vrcholov navzÃ¡jom alebo podobnÃº operÃ¡ciu vyÅ¾adujÃºcu prÃ¡cu so vÅ¡etkÃ½mi pÃ¡rmi vrcholov v sieti s 'v' vrcholmi.

**PoznÃ¡mka:** VÃ¡Å¡ text uvÃ¡dzal "algoritmus pre nÃ¡sobenie dvoch nÃ—n matÃ­c mÃ¡ zloÅ¾itosÅ¥ O(nÂ³)", Äo je pravda pre Å¡tandardnÃ½ algoritmus. SÄÃ­tanie/odÄÃ­tanie matÃ­c je vÅ¡ak O(nÂ²).`
            },
            {
                question: "Rozdiel medzi ukazovateÄ¾om a odkazom:",
                answer: `Rozdiel medzi ukazovateÄ¾om (pointer) a odkazom (reference) je dÃ´leÅ¾itÃ½ najmÃ¤ v jazykoch ako C++. Oba slÃºÅ¾ia na nepriamy prÃ­stup k dÃ¡tam, ale majÃº odliÅ¡nÃ© vlastnosti a pouÅ¾itie.

**UkazovateÄ¾ (Pointer):**
1.  **DefinÃ­cia:** Å pecifickÃ½ ÃºdajovÃ½ typ (premennÃ¡), ktorÃ½ je schopnÃ½ uchovÃ¡vaÅ¥ **adresu** inÃ©ho objektu (premennej) v pamÃ¤ti.
2.  **InicializÃ¡cia:** MÃ´Å¾e byÅ¥ neinicializovanÃ½, mÃ´Å¾e byÅ¥ inicializovanÃ½ na NULL (neukazuje na Å¾iadny platnÃ½ objekt), alebo mÃ´Å¾e byÅ¥ inicializovanÃ½ adresou existujÃºceho objektu.
3.  **Zmena cieÄ¾a:** UkazovateÄ¾ **mÃ´Å¾e meniÅ¥ adresu**, na ktorÃº ukazuje poÄas svojej Å¾ivotnosti. MÃ´Å¾e byÅ¥ presmerovanÃ½ na inÃ½ objekt rovnakÃ©ho (alebo kompatibilnÃ©ho) typu.
    \`\`\`cpp
    int x = 10;
    int y = 20;
    int* ptr = &x; // ptr ukazuje na x
    ptr = &y;     // ptr teraz ukazuje na y
    ptr = nullptr; // ptr teraz neukazuje nikam
    \`\`\`
4.  **Aritmetika ukazovateÄ¾ov:** Podporuje Å¡peciÃ¡lne aritmetickÃ© operÃ¡cie (napr. pripoÄÃ­tanie celÃ©ho ÄÃ­sla k ukazovateÄ¾u posunie adresu o nÃ¡sobok veÄ¾kosti typu, na ktorÃ½ ukazuje). Toto je uÅ¾itoÄnÃ© pri prÃ¡ci s poliami.
5.  **Dereferencovanie:** Pre prÃ­stup k hodnote objektu, na ktorÃ½ ukazovateÄ¾ ukazuje, sa pouÅ¾Ã­va operÃ¡tor dereferencovania (napr. \`*\` v C/C++).
    \`\`\`cpp
    *ptr = 30; // Modifikuje hodnotu objektu, na ktorÃ½ ptr ukazuje
    \`\`\`
6.  **PouÅ¾itie:** ÄŒasto sa vyuÅ¾Ã­va na uchovÃ¡vanie adries dynamicky alokovanÃ½ch premennÃ½ch (z haldy), na implementÃ¡ciu dÃ¡tovÃ½ch Å¡truktÃºr ako zreÅ¥azenÃ© zoznamy a stromy, a na odovzdÃ¡vanie argumentov funkciÃ¡m "referenciou" (v C, alebo ako alternatÃ­va k referenciÃ¡m v C++).

**Odkaz (Reference) - primÃ¡rne v C++:**
1.  **DefinÃ­cia:** AlternatÃ­vny **nÃ¡zov (alias)** pre uÅ¾ existujÃºci objekt v pamÃ¤ti. Odkaz nie je samostatnÃ½ objekt v tom zmysle, Å¾e by mal vlastnÃº pamÃ¤Å¥ovÃº adresu (ako ukazovateÄ¾); je to skÃ´r inÃ© meno pre tÃº istÃº pamÃ¤Å¥ovÃº lokÃ¡ciu.
2.  **InicializÃ¡cia:** Odkaz **musÃ­ byÅ¥ inicializovanÃ½ pri svojom vzniku** a musÃ­ odkazovaÅ¥ na platnÃ½ existujÃºci objekt. NemÃ´Å¾e byÅ¥ NULL a nemÃ´Å¾e byÅ¥ neinicializovanÃ½.
    \`\`\`cpp
    int x = 10;
    int& ref = x; // ref je teraz alias pre x
    // int& bad_ref; // Chyba: odkaz musÃ­ byÅ¥ inicializovanÃ½
    \`\`\`
3.  **Zmena cieÄ¾a:** Od svojho vzniku aÅ¾ do svojho zÃ¡niku **musÃ­ odkazovaÅ¥ vÅ¾dy len na ten istÃ½ objekt** (pamÃ¤Å¥ovÃ© miesto), na ktorÃ½ bol pri svojom vzniku nastavenÃ½. Nie je moÅ¾nÃ© "presmerovaÅ¥" odkaz na inÃ½ objekt.
    \`\`\`cpp
    int y = 20;
    // ref = y; // Toto NEZMENÃ ref, aby ukazoval na y.
              // Namiesto toho to priradÃ­ hodnotu y do x (pretoÅ¾e ref je alias pre x).
              // TakÅ¾e x sa stane 20.
    \`\`\`
4.  **Aritmetika odkazov:** Aritmetika odkazov nie je priamo podporovanÃ¡.
5.  **Dereferencovanie:** PouÅ¾Ã­va sa **implicitne**. KeÄ pouÅ¾ijete nÃ¡zov odkazu, automaticky pristupujete k objektu, na ktorÃ½ odkazuje. Nie je potrebnÃ½ Å¡peciÃ¡lny operÃ¡tor dereferencovania.
    \`\`\`cpp
    ref = 30; // Modifikuje hodnotu x (pretoÅ¾e ref je alias pre x)
    \`\`\`
6.  **PouÅ¾itie:** ÄŒasto sa pouÅ¾Ã­va na odovzdÃ¡vanie argumentov funkciÃ¡m (pass-by-reference) pre efektÃ­vnosÅ¥ a moÅ¾nosÅ¥ modifikÃ¡cie pÃ´vodnÃ©ho argumentu, a na vracanie hodnÃ´t z funkciÃ­ referenciou. Syntax je Äasto ÄistejÅ¡ia ako pri ukazovateÄ¾och.

**KÄ¾ÃºÄovÃ© rozdiely zhrnutÃ©:**
*   **InicializÃ¡cia:** UkazovateÄ¾ mÃ´Å¾e byÅ¥ neinicializovanÃ½ alebo NULL. Odkaz musÃ­ byÅ¥ inicializovanÃ½ na existujÃºci objekt.
*   **Zmena cieÄ¾a (Re-seating):** UkazovateÄ¾ mÃ´Å¾e zmeniÅ¥, na Äo ukazuje. Odkaz nemÃ´Å¾e; vÅ¾dy odkazuje na ten istÃ½ objekt.
*   **NULL hodnota:** UkazovateÄ¾ mÃ´Å¾e byÅ¥ NULL. Odkaz nemÃ´Å¾e byÅ¥ NULL (musÃ­ odkazovaÅ¥ na platnÃ½ objekt).
*   **Syntax prÃ­stupu:** UkazovateÄ¾ vyÅ¾aduje dereferencovanie (\`*\` alebo \`->\`). Odkaz sa pouÅ¾Ã­va priamo ako nÃ¡zov pÃ´vodnÃ©ho objektu.
*   **Aritmetika:** Ukazovatele podporujÃº aritmetiku. Odkazy nie.
*   **Existencia:** UkazovateÄ¾ je premennÃ¡, ktorÃ¡ zaberÃ¡ vlastnÃº pamÃ¤Å¥ na uloÅ¾enie adresy. Odkaz je skÃ´r alias a nemusÃ­ nutne zaberaÅ¥ ÄalÅ¡iu pamÃ¤Å¥ (aj keÄ kompilÃ¡tor to mÃ´Å¾e implementovaÅ¥ interne pomocou adresy).`
            },
            {
                question: "OpÃ­saÅ¥ pamÃ¤Å¥ovÃ½ blok explicitnej jednostranne zreÅ¥azenej sekvencie:",
                answer: `PamÃ¤Å¥ovÃ½ blok (Äasto nazÃ½vanÃ½ uzol alebo prvok) v explicitnej jednostranne zreÅ¥azenej sekvencii (singly linked list) je zÃ¡kladnou stavebnou jednotkou tejto dÃ¡tovej Å¡truktÃºry. KaÅ¾dÃ½ takÃ½to blok sa skladÃ¡ z dvoch hlavnÃ½ch ÄastÃ­:

1.  **ÃšdajovÃ¡ ÄasÅ¥ (Data Part):**
    *   Obsahuje samotnÃ© **uÅ¾itoÄnÃ© dÃ¡ta**, ktorÃ© chceme v sekvencii uchovÃ¡vaÅ¥.
    *   Typ tÃ½chto dÃ¡t mÃ´Å¾e byÅ¥ Ä¾ubovoÄ¾nÃ½: primitÃ­vny typ (celÃ© ÄÃ­slo, znak, atÄ.), Å¡truktÃºra, objekt alebo dokonca ukazovateÄ¾ na inÃ© komplexnejÅ¡ie dÃ¡ta.
    *   NaprÃ­klad, ak sekvencia uchovÃ¡va celÃ© ÄÃ­sla, ÃºdajovÃ¡ ÄasÅ¥ bude obsahovaÅ¥ jedno celÃ© ÄÃ­slo.

2.  **VzÅ¥ahovÃ¡ ÄasÅ¥ (Link/Pointer Part):**
    *   Obsahuje **referenciu (ukazovateÄ¾) na nasledujÃºci blok (uzol) v sekvencii.**
    *   TÃ¡to referencia "spÃ¡ja" alebo "reÅ¥azÃ­" aktuÃ¡lny blok s nasledujÃºcim, ÄÃ­m vytvÃ¡ra lineÃ¡rnu postupnosÅ¥ blokov.
    *   NazÃ½va sa tieÅ¾ "smernÃ­k na nasledovnÃ­ka" alebo "next pointer".

**Charakteristiky pamÃ¤Å¥ovÃ©ho bloku a sekvencie:**

*   **Å truktÃºra bloku:**
    Typicky sa implementuje ako Å¡truktÃºra (struct v C/C++) alebo trieda (class), naprÃ­klad:
    \`\`\`cpp
    // PrÃ­klad v C++
    struct Node {
        DataType data; // ÃšdajovÃ¡ ÄasÅ¥
        Node* next;    // VzÅ¥ahovÃ¡ ÄasÅ¥ - ukazovateÄ¾ na nasledujÃºci uzol
    };
    \`\`\`
    (DataType by bol konkrÃ©tny typ ukladanÃ½ch dÃ¡t)

*   **Referencia na nasledovnÃ­ka:**
    *   KaÅ¾dÃ½ blok (okrem poslednÃ©ho) obsahuje platnÃº referenciu (nenulovÃ½ ukazovateÄ¾) na nasledujÃºci blok v sekvencii.
    *   Toto umoÅ¾Åˆuje jednosmernÃ½ prechod sekvenciou â€“ od aktuÃ¡lneho bloku k jeho nasledovnÃ­kovi.

*   **PoslednÃ½ blok (Tail):**
    *   PoslednÃ½ blok v sekvencii mÃ¡ svoju referenciu na nasledovnÃ­ka nastavenÃº na Å¡peciÃ¡lnu hodnotu, ktorÃ¡ indikuje koniec sekvencie.
    *   Typicky je to **NULL** (v C/C++) alebo \`nullptr\` (v modernom C++).
    *   Toto umoÅ¾Åˆuje algoritmom rozpoznaÅ¥, kedy dosiahli koniec sekvencie.

*   **ZaÄiatok sekvencie (Head):**
    *   CelÃ¡ sekvencia je zvyÄajne prÃ­stupnÃ¡ cez samostatnÃº referenciu (ukazovateÄ¾), ktorÃ¡ ukazuje na **prvÃ½ blok (uzol) sekvencie**. Tento ukazovateÄ¾ sa Äasto nazÃ½va "hlava" (head).
    *   Ak je sekvencia prÃ¡zdna, ukazovateÄ¾ "head" je nastavenÃ½ na NULL.

**VizuÃ¡lna predstava bloku:**
\`\`\`
  +------+------+
  | Data | Next | ----> (ukazuje na ÄalÅ¡Ã­ blok alebo NULL)
  +------+------+
\`\`\`

**AlokÃ¡cia:**
Bloky explicitnej jednostranne zreÅ¥azenej sekvencie sÃº typicky alokovanÃ© dynamicky v pamÃ¤ti (na halde), podÄ¾a potreby pri vkladanÃ­ novÃ½ch prvkov. Pri odstraÅˆovanÃ­ prvkov sa ich pamÃ¤Å¥ dealokuje.`
            },
            {
                question: "NapÃ­saÅ¥ 3 tabuÄ¾ky s konÅ¡tantnou zloÅ¾itosÅ¥ou a v jednej opÃ­saÅ¥ operÃ¡ciu vloÅ¾:",
                answer: `Tri typy tabuliek (haÅ¡ovacÃ­ch tabuliek), ktorÃ© sa snaÅ¾ia dosiahnuÅ¥ konÅ¡tantnÃº priemernÃº ÄasovÃº zloÅ¾itosÅ¥ O(1) pre operÃ¡cie ako vloÅ¾, nÃ¡jdi, zruÅ¡:

1.  **TabuÄ¾ka s rozptÃ½lenÃ½mi zÃ¡znamami (Hashing Table) - rieÅ¡enie kolÃ­ziÃ­ zreÅ¥azovanÃ­m (Chaining):**
    *   PriemernÃ¡ zloÅ¾itosÅ¥ operÃ¡ciÃ­: O(1 + Î±), kde Î± je faktor zaplnenia (load factor = n/m; n=poÄet prvkov, m=veÄ¾kosÅ¥ tabuÄ¾ky). Ak Î± je malÃ© konÅ¡tantnÃ© ÄÃ­slo, potom je to O(1).
    *   NajhorÅ¡Ã­ prÃ­pad: O(n), ak vÅ¡etky kÄ¾ÃºÄe heÅ¡ujÃº na rovnakÃ½ index a tvoria dlhÃ½ zreÅ¥azenÃ½ zoznam.

2.  **TabuÄ¾ka s rozptÃ½lenÃ½mi zÃ¡znamami - rieÅ¡enie kolÃ­ziÃ­ otvorenou adresÃ¡ciou (Open Addressing):**
    *   Typy: lineÃ¡rne sondovanie, kvadratickÃ© sondovanie, dvojitÃ© heÅ¡ovanie.
    *   PriemernÃ¡ zloÅ¾itosÅ¥: ZÃ¡visÃ­ od faktora zaplnenia a typu sondovania, ale pri nÃ­zkom faktore zaplnenia sa blÃ­Å¾i O(1).
    *   NajhorÅ¡Ã­ prÃ­pad: O(n), ak dochÃ¡dza k rozsiahlemu zhlukovaniu (clustering).

3.  **TabuÄ¾ka s rozptÃ½lenÃ½mi zÃ¡znamami - bez explicitnÃ©ho rieÅ¡enia kolÃ­ziÃ­ (teoretickÃ½ model alebo s predpokladom perfektnej heÅ¡ovacej funkcie):**
    *   Ak by sme mali perfektnÃº heÅ¡ovaciu funkciu (kaÅ¾dÃ½ kÄ¾ÃºÄ mapuje na unikÃ¡tny index) a dostatoÄne veÄ¾kÃº tabuÄ¾ku, operÃ¡cie by boli O(1) aj v najhorÅ¡om prÃ­pade. V praxi je to Å¥aÅ¾ko dosiahnuteÄ¾nÃ© pre dynamickÃ© dÃ¡ta.
    *   VÃ¡Å¡ text spomÃ­na "TabuÄ¾ka s rozptÃ½lenÃ½mi zÃ¡znamami (bez rieÅ¡enia kolÃ­ziÃ­): O(1)". Toto platÃ­ za predpokladu, Å¾e kolÃ­zie nenastanÃº, alebo Å¾e prepisovanie existujÃºceho prvku s rovnakÃ½m heÅ¡om je akceptovateÄ¾nÃ© (Äo nie je typickÃ© pre vÅ¡eobecnÃº tabuÄ¾ku). Alebo ak je to len zÃ¡kladnÃ½ model, kde sa na pozÃ­ciu jednoducho zapÃ­Å¡e.

**Opis operÃ¡cie VLOÅ½ pre TabuÄ¾ku s rozptÃ½lenÃ½mi zÃ¡znamami (rieÅ¡enie kolÃ­ziÃ­ zreÅ¥azovanÃ­m):**

Predpoklad: MÃ¡me pole (implicitnÃº sekvenciu) M o veÄ¾kosti \`m\`. KaÅ¾dÃ½ prvok poÄ¾a M je ukazovateÄ¾ na zaÄiatok zreÅ¥azenÃ©ho zoznamu (alebo je NULL, ak je slot prÃ¡zdny).

**OperÃ¡cia VLOÅ½ (kÄ¾ÃºÄ K, Ãºdaje D):**

1.  **VÃ½poÄet heÅ¡ovacej hodnoty:**
    *   Aplikuje sa heÅ¡ovacia funkcia H na kÄ¾ÃºÄ K: \`h_val = H(K)\`.

2.  **VÃ½poÄet indexu do tabuÄ¾ky:**
    *   Index do poÄ¾a M sa vypoÄÃ­ta z heÅ¡ovacej hodnoty, typicky pomocou modulo operÃ¡cie: \`index = h_val mod m\`. Toto zabezpeÄÃ­, Å¾e index bude v platnom rozsahu [0, m-1].

3.  **PrÃ­stup k zreÅ¥azenÃ©mu zoznamu:**
    *   ZÃ­ska sa ukazovateÄ¾ na zaÄiatok zreÅ¥azenÃ©ho zoznamu na vypoÄÃ­tanom \`indexe\` v poli M: \`list_head = M[index]\`.

4.  **(VoliteÄ¾nÃ©) Kontrola existencie kÄ¾ÃºÄa:**
    *   Prejde sa zreÅ¥azenÃ½ zoznam zaÄÃ­najÃºci na \`list_head\`. Pre kaÅ¾dÃ½ prvok v zozname sa porovnÃ¡ jeho kÄ¾ÃºÄ s vkladanÃ½m kÄ¾ÃºÄom K.
    *   Ak sa nÃ¡jde prvok s rovnakÃ½m kÄ¾ÃºÄom K:
        *   BuÄ sa aktualizujÃº jeho Ãºdaje D (ak je to povolenÃ© a Å¾iaduce).
        *   Alebo sa operÃ¡cia vloÅ¾enia mÃ´Å¾e zamietnuÅ¥ (ak kÄ¾ÃºÄe musia byÅ¥ unikÃ¡tne a aktualizÃ¡cia nie je povolenÃ¡).
        *   OperÃ¡cia vloÅ¾enia konÄÃ­.

5.  **Vytvorenie novÃ©ho prvku:**
    *   Ak kÄ¾ÃºÄ K nebol nÃ¡jdenÃ½ v zreÅ¥azenom zozname (alebo ak je povolenÃ© vkladaÅ¥ duplicitnÃ© kÄ¾ÃºÄe, Äo nie je typickÃ© pre heÅ¡ovacie tabuÄ¾ky), vytvorÃ­ sa novÃ½ uzol/prvok obsahujÃºci kÄ¾ÃºÄ K a Ãºdaje D.

6.  **VloÅ¾enie novÃ©ho prvku do zreÅ¥azenÃ©ho zoznamu:**
    *   NovÃ½ prvok sa vloÅ¾Ã­ do zreÅ¥azenÃ©ho zoznamu na \`indexe\`. NajÄastejÅ¡ie sa vkladÃ¡ na zaÄiatok zoznamu pre jednoduchosÅ¥ a efektivitu O(1) pre samotnÃ© vloÅ¾enie do zoznamu:
        *   \`novy_prvok->next = M[index]\`
        *   \`M[index] = novy_prvok\`

7.  **(VoliteÄ¾nÃ©) AktualizÃ¡cia poÄtu prvkov a faktora zaplnenia:**
    *   ZvÃ½Å¡i sa celkovÃ½ poÄet prvkov v tabuÄ¾ke.
    *   Ak faktor zaplnenia Î± prekroÄÃ­ urÄitÃº hranicu, mÃ´Å¾e sa vykonaÅ¥ operÃ¡cia zvÃ¤ÄÅ¡enia tabuÄ¾ky (rehash), aby sa zachovala dobrÃ¡ priemernÃ¡ zloÅ¾itosÅ¥. Toto je drahÅ¡ia operÃ¡cia, ale amortizovane stÃ¡le umoÅ¾Åˆuje O(1) pre vloÅ¾enie.

**ZloÅ¾itosÅ¥ operÃ¡cie VLOÅ½ (zreÅ¥azovanie):**
*   VÃ½poÄet heÅ¡u a indexu: O(dÄºÅ¾ka kÄ¾ÃºÄa) zvyÄajne, ale Äasto povaÅ¾ovanÃ© za O(1) ak dÄºÅ¾ka kÄ¾ÃºÄa je obmedzenÃ¡.
*   VloÅ¾enie na zaÄiatok zoznamu: O(1).
*   PrechÃ¡dzanie zoznamu (kontrola duplikÃ¡tov): V priemere O(Î±). Ak sa kontrola duplikÃ¡tov nerobÃ­ (alebo sa vkladÃ¡ vÅ¾dy na zaÄiatok), tÃ¡to ÄasÅ¥ je O(1).
*   Celkovo: Priemerne O(1+Î±). Ak sa nerobÃ­ kontrola duplikÃ¡tov, tak O(1) pre samotnÃ© vloÅ¾enie + cena rehashingu amortizovane. `
            },
            {
                question: "Rozdiel medzi usporiadanÃ½mi a neusporiadanÃ½mi K-cestnÃ½mi hierarchiami:",
                answer: `Rozdiel medzi usporiadanÃ½mi a neusporiadanÃ½mi K-cestnÃ½mi hierarchiami (stromami) spoÄÃ­va v tom, Äi existuje definovanÃ© poradie medzi synmi danÃ©ho vrcholu.

**UsporiadanÃ© K-cestnÃ© hierarchie (Ordered K-way Trees):**

1.  **Poradie synov:** Synovia kaÅ¾dÃ©ho vrcholu tvoria **lineÃ¡rne usporiadanÃº mnoÅ¾inu**. To znamenÃ¡, Å¾e existuje jasne definovanÃ½ "prvÃ½ syn", "druhÃ½ syn", ..., aÅ¾ "k-ty syn" (ak existujÃº).
2.  **Pomenovanie synov:** VÄaka usporiadaniu je moÅ¾nÃ© synov pomenovaÅ¥ alebo na nich odkazovaÅ¥ na zÃ¡klade ich pozÃ­cie (napr. najÄ¾avejÅ¡Ã­ syn, pravÃ½ brat, atÄ.). Pre binÃ¡rne stromy (K=2) sÃº to typicky "Ä¾avÃ½ syn" a "pravÃ½ syn".
3.  **OperÃ¡cie:** OperÃ¡cie pracujÃºce so synmi vrcholu typicky presne Å¡pecifikujÃº, ktorÃ©ho syna sa operÃ¡cia tÃ½ka na zÃ¡klade jeho poradia alebo roly (napr. "vloÅ¾ ako Ä¾avÃ©ho syna").
4.  **ImplementÃ¡cia:**
    *   MÃ´Å¾u byÅ¥ implementovanÃ© ako **implicitnÃ© hierarchie** v kompaktnej pamÃ¤ti (napr. binÃ¡rna halda), ak sÃº navyÅ¡e kompletnÃ©. VzÅ¥ahy sa vypoÄÃ­tavajÃº z indexov.
    *   MÃ´Å¾u byÅ¥ implementovanÃ© ako **explicitnÃ© hierarchie**, kde kaÅ¾dÃ½ vrchol mÃ¡ K (alebo menej) explicitnÃ½ch referenciÃ­ na svojich synov, priÄom kaÅ¾dÃ¡ referencia zodpovedÃ¡ urÄitej pozÃ­cii (napr. pole ukazovateÄ¾ov na synov veÄ¾kosti K).
5.  **PrÃ­klady:** BinÃ¡rne vyhÄ¾adÃ¡vacie stromy (kde Ä¾avÃ½ syn je menÅ¡Ã­ a pravÃ½ vÃ¤ÄÅ¡Ã­), vÅ¡eobecnÃ© usporiadanÃ© stromy pouÅ¾Ã­vanÃ© na reprezentÃ¡ciu XML dokumentov (kde poradie elementov mÃ¡ vÃ½znam).

**NeusporiadanÃ© K-cestnÃ© hierarchie (Unordered K-way Trees):**

1.  **Poradie synov:** Synovia kaÅ¾dÃ©ho vrcholu tvoria **mnoÅ¾inu bez definovanÃ©ho poradia**. ZÃ¡leÅ¾Ã­ len na tom, ktorÃ­ synovia existujÃº, nie na ich vzÃ¡jomnom poradÃ­.
2.  **Pomenovanie synov:** Nie je moÅ¾nÃ© jednoznaÄne urÄiÅ¥ "prvÃ©ho" alebo "druhÃ©ho" syna len na zÃ¡klade Å¡truktÃºry. AkÃ½koÄ¾vek prechod synmi vrÃ¡ti mnoÅ¾inu synov v Ä¾ubovoÄ¾nom poradÃ­.
3.  **OperÃ¡cie:** OperÃ¡cie pracujÃºce so synmi sa typicky tÃ½kajÃº vÅ¡etkÃ½ch synov ako skupiny, alebo vyhÄ¾adÃ¡vajÃº konkrÃ©tneho syna na zÃ¡klade jeho hodnoty, nie pozÃ­cie.
4.  **ImplementÃ¡cia:**
    *   Typicky sa implementujÃº ako **explicitnÃ© hierarchie**.
    *   KaÅ¾dÃ½ vrchol mÃ´Å¾e obsahovaÅ¥ referenciu na **dÃ¡tovÃº Å¡truktÃºru (napr. zreÅ¥azenÃ½ zoznam, heÅ¡ovaciu tabuÄ¾ku, alebo dynamickÃ© pole) uchovÃ¡vajÃºcu referencie na jeho synov.** Poradie v tejto pomocnej Å¡truktÃºre nemusÃ­ maÅ¥ sÃ©mantickÃ½ vÃ½znam pre hierarchiu ako takÃº.
    *   ImplicitnÃ¡ implementÃ¡cia nie je priamoÄiarÃ¡, pretoÅ¾e chÃ½ba pevnÃ© mapovanie pozÃ­cie na konkrÃ©tneho syna.
5.  **PrÃ­klady:** ReprezentÃ¡cia mnoÅ¾inovÃ½ch vzÅ¥ahov, niektorÃ© typy stromov v teÃ³rii grafov, kde zÃ¡leÅ¾Ã­ len na vzÅ¥ahu rodiÄ-syn, nie na poradÃ­ synov (napr. strom komponentov grafu).

**HlavnÃ© rozdiely zhrnutÃ©:**

| VlastnosÅ¥         | UsporiadanÃ¡ K-cestnÃ¡ hierarchia             | NeusporiadanÃ¡ K-cestnÃ¡ hierarchia          |
|-------------------|---------------------------------------------|-------------------------------------------|
| **Poradie synov** | Ãno, synovia sÃº lineÃ¡rne usporiadanÃ­.       | Nie, synovia tvoria neusporiadanÃº mnoÅ¾inu. |
| **PrÃ­stup k synom**| PodÄ¾a pozÃ­cie/indexu (napr. 1., 2. syn).   | PodÄ¾a hodnoty alebo ako celÃ¡ mnoÅ¾ina.       |
| **ImplementÃ¡cia (typickÃ¡)** | ImplicitnÃ¡ (ak kompletnÃ¡) alebo explicitnÃ¡ s K referenciami. | ExplicitnÃ¡ s kolekciou referenciÃ­ na synov. |
| **SÃ©mantika**     | Poradie synov mÃ¡ vÃ½znam.                    | Poradie synov nemÃ¡ vÃ½znam.                 |

Pre K=2 (binÃ¡rne stromy) je vÃ¤ÄÅ¡ina beÅ¾ne pouÅ¾Ã­vanÃ½ch binÃ¡rnych stromov (BVS, haldy) usporiadanÃ¡, pretoÅ¾e rozliÅ¡ujeme medzi Ä¾avÃ½m a pravÃ½m synom.`
            },
            // {
            // Q: Ä½avostranna halda, opÃ­saÅ¥, napÃ­saÅ¥ APS, operÃ¡cie vÅ¡etky 3 popÃ­saÅ¥ a zloÅ¾itosti k nim aj vysvetliÅ¥ ich:
            // A: (TÃ¡to otÃ¡zka je duplicitnÃ¡ s jednou vyÅ¡Å¡ie, pouÅ¾ije sa tamtÃ¡ odpoveÄ)
            // },
            {
                question: "ZoraÄte 4 PF od najlepÅ¡ej po najhorÅ¡iu (operÃ¡cia VYBER prvok s najvyÅ¡Å¡ou prioritou):",
                answer: `Zoradenie 4 implementÃ¡ciÃ­ prioritnÃ©ho frontu (PF) podÄ¾a Äasovej zloÅ¾itosti operÃ¡cie **VYBER prvok s najvyÅ¡Å¡ou prioritou** (od najlepÅ¡ej po najhorÅ¡iu):

1.  **UtriedenÃ½ sekvenÄnÃ½ prioritnÃ½ front (Sorted Sequential Priority Queue):**
    *   ImplementÃ¡cia: Pole alebo zreÅ¥azenÃ½ zoznam, kde prvky sÃº neustÃ¡le udrÅ¾iavanÃ© utriedenÃ© podÄ¾a priority.
    *   ZloÅ¾itosÅ¥ operÃ¡cie VYBER: **O(1)**
    *   Vysvetlenie: Prvok s najvyÅ¡Å¡ou prioritou je vÅ¾dy na znÃ¡mom konci sekvencie (napr. na zaÄiatku alebo na konci, v zÃ¡vislosti od spÃ´sobu triedenia). Jeho odstrÃ¡nenie je teda veÄ¾mi rÃ½chle.
    *   (NevÃ½hoda: VloÅ¾enie je O(n)).

2.  **Ä½avostrannÃ¡ halda (Binary Heap):**
    *   ImplementÃ¡cia: Typicky implicitnÃ¡ binÃ¡rna hierarchia (pole).
    *   ZloÅ¾itosÅ¥ operÃ¡cie VYBER: **O(log n)**
    *   Vysvetlenie: Prvok s najvyÅ¡Å¡ou prioritou je v koreni. Po jeho odstrÃ¡nenÃ­ sa na jeho miesto presunie poslednÃ½ prvok a vykonÃ¡ sa operÃ¡cia "sift-down" (heapify-down) na obnovenie vlastnosti haldy, Äo trvÃ¡ O(log n).

3.  **Dvojzoznam (AUMS Dvojzoznam):**
    *   ImplementÃ¡cia: KombinÃ¡cia krÃ¡tkej (implicitnej) a dlhej (explicitnej) sekvencie.
    *   ZloÅ¾itosÅ¥ operÃ¡cie VYBER: **O(k + log m) alebo O(k) ak je krÃ¡tka sekvencia triedenÃ¡, O(m) ak je dlhÃ¡ sekvencia prehÄ¾adÃ¡vanÃ¡, kde k je veÄ¾kosÅ¥ krÃ¡tkej a m dlhej. Ak je to prepracovanejÅ¡ie, tak O(k) na nÃ¡jdenie v krÃ¡tkej, O(1) na vybratie z dlhej ak je tam, alebo O(m) na nÃ¡jdenie v dlhej.**
    *   VÃ¡Å¡ text neÅ¡pecifikuje presnÃº zloÅ¾itosÅ¥ vyber pre Dvojzoznam. Typicky sa prvok s najvyÅ¡Å¡ou prioritou hÄ¾adÃ¡ v krÃ¡tkej sekvencii (O(k), kde k je jej dÄºÅ¾ka) a ak je krÃ¡tka sekvencia prÃ¡zdna, tak na zaÄiatku dlhej sekvencie (ak je dlhÃ¡ sekvencia utriedenÃ¡, inak O(m)). Ak je krÃ¡tka sekvencia malÃ¡ (napr. konÅ¡tantnÃ¡ veÄ¾kosÅ¥), tak je to efektÃ­vne. Ak mÃ¡ krÃ¡tka sekvencia napr. logaritmickÃº veÄ¾kosÅ¥ a je triedenÃ¡, tak to mÃ´Å¾e byÅ¥ O(log n). Bez presnejÅ¡ej Å¡pecifikÃ¡cie je Å¥aÅ¾kÃ© zaradiÅ¥. Pre jednoduchosÅ¥ predpokladajme, Å¾e sa musÃ­ prejsÅ¥ krÃ¡tka sekvencia: **O(k)**, kde k je veÄ¾kosÅ¥ krÃ¡tkej sekvencie. Ak k je malÃ©, je to dobrÃ©. Ak k mÃ´Å¾e rÃ¡sÅ¥, je to horÅ¡ie.
    *   Ak by sme brali do Ãºvahy, Å¾e dvojzoznam mÃ¡ za cieÄ¾ amortizovane O(1) vloÅ¾enie, vyber mÃ´Å¾e byÅ¥ menej optimÃ¡lny. Ak prioritu mÃ¡ prvok v krÃ¡tkej Äasti (O(k)), ak v dlhej (O(1) ak je na zaÄiatku, inak O(m)). ÄŒasto sa krÃ¡tka udrÅ¾iava utriedenÃ¡, potom je to O(1) z krÃ¡tkej alebo dlhej.
    *   Pre tento zoznam, ak predpokladÃ¡me, Å¾e dvojzoznam je optimalizovanÃ½ skÃ´r na vkladanie, a vyber vyÅ¾aduje prehÄ¾adanie krÃ¡tkej Äasti: O(k), kde k je veÄ¾kosÅ¥ krÃ¡tkej Äasti. Ak k ~ log n, potom O(log n). Ak k mÃ´Å¾e byÅ¥ aÅ¾ O(n), potom O(n). Ak je k fixnÃ© a malÃ©, tak O(1). ZaradÃ­m ho ako porovnateÄ¾nÃ½ s haldou alebo horÅ¡Ã­, zÃ¡leÅ¾Ã­ od k.
    *   *PÃ´vodnÃ½ text z otÃ¡zky "4 implementÃ¡cie prioritnÃ©ho frontu a zoraÄ ich na zÃ¡klade operÃ¡cie vloÅ¾" mal dvojzoznam ako O(1) amortizovane pre vloÅ¾. Pre vyber to nie je explicitne uvedenÃ©.*
    *   Ak berieme beÅ¾nÃº implementÃ¡ciu dvojzoznamu ako prioritnÃ©ho frontu, vyber by mal byÅ¥ rÃ½chly, ak je prvok v krÃ¡tkej Äasti a tÃ¡ je malÃ¡. Ak sa musia zluÄovaÅ¥, je to drahÅ¡ie. ZaradÃ­m ho s otÃ¡znikom za haldu.

4.  **NeutriedenÃ½ sekvenÄnÃ½ prioritnÃ½ front (Unsorted Sequential Priority Queue):**
    *   ImplementÃ¡cia: Pole alebo zreÅ¥azenÃ½ zoznam, kde prvky sÃº vkladanÃ© bez ohÄ¾adu na prioritu (napr. na koniec).
    *   ZloÅ¾itosÅ¥ operÃ¡cie VYBER: **O(n)**
    *   Vysvetlenie: Na nÃ¡jdenie prvku s najvyÅ¡Å¡ou prioritou je potrebnÃ© prejsÅ¥ celÃº sekvenciu a porovnaÅ¥ vÅ¡etky prvky.
    *   (VÃ½hoda: VloÅ¾enie je O(1)).

**Zoradenie (s ohÄ¾adom na nejasnosÅ¥ Dvojzoznamu pre VYBER):**
1.  **UtriedenÃ½ sekvenÄnÃ½ PF:** O(1)
2.  **Ä½avostrannÃ¡ halda:** O(log n)
3.  **Dvojzoznam:** ? (PotenciÃ¡lne od O(1) po O(n) v zÃ¡vislosti od implementÃ¡cie a stavu. Ak je krÃ¡tka ÄasÅ¥ malÃ¡ a prehÄ¾adÃ¡va sa, tak efektÃ­vne. Ak je krÃ¡tka ÄasÅ¥ veÄ¾kÃ¡ alebo sa musÃ­ prehÄ¾adÃ¡vaÅ¥ dlhÃ¡ ÄasÅ¥, tak menej efektÃ­vne). Pre ÃºÄely tohto poradia ho dajme ako horÅ¡Ã­ neÅ¾ halda, ale lepÅ¡Ã­ neÅ¾ Ãºplne neutriedenÃ½. MoÅ¾no O(k) alebo O(log n) v typickÃ½ch prÃ­padoch.
4.  **NeutriedenÃ½ sekvenÄnÃ½ PF:** O(n)

UpravenÃ© poradie s konzervatÃ­vnym odhadom pre dvojzoznam:
1.  **UtriedenÃ½ sekvenÄnÃ½ PF:** O(1)
2.  **Ä½avostrannÃ¡ halda:** O(log n)
3.  **Dvojzoznam:** (napr. O(k), kde k je veÄ¾kosÅ¥ krÃ¡tkej sekvencie; ak k ~ log n, tak porovnateÄ¾nÃ© s haldou. Ak k je malÃ© konÅ¡tantnÃ©, tak blÃ­zko O(1))
4.  **NeutriedenÃ½ sekvenÄnÃ½ PF:** O(n)

Ak by sme mali byÅ¥ striktnÃ­ a dvojzoznam by vyÅ¾adoval prehÄ¾adanie podstatnej Äasti, mohol by byÅ¥ aj za neutriedenÃ½m, ale to by popieralo jeho ÃºÄel ako efektÃ­vneho PF. PravdepodobnejÅ¡ie je, Å¾e je navrhnutÃ½ tak, aby vyber bol tieÅ¾ relatÃ­vne rÃ½chly. `
            },
            {
                question: "NapÃ­Å¡ Äo je to sAPT(blok siete) a brÃ¡na:",
                answer: `**sAPT (blok siete) - Blok pamÃ¤te v sieÅ¥ovom Abstraktnom PamÃ¤Å¥ovom Type:**

V kontexte sieÅ¥ovÃ½ch AbstraktnÃ½ch PamÃ¤Å¥ovÃ½ch Typov (APT pre siete, niekedy oznaÄovanÃ© ako sAPT, kde 's' mÃ´Å¾e znamenaÅ¥ sieÅ¥/struktÃºra):
*   **Bloky pamÃ¤te sa oznaÄujÃº ako vrcholy (nodes/vertices) siete.**
*   SieÅ¥ovÃ½ APT definuje, ako sÃº tieto vrcholy organizovanÃ© a akÃ© operÃ¡cie sÃº nad nimi definovanÃ©.
*   CharakteristickÃ½m rysom siete je, Å¾e **kaÅ¾dÃ½ vrchol mÃ´Å¾e maÅ¥ potenciÃ¡lne vzÅ¥ah (byÅ¥ spojenÃ½ hranou) s kaÅ¾dÃ½m inÃ½m vrcholom siete.** VzÅ¥ahy nie sÃº obmedzenÃ© na lineÃ¡rne (ako v sekvencii) alebo hierarchickÃ© (ako v strome).
*   **VzÅ¥ahy medzi vrcholmi v sieÅ¥ovÃ½ch APT sÃº nelineÃ¡rne a nehierarchickÃ©.**
*   **Å½iadny vrchol v sieÅ¥ovom APT nemÃ¡ prirodzene vÃ½nimoÄnÃ© postavenie** (na rozdiel od prvÃ©ho/poslednÃ©ho prvku v sekvencii, alebo koreÅˆa v hierarchii). AkÃ½koÄ¾vek vrchol mÃ´Å¾e byÅ¥ vÃ½chodiskovÃ½m bodom pre operÃ¡cie.

**BrÃ¡na (Gateway / Portal) v sieÅ¥ovom APT:**

KeÄÅ¾e v sieti neexistuje jeden prirodzenÃ½ vstupnÃ½ bod (ako koreÅˆ v strome), je potrebnÃ½ mechanizmus na prÃ­stup k vrcholom siete. Tento mechanizmus sa nazÃ½va **brÃ¡na**.

*   **ÃšÄel brÃ¡ny:** BrÃ¡na je sÃºÄasÅ¥ sieÅ¥ovÃ©ho APT (alebo pridruÅ¾enÃ¡ Å¡truktÃºra), ktorÃ¡ **udrÅ¾iava referencie na vÅ¡etky (alebo podmnoÅ¾inu) blokov pamÃ¤te (vrcholov) v sieti.**
*   **Å truktÃºra brÃ¡ny:** Tieto referencie sÃº typicky uloÅ¾enÃ© v nejakej forme **sekvencie** (napr. pole, zreÅ¥azenÃ½ zoznam, heÅ¡ovacia tabuÄ¾ka mapujÃºca identifikÃ¡tory vrcholov na referencie).
*   **Funkcia brÃ¡ny:**
    *   UmoÅ¾Åˆuje iterovaÅ¥ cez vÅ¡etky vrcholy v sieti.
    *   UmoÅ¾Åˆuje nÃ¡jsÅ¥ konkrÃ©tny vrchol (napr. podÄ¾a jeho ID alebo inÃ©ho atribÃºtu), ak brÃ¡na podporuje indexovanÃ½ prÃ­stup alebo vyhÄ¾adÃ¡vanie.
    *   SlÃºÅ¾i ako vstupnÃ½ bod pre algoritmy pracujÃºce so sieÅ¥ou (napr. prehÄ¾adÃ¡vanie do Å¡Ã­rky/hÄºbky mÃ´Å¾e zaÄaÅ¥ z vrcholu zÃ­skanÃ©ho cez brÃ¡nu).

*   **ImplementÃ¡cia brÃ¡ny (podÄ¾a vÃ¡Å¡ho textu):**
    *   **StatickÃ¡ sieÅ¥:** Ako brÃ¡na mÃ´Å¾e byÅ¥ pouÅ¾itÃ¡ **implicitnÃ¡ sekvencia** (napr. pole referenciÃ­ na vrcholy). Toto je moÅ¾nÃ©, pretoÅ¾e poÄet vrcholov v statickej sieti je fixnÃ½.
    *   **DynamickÃ¡ sieÅ¥:** Ako brÃ¡na je typicky pouÅ¾itÃ¡ **explicitnÃ¡ sekvencia** (napr. zreÅ¥azenÃ½ zoznam referenciÃ­ alebo dynamickÃ© pole), pretoÅ¾e poÄet vrcholov sa mÃ´Å¾e meniÅ¥ a explicitnÃ¡ sekvencia sa vie flexibilne prispÃ´sobiÅ¥ tÃ½mto zmenÃ¡m.

V podstate, sAPT blok je len inÃ½ nÃ¡zov pre vrchol v kontexte abstraktnej organizÃ¡cie pamÃ¤te pre siete, a brÃ¡na je pomocnÃ¡ Å¡truktÃºra, ktorÃ¡ poskytuje prÃ­stup k tÃ½mto vrcholom.`
            },
            {
                question: "NapÃ­Å¡ presnÃ© ÃºdajovÃ© typy, ktorÃ© vyuÅ¾Ã­vajÃº sekvenciu:",
                answer: `NasledujÃºce AbstraktnÃ© ÃšdajovÃ© Typy (AUT) alebo AbstraktnÃ© ÃšdajovÃ© Å truktÃºry (AUÅ ) vyuÅ¾Ã­vajÃº koncept sekvencie ako zÃ¡kladnÃº alebo pomocnÃº Å¡truktÃºru:

**1. ZÃ¡kladnÃ© typy sekvenciÃ­ (Äasto ako AUÅ  pre AUT Sekvencia):**
*   **ImplicitnÃ¡ sekvencia (Implicit Sequence):**
    *   RealizovanÃ¡ typicky pomocou poÄ¾a (array). Prvky sÃº uloÅ¾enÃ© v sÃºvislom bloku pamÃ¤te.
    *   PrÃ­klad: StatickÃ© pole, dynamickÃ© pole (vector v C++, ArrayList v Jave).
*   **ExplicitnÃ¡ sekvencia (Explicit Sequence):**
    *   RealizovanÃ¡ typicky pomocou zreÅ¥azenÃ½ch zoznamov. KaÅ¾dÃ½ prvok (uzol) obsahuje dÃ¡ta a referenciu (ukazovateÄ¾) na ÄalÅ¡Ã­ prvok (a prÃ­padne predchÃ¡dzajÃºci).
    *   **Jednostranne zreÅ¥azenÃ¡ sekvencia (Singly Linked List)**
    *   **Obojstranne zreÅ¥azenÃ¡ sekvencia (Doubly Linked List)**
*   **CyklickÃ© varianty:**
    *   **ImplicitnÃ¡ cyklickÃ¡ sekvencia (Circular Array/Buffer):** Pole, kde poslednÃ½ prvok logicky nasleduje prvÃ½.
    *   **Jednostranne zreÅ¥azenÃ¡ cyklickÃ¡ sekvencia (Circular Singly Linked List):** PoslednÃ½ prvok ukazuje na prvÃ½.
    *   **Obojstranne zreÅ¥azenÃ¡ cyklickÃ¡ sekvencia (Circular Doubly Linked List):** PoslednÃ½ ukazuje na prvÃ½ a prvÃ½ na poslednÃ½.

**2. AbstraktnÃ© ÃºdajovÃ© typy implementovanÃ© pomocou sekvenciÃ­:**
*   **ZÃ¡sobnÃ­k (Stack - AUT):**
    *   MÃ´Å¾e byÅ¥ implementovanÃ½ pomocou implicitnej sekvencie (pole) alebo explicitnej sekvencie (zreÅ¥azenÃ½ zoznam).
*   **Rad (Queue - AUT):**
    *   MÃ´Å¾e byÅ¥ implementovanÃ½ pomocou implicitnej cyklickej sekvencie (pole) alebo explicitnej sekvencie (zreÅ¥azenÃ½ zoznam).
*   **PrioritnÃ½ front (Priority Queue - AUT):**
    *   **AUS NeutriedenÃ½ sekvenÄnÃ½ prioritnÃ½ front:** PouÅ¾Ã­va implicitnÃº alebo explicitnÃº sekvenciu na ukladanie prvkov bez Å¡pecifickÃ©ho poradia.
    *   **AUS UtriedenÃ½ sekvenÄnÃ½ prioritnÃ½ front:** PouÅ¾Ã­va implicitnÃº alebo explicitnÃº sekvenciu, kde prvky sÃº udrÅ¾iavanÃ© utriedenÃ© podÄ¾a priority.
*   **Zoznam (List - AUT):** VÅ¡eobecnejÅ¡Ã­ typ ako zÃ¡sobnÃ­k alebo rad, umoÅ¾Åˆuje vkladanie, mazanie a prÃ­stup k prvkom na Ä¾ubovoÄ¾nej pozÃ­cii. ÄŒasto implementovanÃ½ ako dynamickÃ© pole alebo zreÅ¥azenÃ½ zoznam.

**3. KomplexnejÅ¡ie Å¡truktÃºry vyuÅ¾Ã­vajÃºce sekvencie ako komponenty:**
*   **AUMS Dvojzoznam (Two-List Structure):**
    *   VyuÅ¾Ã­va dve sekvencie na implementÃ¡ciu prioritnÃ©ho frontu:
        *   **KrÃ¡tka sekvencia:** ÄŒasto implicitnÃ¡ sekvencia s pevnou (alebo obmedzenou) kapacitou.
        *   **DlhÃ¡ sekvencia:** ÄŒasto jednostranne zreÅ¥azenÃ¡ sekvencia.
*   **HaÅ¡ovacia tabuÄ¾ka (Hash Table) s rieÅ¡enÃ­m kolÃ­ziÃ­ zreÅ¥azovanÃ­m (Chaining):**
    *   HlavnÃ¡ Å¡truktÃºra je pole (implicitnÃ¡ sekvencia).
    *   KaÅ¾dÃ½ prvok tohto poÄ¾a je ukazovateÄ¾ na zaÄiatok explicitnej sekvencie (zreÅ¥azenÃ©ho zoznamu), ktorÃ¡ uchovÃ¡va prvky s rovnakou heÅ¡ovacou hodnotou (synonymÃ¡).
*   **Zoznamy susednosti (Adjacency Lists) pre reprezentÃ¡ciu grafov:**
    *   PouÅ¾Ã­va sa pole (implicitnÃ¡ sekvencia), kde kaÅ¾dÃ½ index zodpovedÃ¡ vrcholu grafu.
    *   Hodnota na kaÅ¾dom indexe je referencia na explicitnÃº sekvenciu (zreÅ¥azenÃ½ zoznam) susedov danÃ©ho vrcholu.
*   **BrÃ¡na (Gateway) v sieÅ¥ovÃ½ch APT:**
    *   Ako bolo spomenutÃ© vo vaÅ¡om texte, brÃ¡na na prÃ­stup k vrcholom siete mÃ´Å¾e byÅ¥ implementovanÃ¡ ako implicitnÃ¡ sekvencia (pre statickÃ© siete) alebo explicitnÃ¡ sekvencia (pre dynamickÃ© siete).

Tento zoznam ukazuje, Å¾e sekvencia je fundamentÃ¡lny koncept, ktorÃ½ slÃºÅ¾i buÄ priamo ako dÃ¡tovÃ¡ Å¡truktÃºra, alebo ako stavebnÃ½ blok pre mnohÃ© inÃ©, komplexnejÅ¡ie dÃ¡tovÃ© typy a Å¡truktÃºry.`
            },
            {
                question: "NeinicializovanÃ½ ÃºdajovÃ½ segment, inicializovanÃ½ ÃºdajovÃ½ segment, kÃ³dovÃ½ segment) + popÃ­saÅ¥ Äo kaÅ¾dÃ½ robÃ­ a ako sa v tej \"Å¡truktÃºre\" nachÃ¡dzajÃº:",
                answer: `KeÄ je program spustenÃ½, operaÄnÃ½ systÃ©m mu pridelÃ­ pamÃ¤Å¥ovÃ½ priestor. Tento priestor je typicky rozdelenÃ½ do niekoÄ¾kÃ½ch segmentov. Tri z kÄ¾ÃºÄovÃ½ch segmentov sÃº kÃ³dovÃ½ segment, inicializovanÃ½ ÃºdajovÃ½ segment a neinicializovanÃ½ ÃºdajovÃ½ segment.

**1. KÃ³dovÃ½ segment (Code Segment / Text Segment):**
*   **ÄŒo robÃ­/obsahuje:**
    *   Obsahuje **vykonateÄ¾nÃ© inÅ¡trukcie** programu, teda samotnÃ½ preloÅ¾enÃ½ strojovÃ½ kÃ³d.
    *   MÃ´Å¾e obsahovaÅ¥ aj niektorÃ© konÅ¡tantnÃ© dÃ¡ta, ktorÃ© sÃº sÃºÄasÅ¥ou inÅ¡trukciÃ­ (napr. reÅ¥azcovÃ© literÃ¡ly, read-only konÅ¡tanty).
*   **Vlastnosti:**
    *   Typicky je **read-only** (len na ÄÃ­tanie), aby sa zabrÃ¡nilo nÃ¡hodnej alebo Ãºmyselnej modifikÃ¡cii kÃ³du programu poÄas jeho behu.
    *   MÃ´Å¾e byÅ¥ **zdieÄ¾anÃ½** medzi viacerÃ½mi procesmi, ak spÃºÅ¡Å¥ajÃº ten istÃ½ program (napr. viacerÃ© inÅ¡tancie textovÃ©ho editora mÃ´Å¾u zdieÄ¾aÅ¥ ten istÃ½ kÃ³dovÃ½ segment v pamÃ¤ti).
*   **Umiestnenie v Å¡truktÃºre pamÃ¤te procesu (typickÃ© pre mnohÃ© OS):**
    *   NachÃ¡dza sa v **spodnej Äasti** (najniÅ¾Å¡ie adresy) pamÃ¤Å¥ovÃ©ho priestoru procesu.

**2. InicializovanÃ½ ÃºdajovÃ½ segment (Initialized Data Segment / .data segment):**
*   **ÄŒo robÃ­/obsahuje:**
    *   Obsahuje **globÃ¡lne a statickÃ© premennÃ©, ktorÃ© majÃº v zdrojovom kÃ³de explicitne priradenÃº poÄiatoÄnÃº hodnotu (sÃº inicializovanÃ©).**
    *   PrÃ­klad v C/C++: \`int global_var = 100;\` alebo \`static int static_var = 50;\`.
*   **Vlastnosti:**
    *   Je **read-write** (na ÄÃ­tanie aj zÃ¡pis), pretoÅ¾e hodnoty tÃ½chto premennÃ½ch sa mÃ´Å¾u poÄas behu programu meniÅ¥.
    *   VeÄ¾kosÅ¥ tohto segmentu je znÃ¡ma v Äase kompilÃ¡cie. Hodnoty pre inicializÃ¡ciu sÃº uloÅ¾enÃ© priamo vo vykonateÄ¾nom sÃºbore a pri spustenÃ­ programu sa naÄÃ­tajÃº do pamÃ¤te.
*   **Umiestnenie v Å¡truktÃºre pamÃ¤te procesu:**
    *   NachÃ¡dza sa **nad kÃ³dovÃ½m segmentom**.

**3. NeinicializovanÃ½ ÃºdajovÃ½ segment (Uninitialized Data Segment / .bss segment - Block Started by Symbol):**
*   **ÄŒo robÃ­/obsahuje:**
    *   Obsahuje **globÃ¡lne a statickÃ© premennÃ©, ktorÃ© v zdrojovom kÃ³de nie sÃº explicitne inicializovanÃ©, alebo sÃº inicializovanÃ© na nulu.**
    *   PrÃ­klad v C/C++: \`int global_uninit_var;\` alebo \`static int static_uninit_var;\`.
*   **Vlastnosti:**
    *   Je **read-write**.
    *   OperaÄnÃ½ systÃ©m (alebo C runtime) zabezpeÄÃ­, Å¾e vÅ¡etky premennÃ© v tomto segmente sÃº pred spustenÃ­m funkcie \`main\` **inicializovanÃ© na nulu** (alebo nulovÃ© bitovÃ© vzory pre inÃ© typy).
    *   VÃ½hoda .bss segmentu je, Å¾e vo vykonateÄ¾nom sÃºbore na disku zaberÃ¡ len informÃ¡ciu o svojej veÄ¾kosti, nie skutoÄnÃ© nulovÃ© hodnoty pre kaÅ¾dÃº premennÃº. To Å¡etrÃ­ miesto na disku. Pri naÄÃ­tanÃ­ programu do pamÃ¤te sa alokuje potrebnÃ½ priestor a vynuluje sa.
*   **Umiestnenie v Å¡truktÃºre pamÃ¤te procesu:**
    *   NachÃ¡dza sa **nad inicializovanÃ½m ÃºdajovÃ½m segmentom**.

**TypickÃ© usporiadanie v pamÃ¤Å¥ovom priestore procesu (od najniÅ¾Å¡Ã­ch adries po vyÅ¡Å¡ie):**

\`\`\`
+-------------------------+  <-- VyÅ¡Å¡ie adresy
| Argumenty prÃ­kaz. riadku|
| PremennÃ© prostredia     |
+-------------------------+
| ZÃ¡sobnÃ­k (Stack)        |  (rastie smerom k niÅ¾Å¡Ã­m adresÃ¡m)
|          |              |
|          V              |
+-------------------------+
|                         |  (NepouÅ¾itÃ¡ pamÃ¤Å¥ / medzera)
+-------------------------+
|          ^              |
|          |              |
| Halda (Heap)            |  (rastie smerom k vyÅ¡Å¡Ã­m adresÃ¡m)
+-------------------------+
| NeinicializovanÃ½ ÃºdajovÃ½|  (.bss segment)
| segment                 |
+-------------------------+
| InicializovanÃ½ ÃºdajovÃ½  |  (.data segment)
| segment                 |
+-------------------------+
| KÃ³dovÃ½ segment          |  (.text segment)
+-------------------------+  <-- NajniÅ¾Å¡ie adresy
\`\`\`

**ÄalÅ¡ie dÃ´leÅ¾itÃ© oblasti (nie sÃº sÃºÄasÅ¥ou otÃ¡zky, ale pre kontext):**
*   **Halda (Heap):** OblasÅ¥ pre dynamickÃº alokÃ¡ciu pamÃ¤te (\`malloc\`, \`new\`). Rastie smerom k vyÅ¡Å¡Ã­m adresÃ¡m.
*   **ZÃ¡sobnÃ­k (Stack):** OblasÅ¥ pre lokÃ¡lne premennÃ© funkciÃ­, argumenty funkciÃ­ a nÃ¡vratovÃ© adresy. Rastie smerom k niÅ¾Å¡Ã­m adresÃ¡m.

Toto usporiadanie je typickÃ©, ale detaily sa mÃ´Å¾u lÃ­Å¡iÅ¥ medzi rÃ´znymi operaÄnÃ½mi systÃ©mami a architektÃºrami. Segmenty .data a .bss spolu tvoria statickÃº pamÃ¤Å¥ programu.`
            },
            {
                question: "NapÃ­Å¡ 3 rieÅ¡enia kolÃ­zii (popis, vÃ½hody, nevÃ½hody):",
                answer: `KolÃ­zie v heÅ¡ovacÃ­ch tabuÄ¾kÃ¡ch nastÃ¡vajÃº, keÄ dva alebo viac rÃ´znych kÄ¾ÃºÄov vygeneruje rovnakÃº heÅ¡ovaciu hodnotu (a teda rovnakÃ½ index do tabuÄ¾ky). Tu sÃº tri beÅ¾nÃ© metÃ³dy rieÅ¡enia kolÃ­ziÃ­:

**1. ZreÅ¥azovanie (Chaining / Separate Chaining):**

*   **Popis:**
    *   KaÅ¾dÃ¡ poloÅ¾ka (slot/bucket) v heÅ¡ovacej tabuÄ¾ke nie je samotnÃ½ prvok, ale ukazovateÄ¾ na zaÄiatok dÃ¡tovej Å¡truktÃºry (typicky **zreÅ¥azenÃ©ho zoznamu**), ktorÃ¡ uchovÃ¡va vÅ¡etky prvky, ktorÃ© heÅ¡ovali na tento konkrÃ©tny index.
    *   KeÄ dÃ´jde ku kolÃ­zii (novÃ½ prvok heÅ¡uje na uÅ¾ obsadenÃ½ index, kde uÅ¾ existuje zoznam), novÃ½ prvok sa jednoducho pridÃ¡ do tohto zreÅ¥azenÃ©ho zoznamu (napr. na jeho zaÄiatok alebo koniec).
*   **VÃ½hody:**
    *   **JednoduchÃ¡ implementÃ¡cia:** RelatÃ­vne Ä¾ahko sa kÃ³duje a spravuje.
    *   **NeobmedzenÃ½ (teoreticky) poÄet prvkov:** TabuÄ¾ka sa nikdy nemÃ´Å¾e "Ãºplne zaplniÅ¥" v zmysle, Å¾e by nebolo kam vloÅ¾iÅ¥ novÃ½ prvok (pokiaÄ¾ je dostatok pamÃ¤te pre zoznamy). Faktor zaplnenia mÃ´Å¾e byÅ¥ aj > 1.
    *   **JednoduchÃ© mazanie prvkov:** OdstrÃ¡nenie prvku zo zreÅ¥azenÃ©ho zoznamu je Å¡tandardnÃ¡ operÃ¡cia.
    *   Menej citlivÃ© na zlÃº heÅ¡ovaciu funkciu alebo vysokÃ½ faktor zaplnenia v porovnanÃ­ s otvorenou adresÃ¡ciou, aj keÄ vÃ½kon klesÃ¡.
*   **NevÃ½hody:**
    *   **VyÅ¡Å¡ia pamÃ¤Å¥ovÃ¡ nÃ¡roÄnosÅ¥:** KaÅ¾dÃ½ prvok v zreÅ¥azenom zozname potrebuje dodatoÄnÃº pamÃ¤Å¥ pre ukazovateÄ¾ na ÄalÅ¡Ã­ prvok.
    *   **PomalÅ¡Ã­ prÃ­stup pri dlhÃ½ch reÅ¥azcoch:** Ak veÄ¾a prvkov heÅ¡uje na rovnakÃ½ index, prÃ­sluÅ¡nÃ½ zreÅ¥azenÃ½ zoznam sa stÃ¡va dlhÃ½m a operÃ¡cie (nÃ¡jdi, vloÅ¾ s kontrolou duplikÃ¡tov, zruÅ¡) mÃ´Å¾u degenerovaÅ¥ na O(n) v najhorÅ¡om prÃ­pade (prechÃ¡dzanie dlhÃ©ho zoznamu).
    *   PrÃ­stup k prvkom mÃ´Å¾e byÅ¥ pomalÅ¡Ã­ kvÃ´li "cache misses", pretoÅ¾e prvky zoznamu nemusia byÅ¥ v pamÃ¤ti uloÅ¾enÃ© blÃ­zko seba.

**2. OtvorenÃ¡ adresÃ¡cia (Open Addressing):**

*   **Popis:**
    *   VÅ¡etky prvky sa ukladajÃº priamo do samotnej heÅ¡ovacej tabuÄ¾ky (poÄ¾a).
    *   KeÄ dÃ´jde ku kolÃ­zii (cieÄ¾ovÃ½ slot \`H(k)\` je uÅ¾ obsadenÃ½), algoritmus systematicky hÄ¾adÃ¡ inÃ½ voÄ¾nÃ½ slot v tabuÄ¾ke podÄ¾a urÄitej **sondovacej sekvencie (probe sequence)**.
    *   BeÅ¾nÃ© typy sondovania:
        *   **LineÃ¡rne sondovanie:** HÄ¾adÃ¡ sa v slotoch \`H(k)+1, H(k)+2, ...\` (modulo veÄ¾kosÅ¥ tabuÄ¾ky).
        *   **KvadratickÃ© sondovanie:** HÄ¾adÃ¡ sa v slotoch \`H(k)+1Â², H(k)+2Â², ...\`.
        *   **DvojitÃ© heÅ¡ovanie:** PouÅ¾ije sa druhÃ¡ heÅ¡ovacia funkcia \`H2(k)\` na urÄenie kroku sondovania: \`H(k)+1*H2(k), H(k)+2*H2(k), ...\`.
*   **VÃ½hody:**
    *   **NiÅ¾Å¡ia pamÃ¤Å¥ovÃ¡ nÃ¡roÄnosÅ¥:** NevyÅ¾adujÃº sa dodatoÄnÃ© ukazovatele pre zreÅ¥azenÃ© zoznamy. VÅ¡etky dÃ¡ta sÃº priamo v tabuÄ¾ke.
    *   **LepÅ¡ie vyuÅ¾itie cache:** Prvky sÃº Äasto uloÅ¾enÃ© blÃ­zko seba v pamÃ¤ti, Äo mÃ´Å¾e viesÅ¥ k rÃ½chlejÅ¡iemu prÃ­stupu.
*   **NevÃ½hody:**
    *   **KomplikovanejÅ¡ie mazanie prvkov:** JednoduchÃ© odstrÃ¡nenie prvku mÃ´Å¾e preruÅ¡iÅ¥ sondovaciu sekvenciu pre inÃ© prvky. VyÅ¾aduje sa oznaÄenie slotu ako "vymazanÃ½" (tombstone) alebo komplexnejÅ¡Ã­ rehash.
    *   **CitlivosÅ¥ na faktor zaplnenia:** VÃ½kon sa vÃ½razne zhorÅ¡uje, keÄ sa faktor zaplnenia blÃ­Å¾i k 1 (tabuÄ¾ka je takmer plnÃ¡). Pre otvorenÃº adresÃ¡ciu musÃ­ byÅ¥ faktor zaplnenia < 1.
    *   **ProblÃ©m zhlukovania (clustering):**
        *   *PrimÃ¡rne zhlukovanie (LineÃ¡rne sondovanie):* ObsadenÃ© sloty majÃº tendenciu tvoriÅ¥ sÃºvislÃ© bloky, Äo predlÅ¾uje sondovacie sekvencie.
        *   *SekundÃ¡rne zhlukovanie (KvadratickÃ© sondovanie):* Ak dva kÄ¾ÃºÄe heÅ¡ujÃº na rovnakÃ½ poÄiatoÄnÃ½ slot, budÃº nasledovaÅ¥ rovnakÃº sondovaciu sekvenciu. DvojitÃ© heÅ¡ovanie tento problÃ©m zmierÅˆuje.
    *   Potreba dobrej heÅ¡ovacej funkcie a vhodnej sondovacej stratÃ©gie je kritickejÅ¡ia.

**3. VyuÅ¾itie preplÅˆovacej oblasti (Overflow Area / Separate Overflow Chaining):**

*   **Popis:**
    *   HeÅ¡ovacia tabuÄ¾ka je rozdelenÃ¡ na dve oblasti:
        *   **PrimÃ¡rna oblasÅ¥:** HlavnÃ¡ ÄasÅ¥ tabuÄ¾ky, kam sa prvky snaÅ¾ia uloÅ¾iÅ¥ priamo na zÃ¡klade ich heÅ¡ovacej hodnoty. KaÅ¾dÃ½ slot v primÃ¡rnej oblasti mÃ´Å¾e obsahovaÅ¥ jeden prvok.
        *   **PreplÅˆovacia oblasÅ¥ (Overflow Area):** SamostatnÃ¡ oblasÅ¥ pamÃ¤te (mÃ´Å¾e byÅ¥ inÃ¡ heÅ¡ovacia tabuÄ¾ka, zreÅ¥azenÃ½ zoznam, alebo vyhradenÃ¡ ÄasÅ¥ pÃ´vodnej tabuÄ¾ky), kam sa ukladajÃº prvky, ktorÃ© spÃ´sobili kolÃ­ziu v primÃ¡rnej oblasti.
    *   Ak je slot v primÃ¡rnej oblasti obsadenÃ½, kolidujÃºci prvok sa umiestni do preplÅˆovacej oblasti. Slot v primÃ¡rnej oblasti mÃ´Å¾e obsahovaÅ¥ ukazovateÄ¾ na zaÄiatok reÅ¥azca synonÃ½m v preplÅˆovacej oblasti.
*   **VÃ½hody:**
    *   **Oddelenie kolidujÃºcich prvkov:** UdrÅ¾uje primÃ¡rnu oblasÅ¥ relatÃ­vne "ÄistÃº", Äo mÃ´Å¾e zrÃ½chliÅ¥ prÃ­stup k prvkom, ktorÃ© nekolidovali.
    *   **JednoduchÅ¡ie riadenie kolÃ­ziÃ­:** KolÃ­zie sÃº spravovanÃ© v dedikovanej oblasti, Äo mÃ´Å¾e zjednoduÅ¡iÅ¥ logiku.
    *   MÃ´Å¾e byÅ¥ kombinÃ¡ciou vÃ½hod otvorenej adresÃ¡cie (pre primÃ¡rnu oblasÅ¥) a zreÅ¥azovania (pre preplÅˆovaciu oblasÅ¥).
*   **NevÃ½hody:**
    *   **Obmedzenie maximÃ¡lneho poÄtu prvkov:** Ak mÃ¡ preplÅˆovacia oblasÅ¥ fixnÃº veÄ¾kosÅ¥, mÃ´Å¾e sa zaplniÅ¥.
    *   **PotenciÃ¡lne dve Ãºrovne prÃ­stupu:** Ak prvok nie je v primÃ¡rnej oblasti, musÃ­ sa hÄ¾adaÅ¥ v preplÅˆovacej, Äo mÃ´Å¾e byÅ¥ pomalÅ¡ie.
    *   **SprÃ¡va preplÅˆovacej oblasti:** VyÅ¾aduje dodatoÄnÃº logiku a pamÃ¤Å¥ pre sprÃ¡vu tejto oblasti. MÃ´Å¾e byÅ¥ zloÅ¾itejÅ¡ia na implementÃ¡ciu ako jednoduchÃ© zreÅ¥azovanie.
    *   Ak je preplÅˆovacia oblasÅ¥ zle navrhnutÃ¡ alebo sa rÃ½chlo zaplnÃ­, vÃ½kon mÃ´Å¾e vÃ½razne klesnÃºÅ¥.

KaÅ¾dÃ¡ metÃ³da mÃ¡ svoje kompromisy a vhodnosÅ¥ zÃ¡visÃ­ od konkrÃ©tnych poÅ¾iadaviek aplikÃ¡cie (oÄakÃ¡vanÃ½ poÄet prvkov, frekvencia operÃ¡ciÃ­, poÅ¾iadavky na pamÃ¤Å¥, atÄ.).`
            }
        ];

        let deck = [];
        const flashcardContainer = document.getElementById('flashcard-container');
        const flashcardElement = document.querySelector('.flashcard');
        const frontFace = document.querySelector('.flashcard-front');
        const backFace = document.querySelector('.flashcard-back');
        const controlsElement = document.getElementById('controls');
        const correctBtn = document.getElementById('correct-btn');
        const incorrectBtn = document.getElementById('incorrect-btn');
        const statusElement = document.getElementById('status');
        const completionMessageElement = document.getElementById('completion-message');

        let isFlipped = false;

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function formatAnswer(answerText) {
            // ZÃ¡kladnÃ© nahradenie pre bullet pointy a ÄÃ­slovanÃ© zoznamy
            // MÃ´Å¾e byÅ¥ rozÅ¡Ã­renÃ© pre komplexnejÅ¡ie formÃ¡tovanie
            let htmlAnswer = answerText.replace(/â€¢\s/g, '<li>');
            
            // Regex na nÃ¡jdenie riadkov zaÄÃ­najÃºcich ÄÃ­slom s bodkou (pre ÄÃ­slovanÃ© zoznamy)
            // Toto je zjednoduÅ¡enÃ©, nemusÃ­ pokryÅ¥ vÅ¡etky prÃ­pady vnorenÃ½ch zoznamov
            htmlAnswer = htmlAnswer.replace(/^(\d+\.)\s*(.*)/gm, (match, num, item) => `<li>${num} ${item}</li>`);
            
            // Ak sme pouÅ¾ili <li>, obalÃ­me to do <ul> alebo <ol>
            // Toto je heuristika, nemusÃ­ byÅ¥ dokonalÃ¡. Ak predpokladÃ¡me, Å¾e â€¢ sÃº ul a ÄÃ­sla ol.
            if (htmlAnswer.includes('<li>')) {
                 if (/<li>\d+\./.test(htmlAnswer)) { // Ak prvÃ© li zaÄÃ­na ÄÃ­slom
                    htmlAnswer = '<ol>' + htmlAnswer.replace(/<\/li>\n?/g, '</li>') + '</ol>';
                 } else {
                    htmlAnswer = '<ul>' + htmlAnswer.replace(/<\/li>\n?/g, '</li>') + '</ul>';
                 }
                 // OdstrÃ¡niÅ¥ prÃ¡zdne <li> ak vznikli
                 htmlAnswer = htmlAnswer.replace(/<li>\s*<\/li>/g, '');
            }

            // Nahradenie novÃ½ch riadkov za <br> tam, kde nie sÃº sÃºÄasÅ¥ou <li>
            // Toto je tricky, aby sme nepridÃ¡vali <br> dovnÃºtra uÅ¾ formÃ¡tovanÃ½ch zoznamov
            // JednoduchÅ¡ie je nechaÅ¥ to na `white-space: pre-wrap;` a formÃ¡tovaÅ¥ len explicitnÃ© Å¡truktÃºry

            // Namiesto komplexnÃ©ho nahrÃ¡dzania novÃ½ch riadkov, spoÄ¾ahneme sa na `white-space: pre-wrap;`
            // a len manuÃ¡lne upravÃ­me bullet pointy
            
            // JednoduchÅ¡ia verzia:
            htmlAnswer = answerText
                .replace(/\n\d+\.\s*/g, (match) => `<br>${match.trimStart()}`) // ZachovÃ¡ ÄÃ­slovanie
                .replace(/\nâ€¢\s*/g, (match) => `<br>${match.trimStart()}`);    // ZachovÃ¡ bullety

            return htmlAnswer;
        }


        function displayCurrentCard() {
            if (deck.length === 0) {
                flashcardContainer.style.display = 'none';
                controlsElement.style.display = 'none';
                statusElement.style.display = 'none';
                completionMessageElement.style.display = 'block';
                return;
            }

            flashcardContainer.style.display = 'block'; // Uisti sa, Å¾e je viditeÄ¾nÃ½
            statusElement.style.display = 'block';
            completionMessageElement.style.display = 'none';


            const cardData = deck[0];
            frontFace.textContent = cardData.question;
            backFace.innerHTML = cardData.answer; // PouÅ¾ijeme priamo, keÄÅ¾e formÃ¡tovanie je uÅ¾ v dÃ¡tach
                                                  // alebo pouÅ¾ijeme formatAnswer(cardData.answer) ak chceme dynamickÃ© formÃ¡tovanie

            flashcardElement.classList.remove('flipped');
            isFlipped = false;
            controlsElement.style.display = 'none'; // Skryjeme ovlÃ¡dacie prvky kÃ½m sa kartiÄka neotoÄÃ­
            updateStatus();
        }

        function updateStatus() {
            statusElement.textContent = `ZostÃ¡va kariet: ${deck.length}`;
        }

        flashcardElement.addEventListener('click', () => {
            if (deck.length === 0) return;
            flashcardElement.classList.toggle('flipped');
            isFlipped = !isFlipped;
            if (isFlipped) {
                controlsElement.style.display = 'flex';
            } else {
                controlsElement.style.display = 'none';
            }
        });

        correctBtn.addEventListener('click', () => {
            if (deck.length === 0) return;
            deck.shift(); // OdstrÃ¡ni prvÃº kartiÄku (aktuÃ¡lnu)
            displayCurrentCard();
        });

        incorrectBtn.addEventListener('click', () => {
            if (deck.length === 0) return;
            const incorrectCard = deck.shift(); // Vezme prvÃº kartiÄku
            deck.push(incorrectCard); // PridÃ¡ ju na koniec
            displayCurrentCard();
        });

        function startGame() {
            deck = [...initialCardsData]; // VytvorÃ­me pracovnÃº kÃ³piu
            shuffleArray(deck);
            displayCurrentCard();
        }

        startGame();
    </script>

</body>
</html>
