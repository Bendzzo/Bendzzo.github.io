<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flash Cards</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            padding: 20px;
            box-sizing: border-box;
            font-size: 16px; /* Z√°kladn√° veƒækos≈• p√≠sma */
        }

        .flashcard-container {
            perspective: 1000px;
            width: 90%;
            min-width: 320px; /* Minim√°lna ≈°√≠rka pre men≈°ie obrazovky */
            max-width: 750px; /* Zv√§ƒç≈°en√° maxim√°lna ≈°√≠rka */
            
            height: 65vh; /* V√Ω≈°ka ako percento v√Ω≈°ky okna */
            min-height: 400px; /* Minim√°lna v√Ω≈°ka karty */
            max-height: 550px; /* Maxim√°lna v√Ω≈°ka karty */
            
            margin-bottom: 20px;
        }

        .flashcard {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }

        .flashcard.flipped {
            transform: rotateY(180deg);
        }

        .flashcard-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 25px; /* Trochu zv√§ƒç≈°en√Ω padding */
            box-sizing: border-box;
            text-align: center;
            overflow-y: auto; /* Umo≈æn√≠ skrolovanie, ak je text dlh≈°√≠ */
            border-radius: 10px;
        }

        .flashcard-front {
            background-color: #e0f7fa;
            font-size: 1.25em; /* Zv√§ƒç≈°en√© p√≠smo pre ot√°zku (16px * 1.25 = 20px) */
        }

        .flashcard-back {
            background-color: #fff9c4;
            transform: rotateY(180deg);
            font-size: 1em; /* P√≠smo pre odpoveƒè (16px * 1 = 16px) */
            white-space: pre-wrap; /* Zachov√° form√°tovanie textu vr√°tane nov√Ωch riadkov */
        }
        
        .flashcard-back ul, .flashcard-back ol {
            text-align: left;
            padding-left: 20px;
            margin-top: 5px;
            margin-bottom: 5px;
        }
        .flashcard-back li {
            margin-bottom: 8px; /* Trochu v√§ƒç≈°√≠ odstup medzi polo≈ækami zoznamu */
        }

        .controls button {
            font-size: 28px; /* Zv√§ƒç≈°en√© tlaƒçidl√° */
            padding: 12px 24px; /* Zv√§ƒç≈°en√Ω padding tlaƒçidiel */
            margin: 0 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
        }

        #correct-btn {
            background-color: #a5d6a7;
        }
        #correct-btn:hover {
            background-color: #81c784;
        }

        #incorrect-btn {
            background-color: #ef9a9a;
        }
        #incorrect-btn:hover {
            background-color: #e57373;
        }

        #status {
            margin-top: 15px;
            font-size: 1.1em;
            color: #555;
        }

        #completion-message {
            font-size: 1.5em;
            color: green;
            text-align: center;
        }
    </style>
</head>
<body>

    <div id="flashcard-container">
        <div class="flashcard">
            <div class="flashcard-face flashcard-front"></div>
            <div class="flashcard-face flashcard-back"></div>
        </div>
    </div>

    <div id="controls" style="display: none;">
        <button id="correct-btn" title="Spr√°vne">‚úîÔ∏è</button>
        <button id="incorrect-btn" title="Nespr√°vne">‚ùå</button>
    </div>

    <div id="status"></div>
    <div id="completion-message" style="display:none;">
        V√Ωborne! V≈°etky kartiƒçky si √∫spe≈°ne pre≈°iel! üéâ
    </div>

    <script>
        const initialCardsData = [
            {
                question: "Rozdiel medzi AUT a APT:",
                answer: `AUT (Abstraktn√Ω √∫dajov√Ω typ):
‚Ä¢ Urƒçuje dom√©nu prvkov (pr√≠padne viac dom√©n)
‚Ä¢ Definuje oper√°cie na prvkoch dom√©ny
‚Ä¢ Je nez√°visl√Ω na konkr√©tnej implement√°cii
‚Ä¢ Je realizovateƒæn√Ω viacer√Ωmi abstraktn√Ωmi √∫dajov√Ωmi ≈°trukt√∫rami (AUS)

APT (Abstraktn√Ω pam√§≈•ov√Ω typ):
‚Ä¢ Urƒçuje ako √∫dajov√° ≈°trukt√∫ra organizuje bloky pam√§te v pam√§ti
‚Ä¢ Definuje oper√°cie typick√© pre dan√© pam√§≈•ov√© usporiadanie
‚Ä¢ ≈†pecifikuje po≈æiadavky na bloky pam√§te
‚Ä¢ Je typicky implementovan√Ω ako rozhranie
‚Ä¢ Je realizovateƒæn√Ω viacer√Ωmi sp√¥sobmi s odli≈°nou organiz√°ciou blokov pam√§te

Oba typy s√∫ abstraktn√© a funguj√∫ ako "ƒçierne skrinky". Hlavn√Ω rozdiel je v tom, ≈æe AUT sa zameriava na √∫daje a oper√°cie s nimi, zatiaƒæ ƒço APT sa zameriava na organiz√°ciu pam√§te a oper√°cie s ≈àou.`
            },
            {
                question: "ƒåo je to endianita a jej 2 typy:",
                answer: `Endianita sa t√Ωka sp√¥sobu, ak√Ωm sa viacbajtov√© √∫daje ukladaj√∫ v pam√§ti poƒç√≠taƒça. Existuj√∫ dva hlavn√© typy endianity:
1. Big-endian:
   ‚Ä¢ Najviac v√Ωznamn√Ω bajt sa uklad√° na ni≈æ≈°iu adresu.
   ‚Ä¢ Najmenej v√Ωznamn√Ω bajt sa uklad√° na vy≈°≈°iu adresu.
   ‚Ä¢ Oznaƒçuje sa ako "sie≈•ov√© poradie bajtov", preto≈æe sa v tomto porad√≠ posielaj√∫ √∫daje vo v√§ƒç≈°ine sie≈•ov√Ωch protokolov.
2. Little-endian:
   ‚Ä¢ Najmenej v√Ωznamn√Ω bajt sa uklad√° na ni≈æ≈°iu adresu.
   ‚Ä¢ Najviac v√Ωznamn√Ω bajt sa uklad√° na vy≈°≈°iu adresu.
   ‚Ä¢ Tento typ endianity sa pou≈æ√≠va v architekt√∫re PC.`
            },
            {
                question: "Ak√Ω je rozdiel medzi Implicitnou Sekvenciou a Explicitnou Sekvenciou:",
                answer: `Pozn√°mka: V√°≈° text uv√°dza Implicitn√∫/Explicitn√∫ hierarchiu, nie sekvenciu. Odpoveƒè je podƒæa textu pre hierarchie.

Implicitn√° hierarchia:
1. Mus√≠ by≈• v kompaktnej pam√§ti
2. Mo≈æn√© len pre usporiadan√© K-cestn√© hierarchie
3. Vz≈•ahy medzi vrcholmi (otec-syn) sa vypoƒç√≠tavaj√∫
4. Limitovan√° mno≈æina modifik√°torov - mus√≠ zosta≈• kompletn√°
5. Efekt√≠vna z hƒæadiska pam√§te, ale menej flexibiln√°
6. Vhodn√° pre kompletn√© a vyv√°≈æen√© hierarchie

Explicitn√° hierarchia:
1. M√¥≈æe by≈• v ƒæubovoƒænej pam√§ti (vr√°tane externej)
2. Mo≈æn√° pre v≈°etky typy hierarchi√≠
3. Vz≈•ahy medzi vrcholmi s√∫ explicitne ulo≈æen√© (referencie)
4. V√§ƒç≈°ia flexibilita pri modifik√°cii ≈°trukt√∫ry
5. Vy≈°≈°ia pam√§≈•ov√° n√°roƒçnos≈• kv√¥li ukladaniu referenci√≠
6. Vhodn√° pre dynamick√© a nepravideln√© hierarchie

Implicitn√° hierarchia je pam√§≈•ovo efekt√≠vnej≈°ia, ale menej flexibiln√°. Explicitn√° hierarchia je flexibilnej≈°ia, ale n√°roƒçnej≈°ia na pam√§≈•.`
            },
            {
                question: "Vyp√≠sa≈• 3 druhy O-not√°cie a jej n√°zvy:",
                answer: `1. O(f(n)) - Horn√Ω asymptotick√Ω odhad: Funkcia z(n) je asymptoticky men≈°ia alebo rovn√° ako c*f(n) pre nejak√© kladn√© kon≈°tanty c a k.
2. Œ©(f(n)) - Doln√Ω asymptotick√Ω odhad: Funkcia z(n) je asymptoticky v√§ƒç≈°ia alebo rovn√° ako c*f(n) pre nejak√© kladn√© kon≈°tanty c a k.
3. Œò(f(n)) - Tesn√Ω asymptotick√Ω odhad: Funkcia z(n) je asymptoticky rovn√° ako c*f(n) pre nejak√© kladn√© kon≈°tanty c a k.
(Pozn√°mka: P√¥vodn√Ω text mal ƒç√≠slovanie 3,4,5, tu upraven√© na 1,2,3 pre prehƒæadnos≈•)`
            },
            {
                question: "Zoradi≈• tabuƒæky podƒæa oper√°cie odober s dan√Ωm kƒæ√∫ƒçom:",
                answer: `1. Tabuƒæka s rozpt√Ωlen√Ωmi z√°znamami (bez rie≈°enia kol√≠zi√≠): O(1)
2. Tabuƒæka s rozpt√Ωlen√Ωmi z√°znamami (zre≈•azovanie): O(1)
3. Tabuƒæka s rozpt√Ωlen√Ωmi z√°znamami (prepl≈àovacia oblas≈•): O(1)
4. Bin√°rny vyhƒæad√°vac√≠ strom: O(log n) v priemernom pr√≠pade, O(n) v najhor≈°om pr√≠pade`
            },
            {
                question: "Vysvetli≈• ak√° je to perfektn√° hierarchia, a nakresli≈• ju s 13timi vrcholmi:",
                answer: `Perfektn√° hierarchia:
‚Ä¢ V≈°etky listy s√∫ v rovnakej hƒ∫bke. To znamen√°, ≈æe v≈°etky vrcholy bez synov (listy) s√∫ vzdialen√© od kore≈àa rovnak√Ω poƒçet √∫rovn√≠.
‚Ä¢ V≈°etky vn√∫torn√© vrcholy maj√∫ stupe≈à n (pre n-√°rnu hierarchiu). To znamen√°, ≈æe ka≈æd√Ω vrchol s aspo≈à jedn√Ωm synom m√° presne n synov.

N√°kres s 13 vrcholmi (napr. pre bin√°rnu perfektn√∫ hierarchiu, kde n=2):
(N√°kres tu nie je mo≈æn√© zobrazi≈• textovo, ale predstavte si:)
√örove≈à 0: 1 vrchol (kore≈à)
√örove≈à 1: 2 vrcholy (synovia kore≈àa)
√örove≈à 2: 4 vrcholy (synovia vrcholov z √∫rovne 1)
√örove≈à 3: 6 vrcholov (synovia 3 vrcholov z √∫rovne 2, aby bol s√∫ƒçet 1+2+4+6 = 13. Ak by mala by≈• striktne perfektn√° a kompletn√°, tak by posledn√° √∫rove≈à mala 8 vrcholov, celkovo 15).
Ak m√° ma≈• *presne* 13 vrcholov a by≈• perfektn√°, mus√≠ by≈• n-√°rna, kde n je voliteƒæn√©. Pre bin√°rny strom (n=2) by to nebola √∫plne perfektn√° po posledn√∫ √∫rove≈à ak m√° presne 13 vrcholov. Perfektn√Ω bin√°rny strom m√° 2^h - 1 vrcholov. Pre 13 vrcholov by to znamenalo, ≈æe nie v≈°etky vn√∫torn√© vrcholy na predposlednej √∫rovni maj√∫ pln√Ω poƒçet synov.
Pre K-cestn√∫ perfektn√∫ hierarchu:
- Ak K=3 (tern√°rny strom):
  - √örove≈à 0: 1
  - √örove≈à 1: 3 (spolu 4)
  - √örove≈à 2: 9 (spolu 13)
  Toto by bola perfektn√° tern√°rna hierarchia s hƒ∫bkou 2 a 13 vrcholmi.

  Pr√≠klad (Tern√°rna, K=3):
        O  (1)
       /|\
      O O O (3)
     /|\/|\/|\
    O O O O O O O O O (9)
    Spolu: 1 + 3 + 9 = 13 vrcholov. V≈°etky listy na √∫rovni 2. V≈°etky vn√∫torn√© vrcholy (na √∫rovni 0 a 1) maj√∫ 3 synov.`
            },
            {
                question: "BVS popis, ak√∫ implement√°ciu hierarchie pou≈æ√≠va, a pop√≠sa≈• logiku oper√°ci√≠ vlo≈æ a vyber:",
                answer: `Implement√°cia hierarchie:
‚Ä¢ BVS pou≈æ√≠va explicitn√∫ bin√°rnu hierarchiu.
‚Ä¢ Ka≈æd√Ω vrchol je reprezentovan√Ω samostatn√Ωm objektom v pam√§ti.
‚Ä¢ Vrchol obsahuje: Kƒæ√∫ƒç, √∫daje, odkaz na otca (voliteƒæne), ƒæav√©ho syna a prav√©ho syna.

Logika oper√°cie vlo≈æ:
1. Pok√∫si sa n√°js≈• vrchol s vkladan√Ωm kƒæ√∫ƒçom:
   ‚Ä¢ Testuje unik√°tnos≈• kƒæ√∫ƒça (ak je vy≈æadovan√°).
   ‚Ä¢ Z√≠ska vrchol (rodiƒça), ku ktor√©mu m√° by≈• nov√Ω vrchol pripojen√Ω ako syn.
2. Ak sa vrchol s dan√Ωm kƒæ√∫ƒçom nen√°jde (alebo ak duplik√°ty nie s√∫ povolen√© a kƒæ√∫ƒç je unik√°tny):
   ‚Ä¢ Vytvor√≠ nov√Ω vrchol.
   ‚Ä¢ Vlo≈æ√≠ ho do hierarchie tak, aby nebolo poru≈°en√© usporiadanie BVS (men≈°ie kƒæ√∫ƒçe vƒæavo od rodiƒça, v√§ƒç≈°ie kƒæ√∫ƒçe vpravo od rodiƒça).
   ‚Ä¢ Prirad√≠ do≈à √∫daje.
   ‚Ä¢ Zv√Ω≈°i poƒçet prvkov.

Logika oper√°cie vyber:
1. N√°jde vrchol s dan√Ωm kƒæ√∫ƒçom. Ak sa nen√°jde, oper√°cia konƒç√≠.
2. Ak sa vrchol n√°jde, odstr√°ni ho z hierarchie tak, aby nebolo poru≈°en√© usporiadanie BVS. Rozli≈°uj√∫ sa pr√≠pady:
   a) Vrchol nem√° synov (je list): Jednoducho sa odstr√°ni.
   b) Vrchol m√° jedn√©ho syna: Vrchol sa nahrad√≠ jeho jedin√Ωm synom.
   c) Vrchol m√° dvoch synov: N√°jde sa jeho inorder n√°sledn√≠k (najmen≈°√≠ prvok v pravom podstrome) alebo inorder predchodca (najv√§ƒç≈°√≠ prvok v ƒæavom podstrome). Hodnota n√°sledn√≠ka/predchodcu sa skop√≠ruje do odstra≈àovan√©ho vrcholu a n√°sledne sa rekurz√≠vne odstr√°ni tento n√°sledn√≠k/predchodca (ktor√Ω m√° najviac jedn√©ho syna).
3. Vr√°ti √∫daje z odstr√°nen√©ho vrcholu (voliteƒæne).
4. Dealokuje pam√§≈• vrcholu, zn√≠≈æi poƒçet prvkov.`
            },
            {
                question: "Rozdiel medzi AUT a AU≈†, po jednom pr√≠klade:",
                answer: `AUT (Abstraktn√Ω √∫dajov√Ω typ):
‚Ä¢ Urƒçuje dom√©nu prvkov (pr√≠padne viac dom√©n).
‚Ä¢ Definuje oper√°cie na prvkoch dom√©ny ("ƒço" sa d√° robi≈•).
‚Ä¢ Je nez√°visl√Ω na konkr√©tnej implement√°cii.
‚Ä¢ Je realizovateƒæn√Ω viacer√Ωmi abstraktn√Ωmi √∫dajov√Ωmi ≈°trukt√∫rami (AUS).
‚Ä¢ Pr√≠klad AUT: Z√°sobn√≠k (oper√°cie: push, pop, top, isEmpty).

AU≈† (Abstraktn√° √∫dajov√° ≈°trukt√∫ra):
‚Ä¢ Je to konkr√©tna implement√°cia AUT.
‚Ä¢ Definuje, ako s√∫ d√°ta organizovan√© v pam√§ti.
‚Ä¢ Poskytuje konkr√©tne algoritmy pre oper√°cie definovan√© v AUT.
‚Ä¢ Popisuje "ako" ≈°trukt√∫ra funguje interne.
‚Ä¢ Pr√≠klad AU≈†: Z√°sobn√≠k implementovan√Ω pomocou poƒæa (array-based stack) alebo Z√°sobn√≠k implementovan√Ω pomocou zre≈•azen√©ho zoznamu (linked-list-based stack).

Hlavn√Ω rozdiel je teda v √∫rovni abstrakcie: AUT poskytuje abstraktn√Ω pohƒæad na ≈°trukt√∫ru a jej spr√°vanie (ƒço rob√≠), zatiaƒæ ƒço AU≈† poskytuje konkr√©tnu implement√°ciu tohto spr√°vania (ako to rob√≠).`
            },
            {
                question: "Riadiaci blok explicitnej hierarchie, z ƒçoho sa sklad√°, teda atrib√∫ty a e≈°te nieƒço k tomu asi popis na ƒço s√∫ tie atrib√∫ty:",
                answer: `Riadiaci blok explicitnej hierarchie typicky obsahuje nasleduj√∫ce atrib√∫ty:
1. Referencia na kore≈à:
   ‚Ä¢ Atrib√∫t: napr. \`koren\` (typu referencia na blok pam√§te/vrchol)
   ‚Ä¢ Popis: Uchov√°va referenciu na kore≈àov√Ω vrchol hierarchie. Umo≈æ≈àuje pr√≠stup k celej ≈°trukt√∫re, keƒè≈æe v≈°etky ostatn√© vrcholy s√∫ dostupn√© cez kore≈à. Je to vstupn√Ω bod do hierarchie.
2. Referencia na posledn√Ω pou≈æit√Ω vrchol (current/active node):
   ‚Ä¢ Atrib√∫t: napr. \`poslednyVrchol\`, \`aktualnyVrchol\` (typu referencia na blok pam√§te/vrchol)
   ‚Ä¢ Popis: Uchov√°va referenciu na vrchol, s ktor√Ωm sa naposledy pracovalo (napr. v√Ωsledok oper√°cie n√°jdi, vlo≈æ). M√¥≈æe zr√Ωchli≈• niektor√© sekvenƒçn√© oper√°cie alebo oper√°cie vy≈æaduj√∫ce kontext predch√°dzaj√∫ceho pr√≠stupu. Nie je v≈ædy povinn√Ω.
3. Poƒçet prvkov (mohutnos≈•):
   ‚Ä¢ Atrib√∫t: napr. \`pocetPrvkov\` (typu integer)
   ‚Ä¢ Popis: Uchov√°va aktu√°lny poƒçet vrcholov v hierarchii. U≈æitoƒçn√© pre r√Ωchle zistenie veƒækosti ≈°trukt√∫ry bez potreby prech√°dzania v≈°etk√Ωch vrcholov.
ƒéal≈°ie mo≈æn√© atrib√∫ty (v z√°vislosti od ≈°pecifickej implement√°cie a potrieb):
4. Referencia na Predchodcu (ak je hierarchia ≈°pecificky ≈°trukt√∫rovan√°, napr. pre explicitn√© sekvencie v r√°mci hierarchie, alebo ak ide o obojsmerne zre≈•azen√∫ ≈°trukt√∫ru na nejakej √∫rovni). V≈°eobecne pre hierarchiu ako tak√∫ to nie je typick√© pre riadiaci blok, sk√¥r pre samotn√© vrcholy (ukazovateƒæ na rodiƒça).
5. Referencia na Nasledovn√≠ka (podobne ako predchodca, relevantn√© pre ≈°pecifick√© ≈°trukt√∫ry).

Prim√°rne s√∫ to referencia na kore≈à a poƒçet prvkov. Ostatn√© s√∫ doplnkov√© a z√°visia od konkr√©tneho n√°vrhu.`
            },
            {
                question: "Z ƒçoho sa sklad√° Bitonic sort:",
                answer: `Bitonic sorter (Bitonick√° triediaca sie≈•) sa sklad√° z kask√°dovo zapojen√Ωch jednoduch≈°√≠ch komponentov, konkr√©tne:
1.  **Porovn√°vaƒç (Comparator):** Z√°kladn√Ω stavebn√Ω blok. Je to zariadenie s dvoma vstupmi a dvoma v√Ωstupmi. Na v√Ωstup d√°va hodnoty zo vstupu usporiadan√© (napr. men≈°ia hore, v√§ƒç≈°ia dole, alebo naopak).
2.  **Bitonic Sequence (Bitonick√° sekvencia):** Toto nie je komponent siete, ale typ sekvencie, s ktorou sie≈• pracuje. Je to sekvencia, ktor√° najprv monot√≥nne nekles√° (rastie alebo stagnuje) a potom monot√≥nne nerastie (kles√° alebo stagnuje), alebo naopak (po cyklickom posune). Napr√≠klad: (1, 2, 5, 8, 6, 4, 3) alebo (8, 6, 4, 1, 2, 5, 7).
3.  **Half-Cleaner (Poloviƒçn√Ω ƒçistiƒç / Bitonic Splitter):**
    *   T√°to ƒças≈• siete berie na vstup bitonick√∫ sekvenciu o dƒ∫≈æke N.
    *   Pozost√°va z N/2 porovn√°vaƒçov. Ka≈æd√Ω porovn√°vaƒç sp√°ja prvok i s prvkom i+N/2.
    *   Na v√Ωstupe produkuje dve bitonick√© sekvencie, ka≈æd√∫ o dƒ∫≈æke N/2. V≈°etky prvky v jednej sekvencii s√∫ men≈°ie alebo rovn√© v≈°etk√Ωm prvkom v druhej sekvencii.
4.  **Merger (Zluƒçovaƒç / Bitonic Merger):**
    *   T√°to ƒças≈• siete berie na vstup bitonick√∫ sekvenciu a na v√Ωstupe d√°va utrieden√∫ sekvenciu.
    *   Realizuje sa rekurz√≠vnym pou≈æit√≠m Half-Cleaneru. Po prvom Half-Cleaneri dostaneme dve men≈°ie bitonick√© sekvencie, na ktor√© op√§≈• aplikujeme Merger (ktor√Ω v sebe pou≈æije Half-Cleaner atƒè.), a≈æ k√Ωm nezostan√∫ sekvencie dƒ∫≈æky 1.
5.  **Bitonic Sorter (Cel√° triediaca sie≈•):**
    *   Na vytvorenie utriedenej sekvencie z ƒæubovoƒænej vstupnej sekvencie sa najprv vstupn√° sekvencia transformuje na bitonick√∫ sekvenciu.
    *   Toto sa rob√≠ tak, ≈æe sa najprv utriedia men≈°ie podsiete (napr. dvojice prvkov, ƒç√≠m vznikn√∫ bitonick√© sekvencie dƒ∫≈æky 2).
    *   Potom sa tieto bitonick√© sekvencie zluƒçuj√∫ pomocou Mergerov tak, aby vznikali v√§ƒç≈°ie bitonick√© sekvencie (napr. dve utrieden√© sekvencie dƒ∫≈æky 2 sa spoja do bitonickej sekvencie dƒ∫≈æky 4 ‚Äì jedna sa obr√°ti a pripoj√≠).
    *   Nakoniec sa na v√Ωsledn√∫ bitonick√∫ sekvenciu plnej dƒ∫≈æky aplikuje Merger, ktor√Ω ju utriedi.

V skratke, Bitonic Sort sa sklad√° z viacer√Ωch stup≈àov Mergerov, kde ka≈æd√Ω Merger je postaven√Ω z Half-Cleanerov a tie s√∫ postaven√© z porovn√°vaƒçov.`
            },
            {
                question: "Bin√°rny vyhƒæad√°vac√≠ strom ako funguj√∫ met√≥dy vlo≈æ, vyhƒæadaj a vyber a ich zlo≈æitosti a d√¥vod danej zlo≈æitosti, kedy BVS zdegeneruje a pr√≠klad a zlo≈æitosti dan√Ωch oper√°ci√≠ pri zdegenerovan√≠ a mechanizmus na pred√≠denie zdegenerovania:",
                answer: `**Met√≥da vyhƒæadaj (search):**
*   Fungovanie: Zaƒç√≠na v koreni. Porovn√°va hƒæadan√Ω kƒæ√∫ƒç s kƒæ√∫ƒçom aktu√°lneho vrcholu. Ak sa rovnaj√∫, vrchol je n√°jden√Ω. Ak je hƒæadan√Ω kƒæ√∫ƒç men≈°√≠, pokraƒçuje v ƒæavom podstrome. Ak je v√§ƒç≈°√≠, pokraƒçuje v pravom podstrome. Opakuje, k√Ωm nen√°jde kƒæ√∫ƒç alebo nedosiahne NULL (list).
*   Zlo≈æitos≈•: O(h), kde h je v√Ω≈°ka stromu.
    *   Priemern√Ω pr√≠pad (vyv√°≈æen√Ω strom): O(log n), preto≈æe v√Ω≈°ka je logaritmick√° k poƒçtu prvkov n.
    *   Najhor≈°√≠ pr√≠pad (zdegenerovan√Ω strom): O(n), preto≈æe v√Ω≈°ka je line√°rna.

**Met√≥da vlo≈æ (insert):**
*   Fungovanie: Podobne ako vyhƒæad√°vanie, n√°jde sa miesto, kam nov√Ω prvok patr√≠ (NULL referencia, kde by mal by≈•). Na tomto mieste sa vytvor√≠ nov√Ω vrchol s dan√Ωm kƒæ√∫ƒçom a √∫dajmi.
*   Zlo≈æitos≈•: O(h).
    *   Priemern√Ω pr√≠pad: O(log n).
    *   Najhor≈°√≠ pr√≠pad: O(n).

**Met√≥da vyber (delete/remove):**
*   Fungovanie: Najprv vyhƒæad√° vrchol na vymazanie.
    1.  Ak vrchol nem√° synov (je list): Jednoducho sa odstr√°ni (referencia rodiƒça na≈à sa nastav√≠ na NULL).
    2.  Ak vrchol m√° jedn√©ho syna: Rodiƒç odstra≈àovan√©ho vrcholu sa prepoj√≠ priamo na jedin√©ho syna odstra≈àovan√©ho vrcholu.
    3.  Ak vrchol m√° dvoch synov: N√°jde sa jeho inorder n√°sledn√≠k (najmen≈°√≠ prvok v pravom podstrome) alebo inorder predchodca (najv√§ƒç≈°√≠ prvok v ƒæavom podstrome). Hodnota (kƒæ√∫ƒç a √∫daje) n√°sledn√≠ka/predchodcu sa skop√≠ruje do odstra≈àovan√©ho vrcholu. N√°sledne sa rekurz√≠vne odstr√°ni tento n√°sledn√≠k/predchodca (ktor√Ω m√° u≈æ najviac jedn√©ho syna, tak≈æe spad√° pod pr√≠pady 1 alebo 2).
*   Zlo≈æitos≈•: O(h).
    *   Priemern√Ω pr√≠pad: O(log n).
    *   Najhor≈°√≠ pr√≠pad: O(n).

**D√¥vod zlo≈æitosti:** Oper√°cie typicky postupuj√∫ od kore≈àa smerom k listu, priƒçom na ka≈ædej √∫rovni urobia kon≈°tantn√Ω poƒçet oper√°ci√≠. Maxim√°lny poƒçet √∫rovn√≠ je v√Ω≈°ka stromu h.

**Degener√°cia BVS:**
*   Kedy zdegeneruje: BVS zdegeneruje, keƒè sa jeho ≈°trukt√∫ra stane podobnou line√°rnemu zoznamu (ka≈æd√Ω vrchol m√° len jedn√©ho syna, alebo ≈æiadneho).
*   Pr√≠klad: Vkladanie u≈æ usporiadan√Ωch d√°t (napr. 1, 2, 3, 4, 5...) alebo vkladanie d√°t v opaƒçnom usporiadan√≠ (5, 4, 3, 2, 1...).
*   Zlo≈æitosti pri zdegenerovan√≠: V≈°etky oper√°cie (vyhƒæadaj, vlo≈æ, vyber) maj√∫ zlo≈æitos≈• O(n), preto≈æe strom sa spr√°va ako line√°rny zoznam a je potrebn√© prejs≈• potenci√°lne v≈°etky prvky.

**Mechanizmy na pred√≠denie degener√°cie (Samo-vyva≈æovacie stromy):**
1.  **AVL stromy:** Po ka≈ædej oper√°cii vlo≈æenia alebo vymazania kontroluj√∫ "faktor vyv√°≈æenia" ka≈æd√©ho vrcholu (rozdiel v√Ω≈°ok ƒæav√©ho a prav√©ho podstromu). Ak je rozdiel v√§ƒç≈°√≠ ako 1, vykonaj√∫ rot√°cie na obnovenie vyv√°≈æenia. Zaruƒçuj√∫ v√Ω≈°ku O(log n).
2.  **Red-Black stromy (ƒåerveno-ƒçierne stromy):** Pou≈æ√≠vaj√∫ farbenie vrcholov (ƒçerven√°/ƒçierna) a ≈°pecifick√© pravidl√° na udr≈æanie stromu pribli≈æne vyv√°≈æen√©ho. Zaruƒçuj√∫ v√Ω≈°ku O(log n).
3.  **B-stromy (a ich varianty, napr. B+ stromy):** Pou≈æ√≠van√© hlavne pre datab√°zy a s√∫borov√© syst√©my. Udr≈æiavaj√∫ vyv√°≈æenie t√Ωm, ≈æe vrcholy m√¥≈æu ma≈• viac synov a kƒæ√∫ƒçov.
4.  **Treap (Randomizovan√Ω BVS):** Ka≈æd√©mu vrcholu prirad√≠ n√°hodn√∫ prioritu a udr≈æiava strom tak, aby bol BVS vzhƒæadom na kƒæ√∫ƒçe a haldou vzhƒæadom na priority. Oƒçak√°van√° v√Ω≈°ka je O(log n).
5.  **Splay stromy:** Po ka≈ædom pr√≠stupe k vrcholu presun√∫ tento vrchol do kore≈àa pomocou s√©rie rot√°ci√≠ ("splaying"). Nemaj√∫ striktn√∫ O(log n) z√°ruku pre jednu oper√°ciu, ale amortizovan√° zlo≈æitos≈• oper√°ci√≠ je O(log n).
6.  **Periodick√© preusporiadanie:** Obƒçasn√© kompletn√© prebudovanie cel√©ho stromu do dokonale vyv√°≈æenej formy (napr. ak v√Ω≈°ka prekroƒç√≠ urƒçit√Ω n√°sobok log n).`
            },
            {
                question: "ƒåo je to hƒ∫bka a ƒço mohutnos≈• hierarchie:",
                answer: `1.  **Hƒ∫bka hierarchie (Depth/Height of a tree):**
    *   Defin√≠cia: Hƒ∫bka hierarchie je maxim√°lna √∫rove≈à ktor√©hokoƒævek vrcholu v hierarchii. √örove≈à kore≈àa sa ƒçasto definuje ako 0 (alebo niekedy 1). Ak je kore≈à na √∫rovni 0, potom hƒ∫bka je dƒ∫≈æka najdlh≈°ej cesty od kore≈àa k niektor√©mu listu (poƒçet hr√°n).
    *   In√Ωmi slovami, je to najv√§ƒç≈°ia vzdialenos≈• (poƒçet hr√°n) od kore≈àa k ak√©mukoƒævek listu v strome.
    *   Pr√≠klad: Ak m√° strom kore≈à na √∫rovni 0, jeho synovia s√∫ na √∫rovni 1, ich synovia na √∫rovni 2, atƒè. Ak najvzdialenej≈°√≠ list je na √∫rovni 3, hƒ∫bka stromu je 3.

2.  **Mohutnos≈• hierarchie (Size/Order of a tree):**
    *   Defin√≠cia: Mohutnos≈• hierarchie je celkov√Ω poƒçet vrcholov v hierarchii.
    *   Zah≈ï≈àa v≈°etky vrcholy - kore≈à, vn√∫torn√© vrcholy aj listy.
    *   Pr√≠klad: Strom s kore≈àom, dvoma jeho synmi a ka≈æd√Ω z t√Ωchto synov m√° jedn√©ho syna (list), m√° mohutnos≈• 1 (kore≈à) + 2 (synovia kore≈àa) + 2 (listy) = 5 vrcholov.`
            },
            {
                question: "4 implement√°cie prioritn√©ho frontu a zoraƒè ich na z√°klade oper√°cie VLO≈Ω (od najlep≈°ej):",
                answer: `Zoradenie implement√°ci√≠ prioritn√©ho frontu podƒæa zlo≈æitosti oper√°cie **VLO≈Ω** (od najlep≈°ej po najhor≈°iu):

1.  **Neutrieden√Ω sekvenƒçn√Ω prioritn√Ω front (implementovan√Ω ako pole alebo zre≈•azen√Ω zoznam):**
    *   Zlo≈æitos≈• oper√°cie VLO≈Ω: **O(1)**
    *   Vysvetlenie: Prvok sa jednoducho prid√° na koniec sekvencie (alebo na zaƒçiatok, ak je to v√Ωhodnej≈°ie pre implement√°ciu). Nevy≈æaduje sa ≈æiadne usporad√∫vanie ani hƒæadanie poz√≠cie.

2.  **Dvojzoznam (AUMS Dvojzoznam):**
    *   Zlo≈æitos≈• oper√°cie VLO≈Ω: **O(1) amortizovane**
    *   Vysvetlenie: Vklad√° sa do kr√°tkej sekvencie (O(1)), pokiaƒæ nie je pln√°. Ak je pln√°, jej obsah sa zl√∫ƒçi s dlhou sekvenciou, ƒço m√¥≈æe by≈• O(N), ale t√°to drah≈°ia oper√°cia sa nedeje ƒçasto, tak≈æe amortizovan√° zlo≈æitos≈• je O(1).

3.  **ƒΩavostrann√° halda (Bin√°rna halda):**
    *   Zlo≈æitos≈• oper√°cie VLO≈Ω: **O(log n)**
    *   Vysvetlenie: Nov√Ω prvok sa prid√° na koniec haldy (ako posledn√Ω list) a potom sa "prebubl√°va" nahor (oper√°cia heapify-up alebo sift-up), aby sa obnovila vlastnos≈• haldy. V√Ω≈°ka bin√°rneho stromu s n prvkami je O(log n).

4.  **Bin√°rny vyhƒæad√°vac√≠ strom (BVS) ako prioritn√Ω front:**
    *   Zlo≈æitos≈• oper√°cie VLO≈Ω: **O(log n) v priemere, O(n) v najhor≈°om pr√≠pade**
    *   Vysvetlenie: Vkladanie do BVS je v priemere logaritmick√©, ale ak strom zdegeneruje (napr. pri vkladan√≠ usporiadan√Ωch prvkov), zlo≈æitos≈• sa stane line√°rnou. Pre prioritn√Ω front by sa musel pou≈æi≈• vyva≈æovan√Ω BVS (napr. AVL, Red-Black) na zaruƒçenie O(log n).

5.  **Utrieden√Ω sekvenƒçn√Ω prioritn√Ω front (implementovan√Ω ako pole alebo zre≈•azen√Ω zoznam):**
    *   Zlo≈æitos≈• oper√°cie VLO≈Ω: **O(n)**
    *   Vysvetlenie: Pri ka≈ædom vkladan√≠ je potrebn√© n√°js≈• spr√°vne miesto v utriedenej sekvencii, aby sa zachovalo usporiadanie podƒæa priority. To m√¥≈æe vy≈æadova≈• posun a≈æ n prvkov v poli, alebo prechod a≈æ n prvkami v zre≈•azenom zozname.

Pozn√°mka: P√¥vodn√° ot√°zka ≈æiadala 4, text ich uv√°dzal. Pridal som ƒΩavostrann√∫ haldu ako typick√∫ implement√°ciu PF a BVS pre porovnanie. Ak sa m√°me dr≈æa≈• striktne len 4 z textu (ak tam boli len 4), tak vyberte relevantn√©. Poradie je podƒæa VLO≈Ω.`
            },
            {
                question: "ƒΩavostrann√° halda, op√≠sa≈•, nap√≠sa≈• APS, oper√°cie v≈°etky 3 pop√≠sa≈• a zlo≈æitosti k nim aj vysvetli≈• ich:",
                answer: `**ƒΩavostrann√° halda (Leftist Heap/Tree) - Pozn√°mka:**
V√°≈° text pravdepodobne mysl√≠ **Bin√°rnu haldu (Binary Heap)** implementovan√∫ pomocou implicitnej bin√°rnej hierarchie, ktor√° sa niekedy (aj keƒè nie √∫plne presne v akademickom kontexte) oznaƒçuje ako "ƒæavostrann√°" kv√¥li sp√¥sobu, ak√Ωm sa vypƒ∫≈àa (√∫pln√Ω bin√°rny strom sa vypƒ∫≈àa zƒæava doprava na poslednej √∫rovni). ≈†tandardn√° "ƒΩavostrann√° halda" (Leftist Heap) je in√° d√°tov√° ≈°trukt√∫ra (typ zl√∫ƒçiteƒænej haldy). Budem predpoklada≈•, ≈æe ide o **Bin√°rnu haldu**.

**Bin√°rna halda (Binary Heap):**
*   **Opis:** Bin√°rna halda je √∫pln√Ω bin√°rny strom (v≈°etky √∫rovne okrem poslednej s√∫ √∫plne zaplnen√© a posledn√° √∫rove≈à je zaplnen√° zƒæava doprava), kde ka≈æd√Ω vrchol spƒ∫≈àa vlastnos≈• haldy. Pre max-haldu plat√≠, ≈æe hodnota (priorita) v ka≈ædom vrchole je v√§ƒç≈°ia alebo rovn√° hodnot√°m v jeho synoch. Pre min-haldu je to naopak. Prvok s najvy≈°≈°ou (max-halda) alebo najni≈æ≈°ou (min-halda) prioritou je v≈ædy v koreni.
*   **Implement√°cia:** Veƒæmi efekt√≠vna implement√°cia pomocou implicitnej bin√°rnej hierarchie, typicky v poli. Vz≈•ahy otec-syn sa vypoƒç√≠tavaj√∫ pomocou indexov poƒæa.
    *   ƒΩav√Ω syn vrcholu na indexe \`i\`: \`2*i + 1\` (ak indexujeme od 0)
    *   Prav√Ω syn vrcholu na indexe \`i\`: \`2*i + 2\` (ak indexujeme od 0)
    *   Rodiƒç vrcholu na indexe \`i\`: \`floor((i-1)/2)\` (ak indexujeme od 0)

**APS (Abstraktn√° pam√§≈•ov√° ≈°trukt√∫ra) pre Bin√°rnu haldu:**
*   Implicitn√° bin√°rna hierarchia ulo≈æen√° v kompaktnej pam√§ti (typicky pole).
*   ≈†trukt√∫ra: \`Haldy <P, T>\` kde P je typ priority, T je typ √∫dajov.
    *   √ödaje: pole prvkov (ka≈æd√Ω prvok obsahuje prioritu P a √∫daje T)
    *   Atrib√∫ty: \`pocetPrvkov\`, \`kapacitaPola\`

**AUS (Abstraktn√° √∫dajov√° ≈°trukt√∫ra) pre Prioritn√Ω front implementovan√Ω Bin√°rnou haldou:**
*   Prioritn√Ω front <P, T> -> Bin√°rna halda <P, T> -> Implicitn√° bin√°rna hierarchia (pole)

**Oper√°cie (pre Max-Haldu):**
1.  **Vrchol (Top/Peek):**
    *   Popis: Vr√°ti prvok s najvy≈°≈°ou prioritou (kore≈à haldy) bez jeho odstr√°nenia.
    *   Zlo≈æitos≈•: **O(1)**
    *   Vysvetlenie: Prvok s najvy≈°≈°ou prioritou je v≈ædy v koreni haldy (prv√Ω prvok poƒæa). Pr√≠stup k nemu je priamy.

2.  **Vlo≈æ (Insert):**
    *   Popis:
        1.  Vlo≈æ√≠ nov√Ω prvok na prv√© voƒæn√© miesto na konci haldy (ako posledn√Ω list), aby sa zachovala vlastnos≈• √∫pln√©ho bin√°rneho stromu. T√Ωm sa zv√Ω≈°i \`pocetPrvkov\`.
        2.  Porovn√° vlo≈æen√Ω prvok s jeho rodiƒçom. Ak m√° vlo≈æen√Ω prvok vy≈°≈°iu prioritu, vymen√≠ sa s rodiƒçom.
        3.  Tento proces v√Ωmeny ("prebubl√°vanie nahor", sift-up, heapify-up) sa opakuje, k√Ωm prvok nedosiahne kore≈à alebo k√Ωm jeho priorita nie je men≈°ia alebo rovn√° priorite jeho rodiƒça (vlastnos≈• haldy je obnoven√°).
    *   Zlo≈æitos≈•: **O(log n)**, kde n je poƒçet prvkov v halde.
    *   Vysvetlenie: V najhor≈°om pr√≠pade nov√Ω prvok "vyst√∫pa" od listu a≈æ do kore≈àa. Dƒ∫≈æka tejto cesty je v√Ω≈°ka stromu, ktor√° je O(log n) pre √∫pln√Ω bin√°rny strom.

3.  **Vyber (Extract-Max/Pop):**
    *   Popis:
        1.  Odstr√°ni a vr√°ti prvok s najvy≈°≈°ou prioritou (kore≈à haldy).
        2.  Na miesto kore≈àa sa presunie posledn√Ω prvok z haldy (najpravej≈°√≠ list na najni≈æ≈°ej √∫rovni). T√Ωm sa zn√≠≈æi \`pocetPrvkov\`.
        3.  Tento nov√Ω kore≈à sa porovn√° so svojimi synmi. Ak m√° ni≈æ≈°iu prioritu ako niektor√Ω z jeho synov (vyberie sa syn s vy≈°≈°ou prioritou), vymen√≠ sa s t√Ωmto synom.
        4.  Tento proces v√Ωmeny ("klesanie nadol", sift-down, heapify-down) sa opakuje, k√Ωm prvok nedosiahne poz√≠ciu listu alebo k√Ωm jeho priorita nie je v√§ƒç≈°ia alebo rovn√° priorit√°m oboch jeho synov (vlastnos≈• haldy je obnoven√°).
    *   Zlo≈æitos≈•: **O(log n)**
    *   Vysvetlenie: V najhor≈°om pr√≠pade nov√Ω kore≈à "klesne" od kore≈àa a≈æ na √∫rove≈à listu. Dƒ∫≈æka tejto cesty je v√Ω≈°ka stromu, O(log n).`
            },
            {
                question: "Rozdiel medzi horn√Ωm a doln√Ωm asymptotick√Ωm odhadom a ktor√Ω je pre program√°tora viac podstatn√Ω a preƒço:",
                answer: `1.  **Horn√Ω asymptotick√Ω odhad (O-not√°cia, "Big O"):**
    *   Oznaƒçuje sa ako O(f(n)).
    *   Vyjadruje **horn√∫ hranicu** rastu funkcie ƒçasovej alebo pam√§≈•ovej zlo≈æitosti algoritmu.
    *   Znamen√°, ≈æe funkcia zlo≈æitosti T(n) rastie **nanajv√Ω≈° tak r√Ωchlo** ako n√°sobok funkcie f(n) pre dostatoƒçne veƒæk√© n. (T(n) ‚â§ c * f(n) pre n ‚â• n‚ÇÄ).
    *   Popisuje najhor≈°√≠ mo≈æn√Ω scen√°r v√Ωkonu algoritmu.

2.  **Doln√Ω asymptotick√Ω odhad (Œ©-not√°cia, "Big Omega"):**
    *   Oznaƒçuje sa ako Œ©(f(n)).
    *   Vyjadruje **doln√∫ hranicu** rastu funkcie ƒçasovej alebo pam√§≈•ovej zlo≈æitosti algoritmu.
    *   Znamen√°, ≈æe funkcia zlo≈æitosti T(n) rastie **aspo≈à tak r√Ωchlo** ako n√°sobok funkcie f(n) pre dostatoƒçne veƒæk√© n. (T(n) ‚â• c * f(n) pre n ‚â• n‚ÇÄ).
    *   Popisuje najlep≈°√≠ mo≈æn√Ω scen√°r v√Ωkonu algoritmu (algoritmus nem√¥≈æe by≈• r√Ωchlej≈°√≠ ne≈æ toto).

**Ktor√Ω je pre program√°tora viac podstatn√Ω a preƒço:**

Pre program√°tora je vo v≈°eobecnosti **viac podstatn√Ω horn√Ω asymptotick√Ω odhad (O-not√°cia)**, a to z nasleduj√∫cich d√¥vodov:

1.  **Garantuje maxim√°lny v√Ωkon (Worst-case scenario):** O-not√°cia poskytuje z√°ruku, ≈æe algoritmus nebude pracova≈• hor≈°ie (pomal≈°ie, n√°roƒçnej≈°ie na pam√§≈•) ne≈æ dan√° horn√° hranica, bez ohƒæadu na konkr√©tne vstupn√© d√°ta (pre dostatoƒçne veƒæk√© n). Toto je kƒæ√∫ƒçov√© pre predv√≠dateƒænos≈• a spoƒæahlivos≈• softv√©ru, najm√§ v kritick√Ωch aplik√°ci√°ch.
2.  **Optimaliz√°cia a v√Ωber algoritmu:** Program√°tori sa sna≈æia minimalizova≈• horn√∫ hranicu zlo≈æitosti. Pri porovn√°van√≠ dvoch algoritmov pre rovnak√Ω probl√©m sa ƒçasto uprednostn√≠ ten s lep≈°ou (ni≈æ≈°ou) O-not√°ciou, preto≈æe to znamen√° lep≈°√≠ v√Ωkon v najhor≈°om pr√≠pade.
3.  **Pl√°novanie zdrojov:** Umo≈æ≈àuje lep≈°ie pl√°nova≈• potrebn√© v√Ωpoƒçtov√© zdroje (ƒças CPU, pam√§≈•) a odhadova≈• ƒças behu programu pre veƒæk√© vstupy. Ak vieme, ≈æe algoritmus je O(n¬≤), m√¥≈æeme oƒçak√°va≈• v√Ωrazn√© spomalenie pri zdvojn√°soben√≠ veƒækosti vstupu.
4.  **Komunik√°cia a anal√Ωza:** O-not√°cia je ≈°tandardn√Ω sp√¥sob, ako diskutova≈• a porovn√°va≈• efektivitu algoritmov v informatike.

Aj keƒè Œ©-not√°cia je tie≈æ d√¥le≈æit√° (napr. na preuk√°zanie, ≈æe algoritmus je optim√°lny, ak sa jeho O-not√°cia zhoduje s Œ©-not√°ciou probl√©mu), O-not√°cia je praktickej≈°ia pre ka≈ædodenn√© rozhodovanie program√°tora o v√Ωkone a ≈°k√°lovateƒænosti. Program√°tora zauj√≠ma, ako sa bude jeho k√≥d spr√°va≈•, keƒè veci "p√¥jdu zle" alebo keƒè bude musie≈• spracova≈• veƒæk√© mno≈æstvo d√°t.`
            },
            {
                question: "Rozdiel medzi primit√≠vnymi a odvoden√Ωmi typmi:",
                answer: `**Primit√≠vne typy (Primitive Types):**
1.  S√∫ to z√°kladn√©, najjednoduch≈°ie √∫dajov√© typy, ktor√© s√∫ priamo vstavan√© do programovacieho jazyka.
2.  Nie s√∫ odvoden√© od ≈æiadnych in√Ωch typov.
3.  Typicky zah≈ï≈àaj√∫:
    *   **Cel√© ƒç√≠sla** (napr. \`int\`, \`short\`, \`long\`, \`byte\`)
    *   **Re√°lne ƒç√≠sla** (ƒç√≠sla s pohyblivou desatinnou ƒçiarkou, napr. \`float\`, \`double\`)
    *   **Typ znak** (napr. \`char\`)
    *   **Booleovsk√Ω typ** (logick√° hodnota, napr. \`boolean\`, \`bool\`, reprezentuj√∫ci pravda/nepravda)
    *   Niekedy sa sem zaraƒèuj√∫ aj **referencie/ukazovatele** (ako typ schopn√Ω uchova≈• adresu), aj keƒè ich povaha je trochu odli≈°n√°.
4.  S√∫ to ƒçasto **skal√°rne typy**: ich hodnoty je mo≈æn√© navz√°jom jednoducho porovn√°va≈• (napr. men≈°√≠, v√§ƒç≈°√≠, rovn√Ω sa).
5.  Oper√°cie s nimi s√∫ zvyƒçajne priamo podporovan√© hardv√©rom (napr. aritmetick√© oper√°cie).

**Odvoden√© typy (Derived Types / Composite Types / User-Defined Types):**
1.  S√∫ to zlo≈æitej≈°ie √∫dajov√© typy, ktor√© s√∫ vytvoren√© program√°torom z primit√≠vnych typov alebo in√Ωch odvoden√Ωch typov.
2.  Umo≈æ≈àuj√∫ ≈°trukt√∫rova≈• a organizova≈• d√°ta komplexnej≈°√≠m sp√¥sobom.
3.  Existuj√∫ r√¥zne sp√¥soby vytv√°rania odvoden√Ωch typov, najƒçastej≈°ie:
    *   **Agreg√°cia (Aggregation / Structuring):** Zl√∫ƒçenie viacer√Ωch existuj√∫cich typov (primit√≠vnych alebo odvoden√Ωch) do jedn√©ho nov√©ho typu. Pr√≠klady:
        *   **≈†trukt√∫ry** (struct v C/C++, record v Pascale)
        *   **Triedy** (class v objektovo-orientovan√Ωch jazykoch ako Java, C++, Python) ‚Äì triedy s√∫ viac ne≈æ len agreg√°cia, zah≈ï≈àaj√∫ aj spr√°vanie (met√≥dy).
        *   **Polia** (arrays): homog√©nna kolekcia prvkov rovnak√©ho typu.
        *   **N-tice** (tuples): heterog√©nna, usporiadan√° kolekcia prvkov.
    *   **Enumer√°cia (Enumeration):** Vymenovanie v≈°etk√Ωch mo≈æn√Ωch hodn√¥t, ktor√© m√¥≈æe typ nadob√∫da≈•. Hodnoty s√∫ zvyƒçajne symbolick√© kon≈°tanty. Pr√≠klad: \`enum Day { MONDAY, TUESDAY, ..., SUNDAY }\`.
    *   **Ukazovatele/Referencie na in√© typy:** Napr. \`int*\` (ukazovateƒæ na cel√© ƒç√≠slo).
    *   **Uniony:** Umo≈æ≈àuj√∫ uchov√°va≈• r√¥zne typy d√°t v tom istom pam√§≈•ovom mieste (ale v≈ædy len jeden typ naraz).

**Kƒæ√∫ƒçov√© rozdiely:**
*   **Z√°klad vs. Kon≈°trukcia:** Primit√≠vne typy s√∫ z√°kladn√© stavebn√© bloky, odvoden√© typy s√∫ z nich kon≈°truovan√©.
*   **Zlo≈æitos≈•:** Primit√≠vne typy s√∫ jednoduch√©, odvoden√© m√¥≈æu by≈• ƒæubovoƒæne zlo≈æit√©.
*   **Vstavanos≈•:** Primit√≠vne s√∫ zvyƒçajne vstavan√© v jazyku, odvoden√© definuje program√°tor (aj keƒè niektor√© odvoden√©, ako pole, m√¥≈æu ma≈• ≈°peci√°lnu syntax v jazyku).`
            },
            {
                question: "ƒåo sa uklad√° v halde, ako sa tam alokuje a dealokuje, ƒço je ukazovateƒæ a ƒço je visiaci ukazovateƒæ a ƒço je to a kedy vznik√° √∫nik pam√§te:",
                answer: `**Halda (Heap):**
ƒåas≈• pam√§te programu urƒçen√° na dynamick√∫ alok√°ciu pam√§te.

1.  **ƒåo sa uklad√° v halde:**
    *   **Dynamicky alokovan√© premenn√©/objekty:** Premenn√©, ktor√Ωch veƒækos≈• alebo ≈æivotnos≈• nie je zn√°ma v ƒçase kompil√°cie, alebo ktor√© maj√∫ pretrv√°va≈• medzi volaniami funkci√≠.
    *   Objekty vytvoren√© pomocou oper√°tora \`new\` (v C++, Java, C#) alebo funkci√≠ ako \`malloc\`, \`calloc\`, \`realloc\` (v C/C++).
    *   Premenn√©, ktor√© s√∫ pr√≠li≈° veƒæk√© na to, aby sa zmestili na z√°sobn√≠k (stack).

2.  **Ako sa alokuje v halde:**
    *   Program√°tor explicitne ≈æiada o blok pam√§te urƒçitej veƒækosti.
    *   V C: pomocou funkci√≠ \`malloc(size)\`, \`calloc(num, size)\`, \`realloc(ptr, new_size)\`.
    *   V C++: pomocou oper√°tora \`new\` (pre objekty vol√° aj kon≈°truktor) alebo spom√≠nan√Ωch C funkci√≠.
    *   V√Ωsledkom alok√°cie je **ukazovateƒæ** (adresa) na zaƒçiatok alokovan√©ho bloku pam√§te v halde. Ak alok√°cia zlyh√° (napr. nedostatok pam√§te), vr√°ti sa NULL (pre C funkcie) alebo sa vyhod√≠ v√Ωnimka (pre C++ \`new\`).

3.  **Ako sa dealokuje z haldy:**
    *   Program√°tor mus√≠ explicitne uvoƒæni≈• alokovan√∫ pam√§≈•, keƒè ju u≈æ nepotrebuje.
    *   V C: pomocou funkcie \`free(pointer)\`.
    *   V C++: pomocou oper√°tora \`delete pointer\` (pre jednotliv√© objekty, vol√° aj de≈°truktor) alebo \`delete[] pointer\` (pre polia objektov).
    *   Ako parameter sa po≈æaduje ukazovateƒæ na zaƒçiatok bloku pam√§te, ktor√Ω m√° by≈• uvoƒænen√Ω.

4.  **Ukazovateƒæ (Pointer):**
    *   Premenn√°, ktorej hodnota je **adresa in√©ho miesta v pam√§ti**.
    *   Umo≈æ≈àuje nepriamy pr√≠stup k d√°tam ulo≈æen√Ωm na tejto adrese (tzv. dereferencovanie).
    *   V kontexte haldy ukazovatele uchov√°vaj√∫ adresy dynamicky alokovan√Ωch blokov pam√§te.

5.  **Visiaci ukazovateƒæ (Dangling Pointer):**
    *   Ukazovateƒæ, ktor√Ω ukazuje na adresu v pam√§ti, ktor√° u≈æ bola **dealokovan√°** (uvoƒænen√°) alebo ktorej obsah u≈æ nie je platn√Ω (napr. ukazovateƒæ na lok√°lnu premenn√∫ funkcie, ktor√° u≈æ skonƒçila).
    *   Pou≈æitie (dereferencovanie) visiaceho ukazovateƒæa vedie k nedefinovan√©mu spr√°vaniu, ƒçasto k p√°du programu alebo po≈°kodeniu d√°t.
    *   Pr√≠klad:
        \`\`\`c
        int *p;
        {
            int x = 10;
            p = &x;
        } // x zanik√°, p je teraz visiaci ukazovateƒæ
        // *p = 20; // Chyba! Nedefinovan√© spr√°vanie
        \`\`\`
        Alebo:
        \`\`\`c
        int *ptr = (int*)malloc(sizeof(int));
        free(ptr);
        // ptr je teraz visiaci ukazovateƒæ
        // *ptr = 5; // Chyba!
        \`\`\`

6.  **√önik pam√§te (Memory Leak):**
    *   Vznik√°, keƒè program **strat√≠ v≈°etky referencie (ukazovatele) na dynamicky alokovan√Ω blok pam√§te v halde bez toho, aby t√∫to pam√§≈• predt√Ωm uvoƒænil.**
    *   Alokovan√° pam√§≈• zost√°va obsaden√°, ale program k nej u≈æ nem√° pr√≠stup, a teda ju nem√¥≈æe ani pou≈æi≈•, ani uvoƒæni≈•.
    *   D√¥sledok: Postupn√© vyƒçerp√°vanie dostupnej pam√§te, ƒço m√¥≈æe vies≈• k spomaleniu alebo p√°du programu, pr√≠padne cel√©ho syst√©mu.
    *   Pr√≠klad:
        \`\`\`c
        void memory_leak_example() {
            int *ptr = (int*)malloc(sizeof(int));
            // ... nejak√° pr√°ca s ptr ...
            // Zabudli sme zavola≈• free(ptr)
            // Keƒè funkcia skonƒç√≠, ukazovateƒæ ptr zanikne,
            // ale alokovan√° pam√§≈• zostane obsaden√°.
        }

        // Alebo
        int *global_ptr = (int*)malloc(sizeof(int));
        global_ptr = (int*)malloc(sizeof(int)); // Adresa prv√©ho bloku sa stratila
        \`\`\`
    *   **Prevencia:**
        *   D√¥sledn√© uvoƒæ≈àovanie pam√§te (\`free\`, \`delete\`).
        *   Pou≈æ√≠vanie techn√≠k ako RAII (Resource Acquisition Is Initialization) v C++.
        *   Inteligentn√© ukazovatele (smart pointers ako \`std::unique_ptr\`, \`std::shared_ptr\` v C++), ktor√© automatizuj√∫ spr√°vu pam√§te.
        *   V jazykoch s automatickou spr√°vou pam√§te (Garbage Collector - GC), ako Java alebo C#, sa GC star√° o uvoƒæ≈àovanie nedosiahnuteƒænej pam√§te, ƒç√≠m predch√°dza v√§ƒç≈°ine √∫nikov pam√§te (aj keƒè nie v≈°etk√Ωm typom √∫nikov zdrojov).`
            },
            {
                question: "3 pr√≠klady APT a k nim APS:",
                answer: `APT (Abstraktn√Ω Pam√§≈•ov√Ω Typ) definuje, ako √∫dajov√° ≈°trukt√∫ra organizuje bloky pam√§te a oper√°cie s nimi. APS (Abstraktn√° Pam√§≈•ov√° ≈†trukt√∫ra) je konkr√©tna realiz√°cia APT.

1.  **APT: Sekvencia (Sequence)**
    *   Popis: Bloky pam√§te s√∫ usporiadan√© line√°rne, ka≈æd√Ω blok (okrem pr√≠padne prv√©ho/posledn√©ho) m√° svojho predchodcu a/alebo nasledovn√≠ka.
    *   **Pr√≠klady APS pre Sekvenciu:**
        *   **Implicitn√° sekvencia (Implicit Sequence):**
            *   Bloky pam√§te s√∫ ulo≈æen√© v s√∫vislom bloku pam√§te (napr. pole).
            *   Vz≈•ahy medzi blokmi (nasledovn√≠k, predchodca) s√∫ vyjadren√© matematicky pomocou indexov (napr. nasledovn√≠k bloku na indexe \`i\` je na indexe \`i+1\`).
            *   Bloky pam√§te nemaj√∫ explicitn√∫ vz≈•ahov√∫ ƒças≈• pre tieto z√°kladn√© sekvenƒçn√© vz≈•ahy.
        *   **Explicitn√° sekvencia v kompaktnej pam√§ti (Explicit Sequence in Compact Memory):**
            *   Bloky pam√§te maj√∫ explicitne ulo≈æen√∫ vz≈•ahov√∫ ƒças≈• (ukazovateƒæ/referenciu na nasledovn√≠ka, pr√≠padne aj predchodcu).
            *   Tieto bloky s√∫ v≈°ak st√°le alokovan√© v jednom s√∫vislom bloku pam√§te (napr. pole ≈°trukt√∫r, kde ka≈æd√° ≈°trukt√∫ra m√° d√°tov√∫ a vz≈•ahov√∫ ƒças≈•).
        *   **Explicitn√° sekvencia v dynamickej pam√§ti (Explicit Sequence in Dynamic Memory - napr. zre≈•azen√Ω zoznam):**
            *   Bloky pam√§te s√∫ alokovan√© jednotlivo v dynamickej pam√§ti (halde).
            *   Ka≈æd√Ω blok obsahuje d√°tov√∫ ƒças≈• a vz≈•ahov√∫ ƒças≈• (ukazovateƒæ na nasledovn√≠ka, pr√≠padne aj predchodcu).

2.  **APT: Hierarchia (Hierarchy)**
    *   Popis: Bloky pam√§te s√∫ usporiadan√© hierarchicky (stromovo), s jedn√Ωm kore≈àov√Ωm blokom. Ka≈æd√Ω blok (okrem kore≈àa) m√° jedn√©ho rodiƒça a m√¥≈æe ma≈• nula alebo viac synov.
    *   **Pr√≠klady APS pre Hierarchiu:**
        *   **Implicitn√° hierarchia (Implicit Hierarchy):**
            *   Typicky pre kompletn√© k-cestn√© stromy, ulo≈æen√© v s√∫vislom bloku pam√§te (napr. pole pre bin√°rnu haldu).
            *   Vz≈•ahy medzi blokmi (rodiƒç, synovia) s√∫ vyjadren√© matematicky pomocou indexov.
        *   **Explicitn√° hierarchia v kompaktnej pam√§ti (Explicit Hierarchy in Compact Memory):**
            *   Bloky pam√§te (vrcholy) maj√∫ explicitne ulo≈æen√© referencie na synov (a pr√≠padne rodiƒça).
            *   Tieto bloky s√∫ alokovan√© v s√∫vislom bloku pam√§te (napr. pole vrcholov, kde ka≈æd√Ω vrchol je ≈°trukt√∫ra s d√°tami a referenciami).
        *   **Explicitn√° hierarchia v dynamickej pam√§ti (Explicit Hierarchy in Dynamic Memory - napr. dynamicky alokovan√Ω strom):**
            *   Ka≈æd√Ω vrchol je samostatne alokovan√Ω v dynamickej pam√§ti.
            *   Vrcholy obsahuj√∫ d√°ta a explicitn√© referencie (ukazovatele) na svojich synov (a pr√≠padne rodiƒça).

3.  **APT: Sie≈• (Network / Graph)**
    *   Popis: Bloky pam√§te (vrcholy) m√¥≈æu by≈• ƒæubovoƒæne prepojen√© s in√Ωmi blokmi (hranami). Vz≈•ahy nie s√∫ nutne line√°rne ani hierarchick√©.
    *   **Pr√≠klady APS pre Sie≈•:**
        *   **Matica susednosti (Adjacency Matrix):**
            *   Reprezentovan√° 2D poƒæom, kde prvok \`M[i][j]\` indikuje existenciu (a pr√≠padne v√°hu) hrany medzi vrcholom \`i\` a vrcholom \`j\`. Vhodn√° pre hust√© grafy.
            *   Pam√§≈•ov√° ≈°trukt√∫ra: implicitn√° sekvencia (pole) pol√≠.
        *   **Zoznamy susednosti (Adjacency Lists):**
            *   Pre ka≈æd√Ω vrchol sa udr≈æiava zoznam (napr. zre≈•azen√Ω zoznam alebo dynamick√© pole) jeho susedov. Vhodn√© pre riedke grafy.
            *   Pam√§≈•ov√° ≈°trukt√∫ra: pole (implicitn√° sekvencia) zre≈•azen√Ωch zoznamov (explicitn√© sekvencie).
        *   **Statick√° sie≈• (Static Network):**
            *   Poƒçet vrcholov a hr√°n je fixn√Ω a zn√°my vopred. M√¥≈æe by≈• implementovan√° pomocou matice susednosti alebo statick√Ωch zoznamov susednosti.
            *   Br√°na (ak je pou≈æit√° na pr√≠stup k vrcholom) m√¥≈æe by≈• implicitn√° sekvencia.
        *   **Dynamick√° sie≈• (Dynamic Network):**
            *   Poƒçet vrcholov a hr√°n sa m√¥≈æe meni≈• poƒças behu. Typicky implementovan√° pomocou zoznamov susednosti s dynamickou alok√°ciou.
            *   Br√°na (ak je pou≈æit√°) je ƒçasto explicitn√° sekvencia (napr. zre≈•azen√Ω zoznam referenci√≠ na vrcholy).`
            },
            {
                question: "Rozdiel medzi dynamick√Ωmi a statick√Ωmi sie≈•ami:",
                answer: `Rozdiel medzi dynamick√Ωmi a statick√Ωmi sie≈•ami (grafmi) sa t√Ωka najm√§ ich schopnosti meni≈• ≈°trukt√∫ru (poƒçet vrcholov a hr√°n) poƒças behu programu a sp√¥sobu ich implement√°cie.

**Statick√° sie≈• (Static Network):**
1.  **≈†trukt√∫ra:**
    *   Poƒçet vrcholov a hr√°n je **fixn√Ω** a zn√°my v ƒçase kompil√°cie alebo inicializ√°cie.
    *   ≈†trukt√∫ra siete sa poƒças behu programu **nemen√≠** (nie je mo≈æn√© prid√°va≈• ani odobera≈• vrcholy ƒçi hrany).
2.  **Implement√°cia:**
    *   ƒåasto implementovan√° pomocou **matice susednosti** (2D pole), kde veƒækos≈• matice je urƒçen√° maxim√°lnym poƒçtom vrcholov.
    *   M√¥≈æe by≈• implementovan√° aj pomocou **zoznamov susednosti**, ak s√∫ tieto zoznamy statickej veƒækosti alebo alokovan√© naraz.
    *   **Implement√°cia br√°ny** (ak sa pou≈æ√≠va na pr√≠stup k vrcholom, napr. zoznam v≈°etk√Ωch vrcholov): Typicky **implicitn√° sekvencia** (napr. pole referenci√≠ na vrcholy), preto≈æe poƒçet vrcholov je fixn√Ω.
3.  **Efektivita modifik√°torov:**
    *   Modifik√°tory (oper√°cie na pridanie/odobratie vrcholu/hrany) **nie s√∫ podporovan√©** alebo s√∫ veƒæmi neefekt√≠vne (vy≈æadovali by vytvorenie novej statickej siete).
4.  **Flexibilita:**
    *   **N√≠zka flexibilita**, keƒè≈æe ≈°trukt√∫ra je pevne dan√°.
5.  **Pam√§≈•ov√° n√°roƒçnos≈•:**
    *   M√¥≈æe by≈• predv√≠dateƒæn√°. Matica susednosti m√° v≈ædy O(V¬≤) pam√§≈•ov√∫ n√°roƒçnos≈• (V je poƒçet vrcholov), aj keƒè je graf riedky.
    *   Pri pou≈æit√≠ statick√Ωch zoznamov susednosti je n√°roƒçnos≈• O(V+E) (E je poƒçet hr√°n).
6.  **Pou≈æitie:** Vhodn√° pre probl√©my, kde je ≈°trukt√∫ra grafu nemenn√° a zn√°ma vopred (napr. mapy ciest, ktor√© sa nemenia, pevn√© komunikaƒçn√© siete).

**Dynamick√° sie≈• (Dynamic Network):**
1.  **≈†trukt√∫ra:**
    *   Poƒçet vrcholov a hr√°n sa **m√¥≈æe meni≈•** poƒças behu programu.
    *   Je mo≈æn√© dynamicky **prid√°va≈• a odobera≈•** vrcholy a hrany.
2.  **Implement√°cia:**
    *   Typicky implementovan√° pomocou **zoznamov susednosti**, kde ka≈æd√Ω zoznam je dynamick√° ≈°trukt√∫ra (napr. zre≈•azen√Ω zoznam, dynamick√© pole/vector).
    *   Menej ƒçasto pomocou matice susednosti, ak sa maxim√°lny poƒçet vrcholov neust√°le men√≠ (vy≈æadovalo by to realok√°ciu matice).
    *   **Implement√°cia br√°ny:** Typicky **explicitn√° sekvencia** (napr. zre≈•azen√Ω zoznam alebo dynamick√© pole referenci√≠ na vrcholy), preto≈æe poƒçet vrcholov sa men√≠.
3.  **Efektivita modifik√°torov:**
    *   **Efekt√≠vne modifik√°tory** pre prid√°vanie a odoberanie vrcholov a hr√°n (v z√°vislosti od konkr√©tnej implement√°cie zoznamov susednosti).
4.  **Flexibilita:**
    *   **Vysok√° flexibilita**, umo≈æ≈àuje adaptova≈• sa na meniace sa podmienky.
5.  **Pam√§≈•ov√° n√°roƒçnos≈•:**
    *   Pam√§≈•ov√° n√°roƒçnos≈• je typicky O(V+E), ƒço je efekt√≠vne pre riedke grafy.
    *   M√¥≈æe by≈• menej predv√≠dateƒæn√°, keƒè≈æe z√°vis√≠ od aktu√°lneho poƒçtu vrcholov a hr√°n. Potreba dynamickej alok√°cie m√¥≈æe prinies≈• urƒçit√∫ r√©≈æiu.
6.  **Pou≈æitie:** Vhodn√° pre probl√©my, kde sa ≈°trukt√∫ra grafu vyv√≠ja v ƒçase (napr. soci√°lne siete, modelovanie dynamick√Ωch syst√©mov, smerovacie protokoly).

**Zhrnutie kƒæ√∫ƒçov√Ωch rozdielov:**
*   **Zmena ≈°trukt√∫ry:** Statick√° - nemenn√°, Dynamick√° - meniteƒæn√°.
*   **Modifik√°tory:** Statick√° - neefekt√≠vne/nepodporovan√©, Dynamick√° - efekt√≠vne.
*   **Implement√°cia br√°ny:** Statick√° - ƒçasto implicitn√° sekvencia, Dynamick√° - ƒçasto explicitn√° sekvencia.
*   **Flexibilita:** Statick√° - n√≠zka, Dynamick√° - vysok√°.`
            },
            {
                question: "ƒåo je to kvadratick√° zlo≈æitos≈• a 3 pr√≠klady:",
                answer: `**Kvadratick√° zlo≈æitos≈• (Quadratic Complexity):**
Kvadratick√° zlo≈æitos≈• je trieda ƒçasovej alebo pam√§≈•ovej zlo≈æitosti algoritmu, kde poƒçet oper√°ci√≠ (alebo potrebn√° pam√§≈•) rastie √∫merne **druhej mocnine veƒækosti vstupu**. V asymptotickej not√°cii sa oznaƒçuje ako **O(n¬≤)**, kde 'n' je veƒækos≈• vstupu.

To znamen√°, ≈æe ak sa veƒækos≈• vstupu zdvojn√°sob√≠, ƒças potrebn√Ω na vykonanie algoritmu sa pribli≈æne zo≈°tvorn√°sob√≠ (2¬≤ = 4). Ak sa vstup zdesa≈•n√°sob√≠, ƒças sa pribli≈æne zoston√°sob√≠ (10¬≤ = 100). Algoritmy s kvadratickou zlo≈æitos≈•ou sa st√°vaj√∫ neprakticky pomal√Ωmi pre veƒæk√© vstupy.

**Pr√≠klady algoritmov alebo oper√°ci√≠ s kvadratickou zlo≈æitos≈•ou O(n¬≤):**

1.  **Jednoduch√© triediace algoritmy (v najhor≈°om alebo priemernom pr√≠pade):**
    *   **Bubble Sort:** V ka≈ædom prechode porovn√°va susedn√© prvky a vymie≈àa ich, ak nie s√∫ v spr√°vnom porad√≠. Vy≈æaduje n prechodov a v ka≈ædom prechode a≈æ n-1 porovnan√≠.
    *   **Selection Sort:** V ka≈ædom prechode n√°jde minim√°lny (alebo maxim√°lny) prvok zo zost√°vaj√∫cej netriedenej ƒçasti a umiestni ho na spr√°vnu poz√≠ciu. Vy≈æaduje n prechodov a v ka≈ædom prechode hƒæadanie minima v zmen≈°uj√∫cej sa ƒçasti poƒæa.
    *   **Insertion Sort:** V najhor≈°om pr√≠pade (napr. pole utrieden√© opaƒçne) ka≈æd√Ω prvok mus√≠ by≈• posunut√Ω cez u≈æ utrieden√∫ ƒças≈• poƒæa.
    *   *D√¥vod:* Tieto algoritmy ƒçasto zah≈ï≈àaj√∫ vnoren√© cykly, kde vonkaj≈°√≠ cyklus prech√°dza n-kr√°t a vn√∫torn√Ω cyklus tie≈æ prech√°dza pribli≈æne n-kr√°t pre ka≈æd√Ω prechod vonkaj≈°ieho cyklu.

2.  **Prech√°dzanie v≈°etk√Ωch p√°rov prvkov v kolekcii:**
    *   √öloha: N√°js≈• v≈°etky mo≈æn√© dvojice prvkov v poli alebo zozname veƒækosti n.
    *   Pr√≠klad: Overenie, ƒçi v poli existuj√∫ duplicitn√© prvky, porovnan√≠m ka≈æd√©ho prvku s ka≈æd√Ωm in√Ωm prvkom.
        \`\`\`python
        # Pr√≠klad k√≥du (Python)
        def find_duplicates_quadratic(arr):
            n = len(arr)
            for i in range(n):
                for j in range(i + 1, n): # Vn√∫torn√Ω cyklus
                    if arr[i] == arr[j]:
                        return True # Na≈°iel sa duplik√°t
            return False
        \`\`\`
    *   *D√¥vod:* Dva vnoren√© cykly, kde vonkaj≈°√≠ iteruje \`n\` kr√°t a vn√∫torn√Ω v priemere \`n/2\` kr√°t, ƒço vedie k O(n¬≤) oper√°ci√°m.

3.  **Niektor√© oper√°cie s maticami (ak n reprezentuje rozmer matice n x n):**
    *   **Sƒç√≠tanie alebo odƒç√≠tanie dvoch mat√≠c n x n:** Ka≈æd√Ω z n¬≤ prvkov jednej matice sa sƒç√≠ta/odƒç√≠ta s kore≈°ponduj√∫cim prvkom druhej matice. Oper√°cia pre ka≈æd√Ω prvok je O(1), celkovo O(n¬≤).
    *   **Priama implement√°cia n√°sobenia dvoch mat√≠c n x n** m√° zlo≈æitos≈• O(n¬≥). Av≈°ak, ak by sme mali oper√°ciu, ktor√° vy≈æaduje pr√≠stup ku ka≈æd√©mu prvku jednej matice n x n a pre ka≈æd√Ω z nich vykonala O(1) oper√°ciu, bola by to O(n¬≤).
    *   **Vytvorenie matice susednosti pre graf s V vrcholmi:** Ak inicializujeme maticu V x V, je to O(V¬≤).
    *   V dokumente sa spom√≠na: "Porovnanie v sie≈•ach: Dokument uv√°dza, ≈æe oper√°cia 'Porovnaj' v sie≈•ach m√° zlo≈æitos≈• O(v¬≤)." Toto by mohlo znamena≈• napr√≠klad porovnanie v≈°etk√Ωch vrcholov navz√°jom alebo podobn√∫ oper√°ciu vy≈æaduj√∫cu pr√°cu so v≈°etk√Ωmi p√°rmi vrcholov v sieti s 'v' vrcholmi.

**Pozn√°mka:** V√°≈° text uv√°dzal "algoritmus pre n√°sobenie dvoch n√ón mat√≠c m√° zlo≈æitos≈• O(n¬≥)", ƒço je pravda pre ≈°tandardn√Ω algoritmus. Sƒç√≠tanie/odƒç√≠tanie mat√≠c je v≈°ak O(n¬≤).`
            },
            {
                question: "Rozdiel medzi ukazovateƒæom a odkazom:",
                answer: `Rozdiel medzi ukazovateƒæom (pointer) a odkazom (reference) je d√¥le≈æit√Ω najm√§ v jazykoch ako C++. Oba sl√∫≈æia na nepriamy pr√≠stup k d√°tam, ale maj√∫ odli≈°n√© vlastnosti a pou≈æitie.

**Ukazovateƒæ (Pointer):**
1.  **Defin√≠cia:** ≈†pecifick√Ω √∫dajov√Ω typ (premenn√°), ktor√Ω je schopn√Ω uchov√°va≈• **adresu** in√©ho objektu (premennej) v pam√§ti.
2.  **Inicializ√°cia:** M√¥≈æe by≈• neinicializovan√Ω, m√¥≈æe by≈• inicializovan√Ω na NULL (neukazuje na ≈æiadny platn√Ω objekt), alebo m√¥≈æe by≈• inicializovan√Ω adresou existuj√∫ceho objektu.
3.  **Zmena cieƒæa:** Ukazovateƒæ **m√¥≈æe meni≈• adresu**, na ktor√∫ ukazuje poƒças svojej ≈æivotnosti. M√¥≈æe by≈• presmerovan√Ω na in√Ω objekt rovnak√©ho (alebo kompatibiln√©ho) typu.
    \`\`\`cpp
    int x = 10;
    int y = 20;
    int* ptr = &x; // ptr ukazuje na x
    ptr = &y;     // ptr teraz ukazuje na y
    ptr = nullptr; // ptr teraz neukazuje nikam
    \`\`\`
4.  **Aritmetika ukazovateƒæov:** Podporuje ≈°peci√°lne aritmetick√© oper√°cie (napr. pripoƒç√≠tanie cel√©ho ƒç√≠sla k ukazovateƒæu posunie adresu o n√°sobok veƒækosti typu, na ktor√Ω ukazuje). Toto je u≈æitoƒçn√© pri pr√°ci s poliami.
5.  **Dereferencovanie:** Pre pr√≠stup k hodnote objektu, na ktor√Ω ukazovateƒæ ukazuje, sa pou≈æ√≠va oper√°tor dereferencovania (napr. \`*\` v C/C++).
    \`\`\`cpp
    *ptr = 30; // Modifikuje hodnotu objektu, na ktor√Ω ptr ukazuje
    \`\`\`
6.  **Pou≈æitie:** ƒåasto sa vyu≈æ√≠va na uchov√°vanie adries dynamicky alokovan√Ωch premenn√Ωch (z haldy), na implement√°ciu d√°tov√Ωch ≈°trukt√∫r ako zre≈•azen√© zoznamy a stromy, a na odovzd√°vanie argumentov funkci√°m "referenciou" (v C, alebo ako alternat√≠va k referenci√°m v C++).

**Odkaz (Reference) - prim√°rne v C++:**
1.  **Defin√≠cia:** Alternat√≠vny **n√°zov (alias)** pre u≈æ existuj√∫ci objekt v pam√§ti. Odkaz nie je samostatn√Ω objekt v tom zmysle, ≈æe by mal vlastn√∫ pam√§≈•ov√∫ adresu (ako ukazovateƒæ); je to sk√¥r in√© meno pre t√∫ ist√∫ pam√§≈•ov√∫ lok√°ciu.
2.  **Inicializ√°cia:** Odkaz **mus√≠ by≈• inicializovan√Ω pri svojom vzniku** a mus√≠ odkazova≈• na platn√Ω existuj√∫ci objekt. Nem√¥≈æe by≈• NULL a nem√¥≈æe by≈• neinicializovan√Ω.
    \`\`\`cpp
    int x = 10;
    int& ref = x; // ref je teraz alias pre x
    // int& bad_ref; // Chyba: odkaz mus√≠ by≈• inicializovan√Ω
    \`\`\`
3.  **Zmena cieƒæa:** Od svojho vzniku a≈æ do svojho z√°niku **mus√≠ odkazova≈• v≈ædy len na ten ist√Ω objekt** (pam√§≈•ov√© miesto), na ktor√Ω bol pri svojom vzniku nastaven√Ω. Nie je mo≈æn√© "presmerova≈•" odkaz na in√Ω objekt.
    \`\`\`cpp
    int y = 20;
    // ref = y; // Toto NEZMEN√ç ref, aby ukazoval na y.
              // Namiesto toho to prirad√≠ hodnotu y do x (preto≈æe ref je alias pre x).
              // Tak≈æe x sa stane 20.
    \`\`\`
4.  **Aritmetika odkazov:** Aritmetika odkazov nie je priamo podporovan√°.
5.  **Dereferencovanie:** Pou≈æ√≠va sa **implicitne**. Keƒè pou≈æijete n√°zov odkazu, automaticky pristupujete k objektu, na ktor√Ω odkazuje. Nie je potrebn√Ω ≈°peci√°lny oper√°tor dereferencovania.
    \`\`\`cpp
    ref = 30; // Modifikuje hodnotu x (preto≈æe ref je alias pre x)
    \`\`\`
6.  **Pou≈æitie:** ƒåasto sa pou≈æ√≠va na odovzd√°vanie argumentov funkci√°m (pass-by-reference) pre efekt√≠vnos≈• a mo≈ænos≈• modifik√°cie p√¥vodn√©ho argumentu, a na vracanie hodn√¥t z funkci√≠ referenciou. Syntax je ƒçasto ƒçistej≈°ia ako pri ukazovateƒæoch.

**Kƒæ√∫ƒçov√© rozdiely zhrnut√©:**
*   **Inicializ√°cia:** Ukazovateƒæ m√¥≈æe by≈• neinicializovan√Ω alebo NULL. Odkaz mus√≠ by≈• inicializovan√Ω na existuj√∫ci objekt.
*   **Zmena cieƒæa (Re-seating):** Ukazovateƒæ m√¥≈æe zmeni≈•, na ƒço ukazuje. Odkaz nem√¥≈æe; v≈ædy odkazuje na ten ist√Ω objekt.
*   **NULL hodnota:** Ukazovateƒæ m√¥≈æe by≈• NULL. Odkaz nem√¥≈æe by≈• NULL (mus√≠ odkazova≈• na platn√Ω objekt).
*   **Syntax pr√≠stupu:** Ukazovateƒæ vy≈æaduje dereferencovanie (\`*\` alebo \`->\`). Odkaz sa pou≈æ√≠va priamo ako n√°zov p√¥vodn√©ho objektu.
*   **Aritmetika:** Ukazovatele podporuj√∫ aritmetiku. Odkazy nie.
*   **Existencia:** Ukazovateƒæ je premenn√°, ktor√° zaber√° vlastn√∫ pam√§≈• na ulo≈æenie adresy. Odkaz je sk√¥r alias a nemus√≠ nutne zabera≈• ƒèal≈°iu pam√§≈• (aj keƒè kompil√°tor to m√¥≈æe implementova≈• interne pomocou adresy).`
            },
            {
                question: "Op√≠sa≈• pam√§≈•ov√Ω blok explicitnej jednostranne zre≈•azenej sekvencie:",
                answer: `Pam√§≈•ov√Ω blok (ƒçasto naz√Ωvan√Ω uzol alebo prvok) v explicitnej jednostranne zre≈•azenej sekvencii (singly linked list) je z√°kladnou stavebnou jednotkou tejto d√°tovej ≈°trukt√∫ry. Ka≈æd√Ω tak√Ωto blok sa sklad√° z dvoch hlavn√Ωch ƒçast√≠:

1.  **√ödajov√° ƒças≈• (Data Part):**
    *   Obsahuje samotn√© **u≈æitoƒçn√© d√°ta**, ktor√© chceme v sekvencii uchov√°va≈•.
    *   Typ t√Ωchto d√°t m√¥≈æe by≈• ƒæubovoƒæn√Ω: primit√≠vny typ (cel√© ƒç√≠slo, znak, atƒè.), ≈°trukt√∫ra, objekt alebo dokonca ukazovateƒæ na in√© komplexnej≈°ie d√°ta.
    *   Napr√≠klad, ak sekvencia uchov√°va cel√© ƒç√≠sla, √∫dajov√° ƒças≈• bude obsahova≈• jedno cel√© ƒç√≠slo.

2.  **Vz≈•ahov√° ƒças≈• (Link/Pointer Part):**
    *   Obsahuje **referenciu (ukazovateƒæ) na nasleduj√∫ci blok (uzol) v sekvencii.**
    *   T√°to referencia "sp√°ja" alebo "re≈•az√≠" aktu√°lny blok s nasleduj√∫cim, ƒç√≠m vytv√°ra line√°rnu postupnos≈• blokov.
    *   Naz√Ωva sa tie≈æ "smern√≠k na nasledovn√≠ka" alebo "next pointer".

**Charakteristiky pam√§≈•ov√©ho bloku a sekvencie:**

*   **≈†trukt√∫ra bloku:**
    Typicky sa implementuje ako ≈°trukt√∫ra (struct v C/C++) alebo trieda (class), napr√≠klad:
    \`\`\`cpp
    // Pr√≠klad v C++
    struct Node {
        DataType data; // √ödajov√° ƒças≈•
        Node* next;    // Vz≈•ahov√° ƒças≈• - ukazovateƒæ na nasleduj√∫ci uzol
    };
    \`\`\`
    (DataType by bol konkr√©tny typ ukladan√Ωch d√°t)

*   **Referencia na nasledovn√≠ka:**
    *   Ka≈æd√Ω blok (okrem posledn√©ho) obsahuje platn√∫ referenciu (nenulov√Ω ukazovateƒæ) na nasleduj√∫ci blok v sekvencii.
    *   Toto umo≈æ≈àuje jednosmern√Ω prechod sekvenciou ‚Äì od aktu√°lneho bloku k jeho nasledovn√≠kovi.

*   **Posledn√Ω blok (Tail):**
    *   Posledn√Ω blok v sekvencii m√° svoju referenciu na nasledovn√≠ka nastaven√∫ na ≈°peci√°lnu hodnotu, ktor√° indikuje koniec sekvencie.
    *   Typicky je to **NULL** (v C/C++) alebo \`nullptr\` (v modernom C++).
    *   Toto umo≈æ≈àuje algoritmom rozpozna≈•, kedy dosiahli koniec sekvencie.

*   **Zaƒçiatok sekvencie (Head):**
    *   Cel√° sekvencia je zvyƒçajne pr√≠stupn√° cez samostatn√∫ referenciu (ukazovateƒæ), ktor√° ukazuje na **prv√Ω blok (uzol) sekvencie**. Tento ukazovateƒæ sa ƒçasto naz√Ωva "hlava" (head).
    *   Ak je sekvencia pr√°zdna, ukazovateƒæ "head" je nastaven√Ω na NULL.

**Vizu√°lna predstava bloku:**
\`\`\`
  +------+------+
  | Data | Next | ----> (ukazuje na ƒèal≈°√≠ blok alebo NULL)
  +------+------+
\`\`\`

**Alok√°cia:**
Bloky explicitnej jednostranne zre≈•azenej sekvencie s√∫ typicky alokovan√© dynamicky v pam√§ti (na halde), podƒæa potreby pri vkladan√≠ nov√Ωch prvkov. Pri odstra≈àovan√≠ prvkov sa ich pam√§≈• dealokuje.`
            },
            {
                question: "Nap√≠sa≈• 3 tabuƒæky s kon≈°tantnou zlo≈æitos≈•ou a v jednej op√≠sa≈• oper√°ciu vlo≈æ:",
                answer: `Tri typy tabuliek (ha≈°ovac√≠ch tabuliek), ktor√© sa sna≈æia dosiahnu≈• kon≈°tantn√∫ priemern√∫ ƒçasov√∫ zlo≈æitos≈• O(1) pre oper√°cie ako vlo≈æ, n√°jdi, zru≈°:

1.  **Tabuƒæka s rozpt√Ωlen√Ωmi z√°znamami (Hashing Table) - rie≈°enie kol√≠zi√≠ zre≈•azovan√≠m (Chaining):**
    *   Priemern√° zlo≈æitos≈• oper√°ci√≠: O(1 + Œ±), kde Œ± je faktor zaplnenia (load factor = n/m; n=poƒçet prvkov, m=veƒækos≈• tabuƒæky). Ak Œ± je mal√© kon≈°tantn√© ƒç√≠slo, potom je to O(1).
    *   Najhor≈°√≠ pr√≠pad: O(n), ak v≈°etky kƒæ√∫ƒçe he≈°uj√∫ na rovnak√Ω index a tvoria dlh√Ω zre≈•azen√Ω zoznam.

2.  **Tabuƒæka s rozpt√Ωlen√Ωmi z√°znamami - rie≈°enie kol√≠zi√≠ otvorenou adres√°ciou (Open Addressing):**
    *   Typy: line√°rne sondovanie, kvadratick√© sondovanie, dvojit√© he≈°ovanie.
    *   Priemern√° zlo≈æitos≈•: Z√°vis√≠ od faktora zaplnenia a typu sondovania, ale pri n√≠zkom faktore zaplnenia sa bl√≠≈æi O(1).
    *   Najhor≈°√≠ pr√≠pad: O(n), ak doch√°dza k rozsiahlemu zhlukovaniu (clustering).

3.  **Tabuƒæka s rozpt√Ωlen√Ωmi z√°znamami - bez explicitn√©ho rie≈°enia kol√≠zi√≠ (teoretick√Ω model alebo s predpokladom perfektnej he≈°ovacej funkcie):**
    *   Ak by sme mali perfektn√∫ he≈°ovaciu funkciu (ka≈æd√Ω kƒæ√∫ƒç mapuje na unik√°tny index) a dostatoƒçne veƒæk√∫ tabuƒæku, oper√°cie by boli O(1) aj v najhor≈°om pr√≠pade. V praxi je to ≈•a≈æko dosiahnuteƒæn√© pre dynamick√© d√°ta.
    *   V√°≈° text spom√≠na "Tabuƒæka s rozpt√Ωlen√Ωmi z√°znamami (bez rie≈°enia kol√≠zi√≠): O(1)". Toto plat√≠ za predpokladu, ≈æe kol√≠zie nenastan√∫, alebo ≈æe prepisovanie existuj√∫ceho prvku s rovnak√Ωm he≈°om je akceptovateƒæn√© (ƒço nie je typick√© pre v≈°eobecn√∫ tabuƒæku). Alebo ak je to len z√°kladn√Ω model, kde sa na poz√≠ciu jednoducho zap√≠≈°e.

**Opis oper√°cie VLO≈Ω pre Tabuƒæku s rozpt√Ωlen√Ωmi z√°znamami (rie≈°enie kol√≠zi√≠ zre≈•azovan√≠m):**

Predpoklad: M√°me pole (implicitn√∫ sekvenciu) M o veƒækosti \`m\`. Ka≈æd√Ω prvok poƒæa M je ukazovateƒæ na zaƒçiatok zre≈•azen√©ho zoznamu (alebo je NULL, ak je slot pr√°zdny).

**Oper√°cia VLO≈Ω (kƒæ√∫ƒç K, √∫daje D):**

1.  **V√Ωpoƒçet he≈°ovacej hodnoty:**
    *   Aplikuje sa he≈°ovacia funkcia H na kƒæ√∫ƒç K: \`h_val = H(K)\`.

2.  **V√Ωpoƒçet indexu do tabuƒæky:**
    *   Index do poƒæa M sa vypoƒç√≠ta z he≈°ovacej hodnoty, typicky pomocou modulo oper√°cie: \`index = h_val mod m\`. Toto zabezpeƒç√≠, ≈æe index bude v platnom rozsahu [0, m-1].

3.  **Pr√≠stup k zre≈•azen√©mu zoznamu:**
    *   Z√≠ska sa ukazovateƒæ na zaƒçiatok zre≈•azen√©ho zoznamu na vypoƒç√≠tanom \`indexe\` v poli M: \`list_head = M[index]\`.

4.  **(Voliteƒæn√©) Kontrola existencie kƒæ√∫ƒça:**
    *   Prejde sa zre≈•azen√Ω zoznam zaƒç√≠naj√∫ci na \`list_head\`. Pre ka≈æd√Ω prvok v zozname sa porovn√° jeho kƒæ√∫ƒç s vkladan√Ωm kƒæ√∫ƒçom K.
    *   Ak sa n√°jde prvok s rovnak√Ωm kƒæ√∫ƒçom K:
        *   Buƒè sa aktualizuj√∫ jeho √∫daje D (ak je to povolen√© a ≈æiaduce).
        *   Alebo sa oper√°cia vlo≈æenia m√¥≈æe zamietnu≈• (ak kƒæ√∫ƒçe musia by≈• unik√°tne a aktualiz√°cia nie je povolen√°).
        *   Oper√°cia vlo≈æenia konƒç√≠.

5.  **Vytvorenie nov√©ho prvku:**
    *   Ak kƒæ√∫ƒç K nebol n√°jden√Ω v zre≈•azenom zozname (alebo ak je povolen√© vklada≈• duplicitn√© kƒæ√∫ƒçe, ƒço nie je typick√© pre he≈°ovacie tabuƒæky), vytvor√≠ sa nov√Ω uzol/prvok obsahuj√∫ci kƒæ√∫ƒç K a √∫daje D.

6.  **Vlo≈æenie nov√©ho prvku do zre≈•azen√©ho zoznamu:**
    *   Nov√Ω prvok sa vlo≈æ√≠ do zre≈•azen√©ho zoznamu na \`indexe\`. Najƒçastej≈°ie sa vklad√° na zaƒçiatok zoznamu pre jednoduchos≈• a efektivitu O(1) pre samotn√© vlo≈æenie do zoznamu:
        *   \`novy_prvok->next = M[index]\`
        *   \`M[index] = novy_prvok\`

7.  **(Voliteƒæn√©) Aktualiz√°cia poƒçtu prvkov a faktora zaplnenia:**
    *   Zv√Ω≈°i sa celkov√Ω poƒçet prvkov v tabuƒæke.
    *   Ak faktor zaplnenia Œ± prekroƒç√≠ urƒçit√∫ hranicu, m√¥≈æe sa vykona≈• oper√°cia zv√§ƒç≈°enia tabuƒæky (rehash), aby sa zachovala dobr√° priemern√° zlo≈æitos≈•. Toto je drah≈°ia oper√°cia, ale amortizovane st√°le umo≈æ≈àuje O(1) pre vlo≈æenie.

**Zlo≈æitos≈• oper√°cie VLO≈Ω (zre≈•azovanie):**
*   V√Ωpoƒçet he≈°u a indexu: O(dƒ∫≈æka kƒæ√∫ƒça) zvyƒçajne, ale ƒçasto pova≈æovan√© za O(1) ak dƒ∫≈æka kƒæ√∫ƒça je obmedzen√°.
*   Vlo≈æenie na zaƒçiatok zoznamu: O(1).
*   Prech√°dzanie zoznamu (kontrola duplik√°tov): V priemere O(Œ±). Ak sa kontrola duplik√°tov nerob√≠ (alebo sa vklad√° v≈ædy na zaƒçiatok), t√°to ƒças≈• je O(1).
*   Celkovo: Priemerne O(1+Œ±). Ak sa nerob√≠ kontrola duplik√°tov, tak O(1) pre samotn√© vlo≈æenie + cena rehashingu amortizovane. `
            },
            {
                question: "Rozdiel medzi usporiadan√Ωmi a neusporiadan√Ωmi K-cestn√Ωmi hierarchiami:",
                answer: `Rozdiel medzi usporiadan√Ωmi a neusporiadan√Ωmi K-cestn√Ωmi hierarchiami (stromami) spoƒç√≠va v tom, ƒçi existuje definovan√© poradie medzi synmi dan√©ho vrcholu.

**Usporiadan√© K-cestn√© hierarchie (Ordered K-way Trees):**

1.  **Poradie synov:** Synovia ka≈æd√©ho vrcholu tvoria **line√°rne usporiadan√∫ mno≈æinu**. To znamen√°, ≈æe existuje jasne definovan√Ω "prv√Ω syn", "druh√Ω syn", ..., a≈æ "k-ty syn" (ak existuj√∫).
2.  **Pomenovanie synov:** Vƒèaka usporiadaniu je mo≈æn√© synov pomenova≈• alebo na nich odkazova≈• na z√°klade ich poz√≠cie (napr. najƒæavej≈°√≠ syn, prav√Ω brat, atƒè.). Pre bin√°rne stromy (K=2) s√∫ to typicky "ƒæav√Ω syn" a "prav√Ω syn".
3.  **Oper√°cie:** Oper√°cie pracuj√∫ce so synmi vrcholu typicky presne ≈°pecifikuj√∫, ktor√©ho syna sa oper√°cia t√Ωka na z√°klade jeho poradia alebo roly (napr. "vlo≈æ ako ƒæav√©ho syna").
4.  **Implement√°cia:**
    *   M√¥≈æu by≈• implementovan√© ako **implicitn√© hierarchie** v kompaktnej pam√§ti (napr. bin√°rna halda), ak s√∫ navy≈°e kompletn√©. Vz≈•ahy sa vypoƒç√≠tavaj√∫ z indexov.
    *   M√¥≈æu by≈• implementovan√© ako **explicitn√© hierarchie**, kde ka≈æd√Ω vrchol m√° K (alebo menej) explicitn√Ωch referenci√≠ na svojich synov, priƒçom ka≈æd√° referencia zodpoved√° urƒçitej poz√≠cii (napr. pole ukazovateƒæov na synov veƒækosti K).
5.  **Pr√≠klady:** Bin√°rne vyhƒæad√°vacie stromy (kde ƒæav√Ω syn je men≈°√≠ a prav√Ω v√§ƒç≈°√≠), v≈°eobecn√© usporiadan√© stromy pou≈æ√≠van√© na reprezent√°ciu XML dokumentov (kde poradie elementov m√° v√Ωznam).

**Neusporiadan√© K-cestn√© hierarchie (Unordered K-way Trees):**

1.  **Poradie synov:** Synovia ka≈æd√©ho vrcholu tvoria **mno≈æinu bez definovan√©ho poradia**. Z√°le≈æ√≠ len na tom, ktor√≠ synovia existuj√∫, nie na ich vz√°jomnom porad√≠.
2.  **Pomenovanie synov:** Nie je mo≈æn√© jednoznaƒçne urƒçi≈• "prv√©ho" alebo "druh√©ho" syna len na z√°klade ≈°trukt√∫ry. Ak√Ωkoƒævek prechod synmi vr√°ti mno≈æinu synov v ƒæubovoƒænom porad√≠.
3.  **Oper√°cie:** Oper√°cie pracuj√∫ce so synmi sa typicky t√Ωkaj√∫ v≈°etk√Ωch synov ako skupiny, alebo vyhƒæad√°vaj√∫ konkr√©tneho syna na z√°klade jeho hodnoty, nie poz√≠cie.
4.  **Implement√°cia:**
    *   Typicky sa implementuj√∫ ako **explicitn√© hierarchie**.
    *   Ka≈æd√Ω vrchol m√¥≈æe obsahova≈• referenciu na **d√°tov√∫ ≈°trukt√∫ru (napr. zre≈•azen√Ω zoznam, he≈°ovaciu tabuƒæku, alebo dynamick√© pole) uchov√°vaj√∫cu referencie na jeho synov.** Poradie v tejto pomocnej ≈°trukt√∫re nemus√≠ ma≈• s√©mantick√Ω v√Ωznam pre hierarchiu ako tak√∫.
    *   Implicitn√° implement√°cia nie je priamoƒçiar√°, preto≈æe ch√Ωba pevn√© mapovanie poz√≠cie na konkr√©tneho syna.
5.  **Pr√≠klady:** Reprezent√°cia mno≈æinov√Ωch vz≈•ahov, niektor√© typy stromov v te√≥rii grafov, kde z√°le≈æ√≠ len na vz≈•ahu rodiƒç-syn, nie na porad√≠ synov (napr. strom komponentov grafu).

**Hlavn√© rozdiely zhrnut√©:**

| Vlastnos≈•         | Usporiadan√° K-cestn√° hierarchia             | Neusporiadan√° K-cestn√° hierarchia          |
|-------------------|---------------------------------------------|-------------------------------------------|
| **Poradie synov** | √Åno, synovia s√∫ line√°rne usporiadan√≠.       | Nie, synovia tvoria neusporiadan√∫ mno≈æinu. |
| **Pr√≠stup k synom**| Podƒæa poz√≠cie/indexu (napr. 1., 2. syn).   | Podƒæa hodnoty alebo ako cel√° mno≈æina.       |
| **Implement√°cia (typick√°)** | Implicitn√° (ak kompletn√°) alebo explicitn√° s K referenciami. | Explicitn√° s kolekciou referenci√≠ na synov. |
| **S√©mantika**     | Poradie synov m√° v√Ωznam.                    | Poradie synov nem√° v√Ωznam.                 |

Pre K=2 (bin√°rne stromy) je v√§ƒç≈°ina be≈æne pou≈æ√≠van√Ωch bin√°rnych stromov (BVS, haldy) usporiadan√°, preto≈æe rozli≈°ujeme medzi ƒæav√Ωm a prav√Ωm synom.`
            },
            // {
            // Q: ƒΩavostranna halda, op√≠sa≈•, nap√≠sa≈• APS, oper√°cie v≈°etky 3 pop√≠sa≈• a zlo≈æitosti k nim aj vysvetli≈• ich:
            // A: (T√°to ot√°zka je duplicitn√° s jednou vy≈°≈°ie, pou≈æije sa tamt√° odpoveƒè)
            // },
            {
                question: "Zoraƒète 4 PF od najlep≈°ej po najhor≈°iu (oper√°cia VYBER prvok s najvy≈°≈°ou prioritou):",
                answer: `Zoradenie 4 implement√°ci√≠ prioritn√©ho frontu (PF) podƒæa ƒçasovej zlo≈æitosti oper√°cie **VYBER prvok s najvy≈°≈°ou prioritou** (od najlep≈°ej po najhor≈°iu):

1.  **Utrieden√Ω sekvenƒçn√Ω prioritn√Ω front (Sorted Sequential Priority Queue):**
    *   Implement√°cia: Pole alebo zre≈•azen√Ω zoznam, kde prvky s√∫ neust√°le udr≈æiavan√© utrieden√© podƒæa priority.
    *   Zlo≈æitos≈• oper√°cie VYBER: **O(1)**
    *   Vysvetlenie: Prvok s najvy≈°≈°ou prioritou je v≈ædy na zn√°mom konci sekvencie (napr. na zaƒçiatku alebo na konci, v z√°vislosti od sp√¥sobu triedenia). Jeho odstr√°nenie je teda veƒæmi r√Ωchle.
    *   (Nev√Ωhoda: Vlo≈æenie je O(n)).

2.  **ƒΩavostrann√° halda (Binary Heap):**
    *   Implement√°cia: Typicky implicitn√° bin√°rna hierarchia (pole).
    *   Zlo≈æitos≈• oper√°cie VYBER: **O(log n)**
    *   Vysvetlenie: Prvok s najvy≈°≈°ou prioritou je v koreni. Po jeho odstr√°nen√≠ sa na jeho miesto presunie posledn√Ω prvok a vykon√° sa oper√°cia "sift-down" (heapify-down) na obnovenie vlastnosti haldy, ƒço trv√° O(log n).

3.  **Dvojzoznam (AUMS Dvojzoznam):**
    *   Implement√°cia: Kombin√°cia kr√°tkej (implicitnej) a dlhej (explicitnej) sekvencie.
    *   Zlo≈æitos≈• oper√°cie VYBER: **O(k + log m) alebo O(k) ak je kr√°tka sekvencia trieden√°, O(m) ak je dlh√° sekvencia prehƒæad√°van√°, kde k je veƒækos≈• kr√°tkej a m dlhej. Ak je to prepracovanej≈°ie, tak O(k) na n√°jdenie v kr√°tkej, O(1) na vybratie z dlhej ak je tam, alebo O(m) na n√°jdenie v dlhej.**
    *   V√°≈° text ne≈°pecifikuje presn√∫ zlo≈æitos≈• vyber pre Dvojzoznam. Typicky sa prvok s najvy≈°≈°ou prioritou hƒæad√° v kr√°tkej sekvencii (O(k), kde k je jej dƒ∫≈æka) a ak je kr√°tka sekvencia pr√°zdna, tak na zaƒçiatku dlhej sekvencie (ak je dlh√° sekvencia utrieden√°, inak O(m)). Ak je kr√°tka sekvencia mal√° (napr. kon≈°tantn√° veƒækos≈•), tak je to efekt√≠vne. Ak m√° kr√°tka sekvencia napr. logaritmick√∫ veƒækos≈• a je trieden√°, tak to m√¥≈æe by≈• O(log n). Bez presnej≈°ej ≈°pecifik√°cie je ≈•a≈æk√© zaradi≈•. Pre jednoduchos≈• predpokladajme, ≈æe sa mus√≠ prejs≈• kr√°tka sekvencia: **O(k)**, kde k je veƒækos≈• kr√°tkej sekvencie. Ak k je mal√©, je to dobr√©. Ak k m√¥≈æe r√°s≈•, je to hor≈°ie.
    *   Ak by sme brali do √∫vahy, ≈æe dvojzoznam m√° za cieƒæ amortizovane O(1) vlo≈æenie, vyber m√¥≈æe by≈• menej optim√°lny. Ak prioritu m√° prvok v kr√°tkej ƒçasti (O(k)), ak v dlhej (O(1) ak je na zaƒçiatku, inak O(m)). ƒåasto sa kr√°tka udr≈æiava utrieden√°, potom je to O(1) z kr√°tkej alebo dlhej.
    *   Pre tento zoznam, ak predpoklad√°me, ≈æe dvojzoznam je optimalizovan√Ω sk√¥r na vkladanie, a vyber vy≈æaduje prehƒæadanie kr√°tkej ƒçasti: O(k), kde k je veƒækos≈• kr√°tkej ƒçasti. Ak k ~ log n, potom O(log n). Ak k m√¥≈æe by≈• a≈æ O(n), potom O(n). Ak je k fixn√© a mal√©, tak O(1). Zarad√≠m ho ako porovnateƒæn√Ω s haldou alebo hor≈°√≠, z√°le≈æ√≠ od k.
    *   *P√¥vodn√Ω text z ot√°zky "4 implement√°cie prioritn√©ho frontu a zoraƒè ich na z√°klade oper√°cie vlo≈æ" mal dvojzoznam ako O(1) amortizovane pre vlo≈æ. Pre vyber to nie je explicitne uveden√©.*
    *   Ak berieme be≈æn√∫ implement√°ciu dvojzoznamu ako prioritn√©ho frontu, vyber by mal by≈• r√Ωchly, ak je prvok v kr√°tkej ƒçasti a t√° je mal√°. Ak sa musia zluƒçova≈•, je to drah≈°ie. Zarad√≠m ho s ot√°znikom za haldu.

4.  **Neutrieden√Ω sekvenƒçn√Ω prioritn√Ω front (Unsorted Sequential Priority Queue):**
    *   Implement√°cia: Pole alebo zre≈•azen√Ω zoznam, kde prvky s√∫ vkladan√© bez ohƒæadu na prioritu (napr. na koniec).
    *   Zlo≈æitos≈• oper√°cie VYBER: **O(n)**
    *   Vysvetlenie: Na n√°jdenie prvku s najvy≈°≈°ou prioritou je potrebn√© prejs≈• cel√∫ sekvenciu a porovna≈• v≈°etky prvky.
    *   (V√Ωhoda: Vlo≈æenie je O(1)).

**Zoradenie (s ohƒæadom na nejasnos≈• Dvojzoznamu pre VYBER):**
1.  **Utrieden√Ω sekvenƒçn√Ω PF:** O(1)
2.  **ƒΩavostrann√° halda:** O(log n)
3.  **Dvojzoznam:** ? (Potenci√°lne od O(1) po O(n) v z√°vislosti od implement√°cie a stavu. Ak je kr√°tka ƒças≈• mal√° a prehƒæad√°va sa, tak efekt√≠vne. Ak je kr√°tka ƒças≈• veƒæk√° alebo sa mus√≠ prehƒæad√°va≈• dlh√° ƒças≈•, tak menej efekt√≠vne). Pre √∫ƒçely tohto poradia ho dajme ako hor≈°√≠ ne≈æ halda, ale lep≈°√≠ ne≈æ √∫plne neutrieden√Ω. Mo≈æno O(k) alebo O(log n) v typick√Ωch pr√≠padoch.
4.  **Neutrieden√Ω sekvenƒçn√Ω PF:** O(n)

Upraven√© poradie s konzervat√≠vnym odhadom pre dvojzoznam:
1.  **Utrieden√Ω sekvenƒçn√Ω PF:** O(1)
2.  **ƒΩavostrann√° halda:** O(log n)
3.  **Dvojzoznam:** (napr. O(k), kde k je veƒækos≈• kr√°tkej sekvencie; ak k ~ log n, tak porovnateƒæn√© s haldou. Ak k je mal√© kon≈°tantn√©, tak bl√≠zko O(1))
4.  **Neutrieden√Ω sekvenƒçn√Ω PF:** O(n)

Ak by sme mali by≈• striktn√≠ a dvojzoznam by vy≈æadoval prehƒæadanie podstatnej ƒçasti, mohol by by≈• aj za neutrieden√Ωm, ale to by popieralo jeho √∫ƒçel ako efekt√≠vneho PF. Pravdepodobnej≈°ie je, ≈æe je navrhnut√Ω tak, aby vyber bol tie≈æ relat√≠vne r√Ωchly. `
            },
            {
                question: "Nap√≠≈° ƒço je to sAPT(blok siete) a br√°na:",
                answer: `**sAPT (blok siete) - Blok pam√§te v sie≈•ovom Abstraktnom Pam√§≈•ovom Type:**

V kontexte sie≈•ov√Ωch Abstraktn√Ωch Pam√§≈•ov√Ωch Typov (APT pre siete, niekedy oznaƒçovan√© ako sAPT, kde 's' m√¥≈æe znamena≈• sie≈•/strukt√∫ra):
*   **Bloky pam√§te sa oznaƒçuj√∫ ako vrcholy (nodes/vertices) siete.**
*   Sie≈•ov√Ω APT definuje, ako s√∫ tieto vrcholy organizovan√© a ak√© oper√°cie s√∫ nad nimi definovan√©.
*   Charakteristick√Ωm rysom siete je, ≈æe **ka≈æd√Ω vrchol m√¥≈æe ma≈• potenci√°lne vz≈•ah (by≈• spojen√Ω hranou) s ka≈æd√Ωm in√Ωm vrcholom siete.** Vz≈•ahy nie s√∫ obmedzen√© na line√°rne (ako v sekvencii) alebo hierarchick√© (ako v strome).
*   **Vz≈•ahy medzi vrcholmi v sie≈•ov√Ωch APT s√∫ neline√°rne a nehierarchick√©.**
*   **≈Ωiadny vrchol v sie≈•ovom APT nem√° prirodzene v√Ωnimoƒçn√© postavenie** (na rozdiel od prv√©ho/posledn√©ho prvku v sekvencii, alebo kore≈àa v hierarchii). Ak√Ωkoƒævek vrchol m√¥≈æe by≈• v√Ωchodiskov√Ωm bodom pre oper√°cie.

**Br√°na (Gateway / Portal) v sie≈•ovom APT:**

Keƒè≈æe v sieti neexistuje jeden prirodzen√Ω vstupn√Ω bod (ako kore≈à v strome), je potrebn√Ω mechanizmus na pr√≠stup k vrcholom siete. Tento mechanizmus sa naz√Ωva **br√°na**.

*   **√öƒçel br√°ny:** Br√°na je s√∫ƒças≈• sie≈•ov√©ho APT (alebo pridru≈æen√° ≈°trukt√∫ra), ktor√° **udr≈æiava referencie na v≈°etky (alebo podmno≈æinu) blokov pam√§te (vrcholov) v sieti.**
*   **≈†trukt√∫ra br√°ny:** Tieto referencie s√∫ typicky ulo≈æen√© v nejakej forme **sekvencie** (napr. pole, zre≈•azen√Ω zoznam, he≈°ovacia tabuƒæka mapuj√∫ca identifik√°tory vrcholov na referencie).
*   **Funkcia br√°ny:**
    *   Umo≈æ≈àuje iterova≈• cez v≈°etky vrcholy v sieti.
    *   Umo≈æ≈àuje n√°js≈• konkr√©tny vrchol (napr. podƒæa jeho ID alebo in√©ho atrib√∫tu), ak br√°na podporuje indexovan√Ω pr√≠stup alebo vyhƒæad√°vanie.
    *   Sl√∫≈æi ako vstupn√Ω bod pre algoritmy pracuj√∫ce so sie≈•ou (napr. prehƒæad√°vanie do ≈°√≠rky/hƒ∫bky m√¥≈æe zaƒça≈• z vrcholu z√≠skan√©ho cez br√°nu).

*   **Implement√°cia br√°ny (podƒæa v√°≈°ho textu):**
    *   **Statick√° sie≈•:** Ako br√°na m√¥≈æe by≈• pou≈æit√° **implicitn√° sekvencia** (napr. pole referenci√≠ na vrcholy). Toto je mo≈æn√©, preto≈æe poƒçet vrcholov v statickej sieti je fixn√Ω.
    *   **Dynamick√° sie≈•:** Ako br√°na je typicky pou≈æit√° **explicitn√° sekvencia** (napr. zre≈•azen√Ω zoznam referenci√≠ alebo dynamick√© pole), preto≈æe poƒçet vrcholov sa m√¥≈æe meni≈• a explicitn√° sekvencia sa vie flexibilne prisp√¥sobi≈• t√Ωmto zmen√°m.

V podstate, sAPT blok je len in√Ω n√°zov pre vrchol v kontexte abstraktnej organiz√°cie pam√§te pre siete, a br√°na je pomocn√° ≈°trukt√∫ra, ktor√° poskytuje pr√≠stup k t√Ωmto vrcholom.`
            },
            {
                question: "Nap√≠≈° presn√© √∫dajov√© typy, ktor√© vyu≈æ√≠vaj√∫ sekvenciu:",
                answer: `Nasleduj√∫ce Abstraktn√© √ödajov√© Typy (AUT) alebo Abstraktn√© √ödajov√© ≈†trukt√∫ry (AU≈†) vyu≈æ√≠vaj√∫ koncept sekvencie ako z√°kladn√∫ alebo pomocn√∫ ≈°trukt√∫ru:

**1. Z√°kladn√© typy sekvenci√≠ (ƒçasto ako AU≈† pre AUT Sekvencia):**
*   **Implicitn√° sekvencia (Implicit Sequence):**
    *   Realizovan√° typicky pomocou poƒæa (array). Prvky s√∫ ulo≈æen√© v s√∫vislom bloku pam√§te.
    *   Pr√≠klad: Statick√© pole, dynamick√© pole (vector v C++, ArrayList v Jave).
*   **Explicitn√° sekvencia (Explicit Sequence):**
    *   Realizovan√° typicky pomocou zre≈•azen√Ωch zoznamov. Ka≈æd√Ω prvok (uzol) obsahuje d√°ta a referenciu (ukazovateƒæ) na ƒèal≈°√≠ prvok (a pr√≠padne predch√°dzaj√∫ci).
    *   **Jednostranne zre≈•azen√° sekvencia (Singly Linked List)**
    *   **Obojstranne zre≈•azen√° sekvencia (Doubly Linked List)**
*   **Cyklick√© varianty:**
    *   **Implicitn√° cyklick√° sekvencia (Circular Array/Buffer):** Pole, kde posledn√Ω prvok logicky nasleduje prv√Ω.
    *   **Jednostranne zre≈•azen√° cyklick√° sekvencia (Circular Singly Linked List):** Posledn√Ω prvok ukazuje na prv√Ω.
    *   **Obojstranne zre≈•azen√° cyklick√° sekvencia (Circular Doubly Linked List):** Posledn√Ω ukazuje na prv√Ω a prv√Ω na posledn√Ω.

**2. Abstraktn√© √∫dajov√© typy implementovan√© pomocou sekvenci√≠:**
*   **Z√°sobn√≠k (Stack - AUT):**
    *   M√¥≈æe by≈• implementovan√Ω pomocou implicitnej sekvencie (pole) alebo explicitnej sekvencie (zre≈•azen√Ω zoznam).
*   **Rad (Queue - AUT):**
    *   M√¥≈æe by≈• implementovan√Ω pomocou implicitnej cyklickej sekvencie (pole) alebo explicitnej sekvencie (zre≈•azen√Ω zoznam).
*   **Prioritn√Ω front (Priority Queue - AUT):**
    *   **AUS Neutrieden√Ω sekvenƒçn√Ω prioritn√Ω front:** Pou≈æ√≠va implicitn√∫ alebo explicitn√∫ sekvenciu na ukladanie prvkov bez ≈°pecifick√©ho poradia.
    *   **AUS Utrieden√Ω sekvenƒçn√Ω prioritn√Ω front:** Pou≈æ√≠va implicitn√∫ alebo explicitn√∫ sekvenciu, kde prvky s√∫ udr≈æiavan√© utrieden√© podƒæa priority.
*   **Zoznam (List - AUT):** V≈°eobecnej≈°√≠ typ ako z√°sobn√≠k alebo rad, umo≈æ≈àuje vkladanie, mazanie a pr√≠stup k prvkom na ƒæubovoƒænej poz√≠cii. ƒåasto implementovan√Ω ako dynamick√© pole alebo zre≈•azen√Ω zoznam.

**3. Komplexnej≈°ie ≈°trukt√∫ry vyu≈æ√≠vaj√∫ce sekvencie ako komponenty:**
*   **AUMS Dvojzoznam (Two-List Structure):**
    *   Vyu≈æ√≠va dve sekvencie na implement√°ciu prioritn√©ho frontu:
        *   **Kr√°tka sekvencia:** ƒåasto implicitn√° sekvencia s pevnou (alebo obmedzenou) kapacitou.
        *   **Dlh√° sekvencia:** ƒåasto jednostranne zre≈•azen√° sekvencia.
*   **Ha≈°ovacia tabuƒæka (Hash Table) s rie≈°en√≠m kol√≠zi√≠ zre≈•azovan√≠m (Chaining):**
    *   Hlavn√° ≈°trukt√∫ra je pole (implicitn√° sekvencia).
    *   Ka≈æd√Ω prvok tohto poƒæa je ukazovateƒæ na zaƒçiatok explicitnej sekvencie (zre≈•azen√©ho zoznamu), ktor√° uchov√°va prvky s rovnakou he≈°ovacou hodnotou (synonym√°).
*   **Zoznamy susednosti (Adjacency Lists) pre reprezent√°ciu grafov:**
    *   Pou≈æ√≠va sa pole (implicitn√° sekvencia), kde ka≈æd√Ω index zodpoved√° vrcholu grafu.
    *   Hodnota na ka≈ædom indexe je referencia na explicitn√∫ sekvenciu (zre≈•azen√Ω zoznam) susedov dan√©ho vrcholu.
*   **Br√°na (Gateway) v sie≈•ov√Ωch APT:**
    *   Ako bolo spomenut√© vo va≈°om texte, br√°na na pr√≠stup k vrcholom siete m√¥≈æe by≈• implementovan√° ako implicitn√° sekvencia (pre statick√© siete) alebo explicitn√° sekvencia (pre dynamick√© siete).

Tento zoznam ukazuje, ≈æe sekvencia je fundament√°lny koncept, ktor√Ω sl√∫≈æi buƒè priamo ako d√°tov√° ≈°trukt√∫ra, alebo ako stavebn√Ω blok pre mnoh√© in√©, komplexnej≈°ie d√°tov√© typy a ≈°trukt√∫ry.`
            },
            {
                question: "Neinicializovan√Ω √∫dajov√Ω segment, inicializovan√Ω √∫dajov√Ω segment, k√≥dov√Ω segment) + pop√≠sa≈• ƒço ka≈æd√Ω rob√≠ a ako sa v tej \"≈°trukt√∫re\" nach√°dzaj√∫:",
                answer: `Keƒè je program spusten√Ω, operaƒçn√Ω syst√©m mu pridel√≠ pam√§≈•ov√Ω priestor. Tento priestor je typicky rozdelen√Ω do niekoƒæk√Ωch segmentov. Tri z kƒæ√∫ƒçov√Ωch segmentov s√∫ k√≥dov√Ω segment, inicializovan√Ω √∫dajov√Ω segment a neinicializovan√Ω √∫dajov√Ω segment.

**1. K√≥dov√Ω segment (Code Segment / Text Segment):**
*   **ƒåo rob√≠/obsahuje:**
    *   Obsahuje **vykonateƒæn√© in≈°trukcie** programu, teda samotn√Ω prelo≈æen√Ω strojov√Ω k√≥d.
    *   M√¥≈æe obsahova≈• aj niektor√© kon≈°tantn√© d√°ta, ktor√© s√∫ s√∫ƒças≈•ou in≈°trukci√≠ (napr. re≈•azcov√© liter√°ly, read-only kon≈°tanty).
*   **Vlastnosti:**
    *   Typicky je **read-only** (len na ƒç√≠tanie), aby sa zabr√°nilo n√°hodnej alebo √∫myselnej modifik√°cii k√≥du programu poƒças jeho behu.
    *   M√¥≈æe by≈• **zdieƒæan√Ω** medzi viacer√Ωmi procesmi, ak sp√∫≈°≈•aj√∫ ten ist√Ω program (napr. viacer√© in≈°tancie textov√©ho editora m√¥≈æu zdieƒæa≈• ten ist√Ω k√≥dov√Ω segment v pam√§ti).
*   **Umiestnenie v ≈°trukt√∫re pam√§te procesu (typick√© pre mnoh√© OS):**
    *   Nach√°dza sa v **spodnej ƒçasti** (najni≈æ≈°ie adresy) pam√§≈•ov√©ho priestoru procesu.

**2. Inicializovan√Ω √∫dajov√Ω segment (Initialized Data Segment / .data segment):**
*   **ƒåo rob√≠/obsahuje:**
    *   Obsahuje **glob√°lne a statick√© premenn√©, ktor√© maj√∫ v zdrojovom k√≥de explicitne priraden√∫ poƒçiatoƒçn√∫ hodnotu (s√∫ inicializovan√©).**
    *   Pr√≠klad v C/C++: \`int global_var = 100;\` alebo \`static int static_var = 50;\`.
*   **Vlastnosti:**
    *   Je **read-write** (na ƒç√≠tanie aj z√°pis), preto≈æe hodnoty t√Ωchto premenn√Ωch sa m√¥≈æu poƒças behu programu meni≈•.
    *   Veƒækos≈• tohto segmentu je zn√°ma v ƒçase kompil√°cie. Hodnoty pre inicializ√°ciu s√∫ ulo≈æen√© priamo vo vykonateƒænom s√∫bore a pri spusten√≠ programu sa naƒç√≠taj√∫ do pam√§te.
*   **Umiestnenie v ≈°trukt√∫re pam√§te procesu:**
    *   Nach√°dza sa **nad k√≥dov√Ωm segmentom**.

**3. Neinicializovan√Ω √∫dajov√Ω segment (Uninitialized Data Segment / .bss segment - Block Started by Symbol):**
*   **ƒåo rob√≠/obsahuje:**
    *   Obsahuje **glob√°lne a statick√© premenn√©, ktor√© v zdrojovom k√≥de nie s√∫ explicitne inicializovan√©, alebo s√∫ inicializovan√© na nulu.**
    *   Pr√≠klad v C/C++: \`int global_uninit_var;\` alebo \`static int static_uninit_var;\`.
*   **Vlastnosti:**
    *   Je **read-write**.
    *   Operaƒçn√Ω syst√©m (alebo C runtime) zabezpeƒç√≠, ≈æe v≈°etky premenn√© v tomto segmente s√∫ pred spusten√≠m funkcie \`main\` **inicializovan√© na nulu** (alebo nulov√© bitov√© vzory pre in√© typy).
    *   V√Ωhoda .bss segmentu je, ≈æe vo vykonateƒænom s√∫bore na disku zaber√° len inform√°ciu o svojej veƒækosti, nie skutoƒçn√© nulov√© hodnoty pre ka≈æd√∫ premenn√∫. To ≈°etr√≠ miesto na disku. Pri naƒç√≠tan√≠ programu do pam√§te sa alokuje potrebn√Ω priestor a vynuluje sa.
*   **Umiestnenie v ≈°trukt√∫re pam√§te procesu:**
    *   Nach√°dza sa **nad inicializovan√Ωm √∫dajov√Ωm segmentom**.

**Typick√© usporiadanie v pam√§≈•ovom priestore procesu (od najni≈æ≈°√≠ch adries po vy≈°≈°ie):**

\`\`\`
+-------------------------+  <-- Vy≈°≈°ie adresy
| Argumenty pr√≠kaz. riadku|
| Premenn√© prostredia     |
+-------------------------+
| Z√°sobn√≠k (Stack)        |  (rastie smerom k ni≈æ≈°√≠m adres√°m)
|          |              |
|          V              |
+-------------------------+
|                         |  (Nepou≈æit√° pam√§≈• / medzera)
+-------------------------+
|          ^              |
|          |              |
| Halda (Heap)            |  (rastie smerom k vy≈°≈°√≠m adres√°m)
+-------------------------+
| Neinicializovan√Ω √∫dajov√Ω|  (.bss segment)
| segment                 |
+-------------------------+
| Inicializovan√Ω √∫dajov√Ω  |  (.data segment)
| segment                 |
+-------------------------+
| K√≥dov√Ω segment          |  (.text segment)
+-------------------------+  <-- Najni≈æ≈°ie adresy
\`\`\`

**ƒéal≈°ie d√¥le≈æit√© oblasti (nie s√∫ s√∫ƒças≈•ou ot√°zky, ale pre kontext):**
*   **Halda (Heap):** Oblas≈• pre dynamick√∫ alok√°ciu pam√§te (\`malloc\`, \`new\`). Rastie smerom k vy≈°≈°√≠m adres√°m.
*   **Z√°sobn√≠k (Stack):** Oblas≈• pre lok√°lne premenn√© funkci√≠, argumenty funkci√≠ a n√°vratov√© adresy. Rastie smerom k ni≈æ≈°√≠m adres√°m.

Toto usporiadanie je typick√©, ale detaily sa m√¥≈æu l√≠≈°i≈• medzi r√¥znymi operaƒçn√Ωmi syst√©mami a architekt√∫rami. Segmenty .data a .bss spolu tvoria statick√∫ pam√§≈• programu.`
            },
            {
                question: "Nap√≠≈° 3 rie≈°enia kol√≠zii (popis, v√Ωhody, nev√Ωhody):",
                answer: `Kol√≠zie v he≈°ovac√≠ch tabuƒæk√°ch nast√°vaj√∫, keƒè dva alebo viac r√¥znych kƒæ√∫ƒçov vygeneruje rovnak√∫ he≈°ovaciu hodnotu (a teda rovnak√Ω index do tabuƒæky). Tu s√∫ tri be≈æn√© met√≥dy rie≈°enia kol√≠zi√≠:

**1. Zre≈•azovanie (Chaining / Separate Chaining):**

*   **Popis:**
    *   Ka≈æd√° polo≈æka (slot/bucket) v he≈°ovacej tabuƒæke nie je samotn√Ω prvok, ale ukazovateƒæ na zaƒçiatok d√°tovej ≈°trukt√∫ry (typicky **zre≈•azen√©ho zoznamu**), ktor√° uchov√°va v≈°etky prvky, ktor√© he≈°ovali na tento konkr√©tny index.
    *   Keƒè d√¥jde ku kol√≠zii (nov√Ω prvok he≈°uje na u≈æ obsaden√Ω index, kde u≈æ existuje zoznam), nov√Ω prvok sa jednoducho prid√° do tohto zre≈•azen√©ho zoznamu (napr. na jeho zaƒçiatok alebo koniec).
*   **V√Ωhody:**
    *   **Jednoduch√° implement√°cia:** Relat√≠vne ƒæahko sa k√≥duje a spravuje.
    *   **Neobmedzen√Ω (teoreticky) poƒçet prvkov:** Tabuƒæka sa nikdy nem√¥≈æe "√∫plne zaplni≈•" v zmysle, ≈æe by nebolo kam vlo≈æi≈• nov√Ω prvok (pokiaƒæ je dostatok pam√§te pre zoznamy). Faktor zaplnenia m√¥≈æe by≈• aj > 1.
    *   **Jednoduch√© mazanie prvkov:** Odstr√°nenie prvku zo zre≈•azen√©ho zoznamu je ≈°tandardn√° oper√°cia.
    *   Menej citliv√© na zl√∫ he≈°ovaciu funkciu alebo vysok√Ω faktor zaplnenia v porovnan√≠ s otvorenou adres√°ciou, aj keƒè v√Ωkon kles√°.
*   **Nev√Ωhody:**
    *   **Vy≈°≈°ia pam√§≈•ov√° n√°roƒçnos≈•:** Ka≈æd√Ω prvok v zre≈•azenom zozname potrebuje dodatoƒçn√∫ pam√§≈• pre ukazovateƒæ na ƒèal≈°√≠ prvok.
    *   **Pomal≈°√≠ pr√≠stup pri dlh√Ωch re≈•azcoch:** Ak veƒæa prvkov he≈°uje na rovnak√Ω index, pr√≠slu≈°n√Ω zre≈•azen√Ω zoznam sa st√°va dlh√Ωm a oper√°cie (n√°jdi, vlo≈æ s kontrolou duplik√°tov, zru≈°) m√¥≈æu degenerova≈• na O(n) v najhor≈°om pr√≠pade (prech√°dzanie dlh√©ho zoznamu).
    *   Pr√≠stup k prvkom m√¥≈æe by≈• pomal≈°√≠ kv√¥li "cache misses", preto≈æe prvky zoznamu nemusia by≈• v pam√§ti ulo≈æen√© bl√≠zko seba.

**2. Otvoren√° adres√°cia (Open Addressing):**

*   **Popis:**
    *   V≈°etky prvky sa ukladaj√∫ priamo do samotnej he≈°ovacej tabuƒæky (poƒæa).
    *   Keƒè d√¥jde ku kol√≠zii (cieƒæov√Ω slot \`H(k)\` je u≈æ obsaden√Ω), algoritmus systematicky hƒæad√° in√Ω voƒæn√Ω slot v tabuƒæke podƒæa urƒçitej **sondovacej sekvencie (probe sequence)**.
    *   Be≈æn√© typy sondovania:
        *   **Line√°rne sondovanie:** Hƒæad√° sa v slotoch \`H(k)+1, H(k)+2, ...\` (modulo veƒækos≈• tabuƒæky).
        *   **Kvadratick√© sondovanie:** Hƒæad√° sa v slotoch \`H(k)+1¬≤, H(k)+2¬≤, ...\`.
        *   **Dvojit√© he≈°ovanie:** Pou≈æije sa druh√° he≈°ovacia funkcia \`H2(k)\` na urƒçenie kroku sondovania: \`H(k)+1*H2(k), H(k)+2*H2(k), ...\`.
*   **V√Ωhody:**
    *   **Ni≈æ≈°ia pam√§≈•ov√° n√°roƒçnos≈•:** Nevy≈æaduj√∫ sa dodatoƒçn√© ukazovatele pre zre≈•azen√© zoznamy. V≈°etky d√°ta s√∫ priamo v tabuƒæke.
    *   **Lep≈°ie vyu≈æitie cache:** Prvky s√∫ ƒçasto ulo≈æen√© bl√≠zko seba v pam√§ti, ƒço m√¥≈æe vies≈• k r√Ωchlej≈°iemu pr√≠stupu.
*   **Nev√Ωhody:**
    *   **Komplikovanej≈°ie mazanie prvkov:** Jednoduch√© odstr√°nenie prvku m√¥≈æe preru≈°i≈• sondovaciu sekvenciu pre in√© prvky. Vy≈æaduje sa oznaƒçenie slotu ako "vymazan√Ω" (tombstone) alebo komplexnej≈°√≠ rehash.
    *   **Citlivos≈• na faktor zaplnenia:** V√Ωkon sa v√Ωrazne zhor≈°uje, keƒè sa faktor zaplnenia bl√≠≈æi k 1 (tabuƒæka je takmer pln√°). Pre otvoren√∫ adres√°ciu mus√≠ by≈• faktor zaplnenia < 1.
    *   **Probl√©m zhlukovania (clustering):**
        *   *Prim√°rne zhlukovanie (Line√°rne sondovanie):* Obsaden√© sloty maj√∫ tendenciu tvori≈• s√∫visl√© bloky, ƒço predl≈æuje sondovacie sekvencie.
        *   *Sekund√°rne zhlukovanie (Kvadratick√© sondovanie):* Ak dva kƒæ√∫ƒçe he≈°uj√∫ na rovnak√Ω poƒçiatoƒçn√Ω slot, bud√∫ nasledova≈• rovnak√∫ sondovaciu sekvenciu. Dvojit√© he≈°ovanie tento probl√©m zmier≈àuje.
    *   Potreba dobrej he≈°ovacej funkcie a vhodnej sondovacej strat√©gie je kritickej≈°ia.

**3. Vyu≈æitie prepl≈àovacej oblasti (Overflow Area / Separate Overflow Chaining):**

*   **Popis:**
    *   He≈°ovacia tabuƒæka je rozdelen√° na dve oblasti:
        *   **Prim√°rna oblas≈•:** Hlavn√° ƒças≈• tabuƒæky, kam sa prvky sna≈æia ulo≈æi≈• priamo na z√°klade ich he≈°ovacej hodnoty. Ka≈æd√Ω slot v prim√°rnej oblasti m√¥≈æe obsahova≈• jeden prvok.
        *   **Prepl≈àovacia oblas≈• (Overflow Area):** Samostatn√° oblas≈• pam√§te (m√¥≈æe by≈• in√° he≈°ovacia tabuƒæka, zre≈•azen√Ω zoznam, alebo vyhraden√° ƒças≈• p√¥vodnej tabuƒæky), kam sa ukladaj√∫ prvky, ktor√© sp√¥sobili kol√≠ziu v prim√°rnej oblasti.
    *   Ak je slot v prim√°rnej oblasti obsaden√Ω, koliduj√∫ci prvok sa umiestni do prepl≈àovacej oblasti. Slot v prim√°rnej oblasti m√¥≈æe obsahova≈• ukazovateƒæ na zaƒçiatok re≈•azca synon√Ωm v prepl≈àovacej oblasti.
*   **V√Ωhody:**
    *   **Oddelenie koliduj√∫cich prvkov:** Udr≈æuje prim√°rnu oblas≈• relat√≠vne "ƒçist√∫", ƒço m√¥≈æe zr√Ωchli≈• pr√≠stup k prvkom, ktor√© nekolidovali.
    *   **Jednoduch≈°ie riadenie kol√≠zi√≠:** Kol√≠zie s√∫ spravovan√© v dedikovanej oblasti, ƒço m√¥≈æe zjednodu≈°i≈• logiku.
    *   M√¥≈æe by≈• kombin√°ciou v√Ωhod otvorenej adres√°cie (pre prim√°rnu oblas≈•) a zre≈•azovania (pre prepl≈àovaciu oblas≈•).
*   **Nev√Ωhody:**
    *   **Obmedzenie maxim√°lneho poƒçtu prvkov:** Ak m√° prepl≈àovacia oblas≈• fixn√∫ veƒækos≈•, m√¥≈æe sa zaplni≈•.
    *   **Potenci√°lne dve √∫rovne pr√≠stupu:** Ak prvok nie je v prim√°rnej oblasti, mus√≠ sa hƒæada≈• v prepl≈àovacej, ƒço m√¥≈æe by≈• pomal≈°ie.
    *   **Spr√°va prepl≈àovacej oblasti:** Vy≈æaduje dodatoƒçn√∫ logiku a pam√§≈• pre spr√°vu tejto oblasti. M√¥≈æe by≈• zlo≈æitej≈°ia na implement√°ciu ako jednoduch√© zre≈•azovanie.
    *   Ak je prepl≈àovacia oblas≈• zle navrhnut√° alebo sa r√Ωchlo zapln√≠, v√Ωkon m√¥≈æe v√Ωrazne klesn√∫≈•.

Ka≈æd√° met√≥da m√° svoje kompromisy a vhodnos≈• z√°vis√≠ od konkr√©tnych po≈æiadaviek aplik√°cie (oƒçak√°van√Ω poƒçet prvkov, frekvencia oper√°ci√≠, po≈æiadavky na pam√§≈•, atƒè.).`
            }
        ];

        let deck = [];
        const flashcardContainer = document.getElementById('flashcard-container');
        const flashcardElement = document.querySelector('.flashcard');
        const frontFace = document.querySelector('.flashcard-front');
        const backFace = document.querySelector('.flashcard-back');
        const controlsElement = document.getElementById('controls');
        const correctBtn = document.getElementById('correct-btn');
        const incorrectBtn = document.getElementById('incorrect-btn');
        const statusElement = document.getElementById('status');
        const completionMessageElement = document.getElementById('completion-message');

        let isFlipped = false;

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function formatAnswer(answerText) {
            // Z√°kladn√© nahradenie pre bullet pointy a ƒç√≠slovan√© zoznamy
            // M√¥≈æe by≈• roz≈°√≠ren√© pre komplexnej≈°ie form√°tovanie
            let htmlAnswer = answerText.replace(/‚Ä¢\s/g, '<li>');
            
            // Regex na n√°jdenie riadkov zaƒç√≠naj√∫cich ƒç√≠slom s bodkou (pre ƒç√≠slovan√© zoznamy)
            // Toto je zjednodu≈°en√©, nemus√≠ pokry≈• v≈°etky pr√≠pady vnoren√Ωch zoznamov
            htmlAnswer = htmlAnswer.replace(/^(\d+\.)\s*(.*)/gm, (match, num, item) => `<li>${num} ${item}</li>`);
            
            // Ak sme pou≈æili <li>, obal√≠me to do <ul> alebo <ol>
            // Toto je heuristika, nemus√≠ by≈• dokonal√°. Ak predpoklad√°me, ≈æe ‚Ä¢ s√∫ ul a ƒç√≠sla ol.
            if (htmlAnswer.includes('<li>')) {
                 if (/<li>\d+\./.test(htmlAnswer)) { // Ak prv√© li zaƒç√≠na ƒç√≠slom
                    htmlAnswer = '<ol>' + htmlAnswer.replace(/<\/li>\n?/g, '</li>') + '</ol>';
                 } else {
                    htmlAnswer = '<ul>' + htmlAnswer.replace(/<\/li>\n?/g, '</li>') + '</ul>';
                 }
                 // Odstr√°ni≈• pr√°zdne <li> ak vznikli
                 htmlAnswer = htmlAnswer.replace(/<li>\s*<\/li>/g, '');
            }

            // Nahradenie nov√Ωch riadkov za <br> tam, kde nie s√∫ s√∫ƒças≈•ou <li>
            // Toto je tricky, aby sme neprid√°vali <br> dovn√∫tra u≈æ form√°tovan√Ωch zoznamov
            // Jednoduch≈°ie je necha≈• to na `white-space: pre-wrap;` a form√°tova≈• len explicitn√© ≈°trukt√∫ry

            // Namiesto komplexn√©ho nahr√°dzania nov√Ωch riadkov, spoƒæahneme sa na `white-space: pre-wrap;`
            // a len manu√°lne uprav√≠me bullet pointy
            
            // Jednoduch≈°ia verzia:
            htmlAnswer = answerText
                .replace(/\n\d+\.\s*/g, (match) => `<br>${match.trimStart()}`) // Zachov√° ƒç√≠slovanie
                .replace(/\n‚Ä¢\s*/g, (match) => `<br>${match.trimStart()}`);    // Zachov√° bullety

            return htmlAnswer;
        }


        function displayCurrentCard() {
            if (deck.length === 0) {
                flashcardContainer.style.display = 'none';
                controlsElement.style.display = 'none';
                statusElement.style.display = 'none';
                completionMessageElement.style.display = 'block';
                return;
            }

            flashcardContainer.style.display = 'block'; // Uisti sa, ≈æe je viditeƒæn√Ω
            statusElement.style.display = 'block';
            completionMessageElement.style.display = 'none';


            const cardData = deck[0];
            frontFace.textContent = cardData.question;
            backFace.innerHTML = cardData.answer; // Pou≈æijeme priamo, keƒè≈æe form√°tovanie je u≈æ v d√°tach
                                                  // alebo pou≈æijeme formatAnswer(cardData.answer) ak chceme dynamick√© form√°tovanie

            flashcardElement.classList.remove('flipped');
            isFlipped = false;
            controlsElement.style.display = 'none'; // Skryjeme ovl√°dacie prvky k√Ωm sa kartiƒçka neotoƒç√≠
            updateStatus();
        }

        function updateStatus() {
            statusElement.textContent = `Zost√°va kariet: ${deck.length}`;
        }

        flashcardElement.addEventListener('click', () => {
            if (deck.length === 0) return;
            flashcardElement.classList.toggle('flipped');
            isFlipped = !isFlipped;
            if (isFlipped) {
                controlsElement.style.display = 'flex';
            } else {
                controlsElement.style.display = 'none';
            }
        });

        correctBtn.addEventListener('click', () => {
            if (deck.length === 0) return;
            deck.shift(); // Odstr√°ni prv√∫ kartiƒçku (aktu√°lnu)
            displayCurrentCard();
        });

        incorrectBtn.addEventListener('click', () => {
            if (deck.length === 0) return;
            const incorrectCard = deck.shift(); // Vezme prv√∫ kartiƒçku
            deck.push(incorrectCard); // Prid√° ju na koniec
            displayCurrentCard();
        });

        function startGame() {
            deck = [...initialCardsData]; // Vytvor√≠me pracovn√∫ k√≥piu
            shuffleArray(deck);
            displayCurrentCard();
        }

        startGame();
    </script>

</body>
</html>
