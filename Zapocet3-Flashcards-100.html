<!DOCTYPE html>
<html lang="sk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Z치po캜et 3 - Flashcards & Test</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            user-select: none;
        }

        /* MENU STYLES */
        .menu-container {
            text-align: center;
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            max-width: 600px;
            width: 90%;
            margin-top: 50px;
        }
        
        .menu-title {
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2rem;
        }

        .menu-btn {
            display: block;
            width: 100%;
            padding: 20px;
            margin: 15px 0;
            font-size: 1.2rem;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, background 0.2s;
            font-weight: bold;
            color: white;
        }

        .btn-learn { background-color: #3498db; }
        .btn-test { background-color: #9b59b6; }
        
        .menu-btn:hover { transform: translateY(-3px); opacity: 0.9; }
        .menu-btn:active { transform: scale(0.98); }

        /* GAME STYLES */
        .game-area {
            display: none; /* Hidden initially */
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            font-size: 1.2rem;
            background: white;
            padding: 15px 30px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .stat-box {
            font-weight: bold;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .stat-label { font-size: 0.8rem; color: #777; font-weight: normal; }
        .stat-value { font-size: 1.5rem; }

        .remaining { color: #3498db; }
        .correct { color: #2ecc71; }
        .incorrect { color: #e74c3c; }

        .card-container {
            perspective: 1000px;
            width: 900px;
            max-width: 95%;
            height: 600px;
            position: relative;
            margin-bottom: 30px;
        }

        .card {
            width: 100%;
            height: 100%;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.6s;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            border-radius: 15px;
            background-color: white;
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            padding: 40px;
            box-sizing: border-box;
            text-align: center;
            overflow-y: auto;
        }

        .card-front {
            background-color: #fff;
            color: #2c3e50;
        }

        .card-back {
            background-color: #fdfdfd;
            color: #2c3e50;
            transform: rotateY(180deg);
            border: 2px solid #e0e0e0;
        }

        h3 { color: #555; margin-top: 0; margin-bottom: 15px; width: 100%; }
        
        pre {
            background: #f4f4f4;
            padding: 15px;
            border-radius: 8px;
            text-align: left;
            width: 100%;
            overflow-x: auto;
            border: 1px solid #ddd;
            font-family: Consolas, monospace;
            white-space: pre-wrap;
            font-size: 0.9rem;
            user-select: text;
            margin-bottom: 10px;
        }

        .controls {
            height: 60px;
            display: flex;
            gap: 20px;
            justify-content: center;
            align-items: center;
        }

        .btn-control {
            padding: 15px 40px;
            border: none;
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s, opacity 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: none; 
            color: white;
        }
        .btn-control:active { transform: scale(0.96); }
        .btn-correct { background-color: #2ecc71; }
        .btn-incorrect { background-color: #e74c3c; }

        .btn-menu {
            display: inline-block; 
            background: #7f8c8d; 
            color:white; 
            margin-top:30px; 
            padding: 15px 30px; 
            border:none; 
            border-radius:8px; 
            font-size:1.1rem; 
            cursor:pointer;
        }

        code { background: #eee; padding: 2px 4px; border-radius: 4px; color: #c7254e; }
        
        .answer-text { text-align: left; line-height: 1.6; }
        strong { color: #2c3e50; }

        .ai-generated {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
            padding: 8px 12px;
            border-radius: 5px;
            font-size: 0.85rem;
            margin-bottom: 15px;
            display: inline-block;
            font-weight: bold;
        }

        .mode-badge {
            position: absolute;
            top: 20px;
            right: 20px;
            background: #e1e1e1;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            color: #555;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <!-- HLAVN칄 MENU -->
    <div class="menu-container" id="main-menu">
        <h1 class="menu-title">Vyberte re쬴m</h1>
        <button class="menu-btn btn-learn" onclick="startLearning()">游닄 V코etky karty (U캜enie)</button>
        <button class="menu-btn btn-test" onclick="startTest()">游 Spusti콘 TEST</button>
        <p style="color:#777; margin-top:20px; font-size:0.9rem;">
            <strong>U캜enie:</strong> Prech치dzajte v코etk칳ch 101 ot치zok rad za radom.<br>
            <strong>Test:</strong> Dostanete 1 n치hodn칰 ot치zku z ka쬯칠ho z 14 okruhov.
        </p>
    </div>

    <!-- HERN츼 PLOCHA -->
    <div class="game-area" id="game-area">
        <div class="mode-badge" id="mode-indicator"></div>

        <div class="stats">
            <div class="stat-box">
                <span class="stat-value remaining" id="count-remaining">0</span>
                <span class="stat-label">Zost치va</span>
            </div>
            <div class="stat-box">
                <span class="stat-value correct" id="count-correct">0</span>
                <span class="stat-label">Spr치vne</span>
            </div>
            <div class="stat-box">
                <span class="stat-value incorrect" id="count-incorrect">0</span>
                <span class="stat-label">Nespr치vne</span>
            </div>
        </div>

        <div class="card-container" id="card-container">
            <div class="card" id="flashcard">
                <div class="card-face card-front">
                    <h3>Ot치zka <span id="q-num"></span></h3>
                    <div id="q-text" style="width: 100%;"></div>
                </div>
                <div class="card-face card-back">
                    <h3>Odpove캞</h3>
                    <div id="a-text" style="width: 100%;"></div>
                </div>
            </div>
        </div>

        <div class="controls" id="controls">
            <button id="btn-incorrect" class="btn-control btn-incorrect" onclick="handleAnswer(false)">Nespr치vne</button>
            <button id="btn-correct" class="btn-control btn-correct" onclick="handleAnswer(true)">Spr치vne</button>
        </div>
    </div>

    <script>
        // --- DATA (101 QUESTIONS) ---
        const questions = [
            // --- DB LINK INSERT (1-3) ---
            { id: 1, q: "M치me vytvoren칳 datab치zov칳 link <code>remote_link</code>, ktor칳 sa odkazuje na in코tanciu students_pdb. Pou쮂셨ate lenka. <br>Nap칤코te pr칤kaz, ktor칳 vlo쮂 obsah lok치lnej tabu쬶y <code>p_predmet</code> do tabu쬶y <code>backup_predmet</code> pou쮂셨ate쬬 tomas na vzdialenom serveri.", a: "<pre>INSERT INTO tomas.backup_predmet@remote_link\nSELECT * FROM p_predmet;</pre>" },
            { id: 2, q: "M치me DB link <code>remote_link</code> (students_pdb), user tomas. <br>Nap칤코te pr칤kaz, ktor칳 vlo쮂 obsah lok치lnej tabu쬶y <code>p_vzdelanie</code> do tabu쬶y <code>data_vzdelanie</code> pou쮂셨ate쬬 lenka na vzdialenom serveri.", a: "<pre>INSERT INTO lenka.data_vzdelanie@remote_link\nSELECT * FROM p_vzdelanie;</pre>" },
            { id: 3, q: "M치me DB link <code>remote_link</code>, user tomas. <br>Vlo쬾e do tabu쬶y <code>log_osoby</code> pou쮂셨ate쬬 lenka na vzdialenom serveri v코etky z치znamy z lok치lnej <code>p_osoba</code>, pre ktor칠 <code>id_osoby</code> e코te neexistuje vo vzdialenej tabu쬶e.", a: "<pre>INSERT INTO lenka.log_osoby@remote_link\nSELECT * FROM p_osoba po \nWHERE NOT EXISTS \n  (SELECT 'x' FROM lenka.log_osoby@remote_link lo\n   WHERE lo.id_osoby = po.id_osoby);</pre>" },
            
            // --- DB LINK UPDATE (4-6) ---
            { id: 4, q: "M치me DB link <code>remote_link</code> (orcl_pdb), user dusan. <br>Aktualizujte lok치lnu tabu쬶u <code>p_poistenie</code>: nastavte d치tum ukon캜enia (<code>dat_do = SYSDATE</code>) pre v코etky osoby, ktor칳ch <code>id_osoby</code> sa nach치dza v tabu쬶e <code>data_osoby</code> pou쮂셨ate쬬 dusan na vzdialenom serveri.", a: "<pre>UPDATE p_poistenie\nSET dat_do = SYSDATE\nWHERE id_osoby IN \n  (SELECT id_osoby\n   FROM dusan.data_osoby@remote_link);</pre>" },
            { id: 5, q: "M치me DB link <code>remote_link</code>, user jana. <br>Aktualizujte lok치lnu tabu쬶u <code>p_zamestnanec</code>: nastavte <code>stav = 'NEAKTIVNY'</code> pre zamestnancov, ktor칳ch ID je v tabu쬶e <code>inactive_ids</code> pou쮂셨ate쬬 tomas na vzdialenom serveri.", a: "<pre>UPDATE p_zamestnanec\nSET stav = 'NEAKTIVNY'\nWHERE id_zamestnanec IN \n  (SELECT ID_ZAMESTNANEC FROM \n   tomas.inactive_ids@remote_link);</pre>" },
            { id: 6, q: "M치me DB link <code>remote_link</code>, user jana. <br>Aktualizujte lok치lnu tabu쬶u <code>p_student</code>: ukon캜ite platnos콘 코t칰dia (<code>dat_do = sysdate</code>) pre 코tudentov, ktor칳ch <code>os_cislo</code> je v tabu쬶e <code>ukonceni_studenti</code> pou쮂셨ate쬬 lenka na vzdialenom serveri.", a: "<pre>UPDATE p_student\nSET dat_do = sysdate\nWHERE os_cislo IN \n  (SELECT os_cislo FROM \n   lenka.ukonceni_studenti@remote_link);</pre>" },
            
            // --- DB LINK LOCAL OPS (7-8) ---
            { id: 7, q: "M치me DB link <code>remote_link</code> (students_pdb), user martin. <br>Vlo쬾e do <strong>lok치lnej</strong> tabu쬶y <code>p_predmet</code> obsah tabu쬶y <code>predmet_link</code> pou쮂셨ate쬬 martin na vzdialenom serveri.", a: "<pre>INSERT INTO p_predmet\nSELECT * FROM martin.predmet_link@remote_link;</pre>" },
            { id: 8, q: "M치me DB link <code>remote_link</code>, user martin. <br>Vlo쬾e do <strong>lok치lnej</strong> tabu쬶y <code>p_ucty</code> z치znamy z tabu쬶y <code>backup_ucty</code> pou쮂셨ate쬬 lenka na vzdialenom serveri.", a: "<pre>INSERT INTO p_ucty\nSELECT * FROM lenka.backup_ucty@remote_link;</pre>" },
            
            // --- DB LINK DELETE (9-10) ---
            { id: 9, q: "M치me DB link <code>remote_link</code>, user andrea. <br>Odstr치켿te z <strong>lok치lnej</strong> tabu쬶y <code>p_poberatel</code> v코etk칳ch poberate쬺v, ktor칳ch <code>id_poberatela</code> sa nach치dza v tabu쬶e <code>del_ids</code> pou쮂셨ate쬬 andrea na vzdialenom serveri.", a: "<pre>DELETE FROM p_poberatel\nWHERE id_poberatela IN \n  (SELECT ID_POBERATELA FROM \n   andrea.del_ids@remote_link);</pre>" },
            { id: 10, q: "M치me DB link <code>remote_link</code>, user andrea. <br>Odstr치켿te z <strong>lok치lnej</strong> tabu쬶y <code>p_nepritomnost</code> v코etky z치znamy, ktor칳ch <code>id_neprit</code> sa nach치dza v tabu쬶e <code>del_neprit</code> pou쮂셨ate쬬 tomas na vzdialenom serveri.", a: "<pre>DELETE FROM p_nepritomnost pn\nWHERE EXISTS\n  (SELECT 'x' FROM tomas.del_neprit@remote_link rmt\n   WHERE pn.id_neprit = rmt.id_neprit);</pre>" },
            
            // --- INDEX DDL (11-13) ---
            { id: 11, q: "Vygenerujte pr칤kazy (netreba spusti콘) na zru코enie v코etk칳ch B-tree indexov nad tabu쬶ou <code>p_poistenie</code>. <br>Pou쬴te poh쬬d <code>user_indexes</code>, filter <code>index_type = 'NORMAL'</code>.", a: "<pre>SELECT 'DROP INDEX \"' || index_name || '\";' \nFROM user_indexes\nWHERE table_name = 'P_POISTENIE'\nAND index_type = 'NORMAL';</pre>" },
            { id: 12, q: "Vygenerujte pr칤kazy na zru코enie v코etk칳ch indexov nad tabu쬶ou <code>p_mesto</code>, <strong>okrem</strong> indexov zabezpe캜uj칰cich unik치tnos콘 (constraint type 'U').", a: "<pre>SELECT 'DROP INDEX ' || index_name || ';'\nFROM user_indexes\nWHERE table_name = 'P_MESTO'\nAND index_name NOT IN \n  (SELECT index_name\n   FROM user_constraints\n   WHERE table_name = 'P_MESTO'\n   AND constraint_type = 'U');</pre>" },
            { id: 13, q: "Vygenerujte pr칤kazy na <strong>rebuild</strong> v코etk칳ch indexov, ktor칠 s칰 asociovan칠 s cudz칤mi k쮂줷꼀i (<code>constraint_type = 'R'</code>) v sch칠me.", a: "<pre>SELECT 'ALTER INDEX ' || i.index_name || ' REBUILD;'\nFROM user_indexes i\nJOIN user_constraints c \n  ON i.index_name = c.constraint_name\nWHERE c.constraint_type = 'R';</pre>" },
            
            // --- INDEX DESIGN (14-19) ---
            { id: 14, q: "Vytvorte najvhodnej코칤 index pre pr칤kaz:<br><pre>select rod_cislo, meno, priezvisko \nfrom p_osoba \nwhere lower(priezvisko) like 'nov%';</pre>", a: "<strong>Function-based index:</strong><br><pre>CREATE INDEX ind_osoba_priezv_lower\nON p_osoba(lower(priezvisko));</pre>" },
            { id: 15, q: "Vytvorte najvhodnej코칤 index(y) pre pr칤kaz:<br><pre>select meno, priezvisko, nazov_mesta\nfrom p_osoba join p_mesto using (psc)\nwhere psc between '01000' and '09999';</pre>", a: "Je potrebn칠 vytvori콘 index pre ka쬯칰 tabu쬶u na spojovac칤 st컄pec:<br><pre>CREATE INDEX ind_osoba_psc\nON p_osoba(psc, meno, priezvisko);\n\nCREATE INDEX ind_mesto_psc\nON p_mesto(psc, nazov_mesta);</pre>" },
            { id: 16, q: "Vytvorte najvhodnej코칤 index pre pr칤kaz:<br><pre>select suma from p_prispevky\nwhere kedy between to_date(...)\nand to_date(...);</pre>", a: "<pre>CREATE INDEX ind_prispevky_todate\nON p_prispevky(kedy, suma);</pre>" },
            { id: 17, q: "Vytvorte najvhodnej코칤 index pre dotaz:<br><pre>select nazov from p_postihnutie\nwhere lower(nazov) like '%sluch%';</pre>", a: "<pre>CREATE INDEX ind_post_lower\nON p_postihnutie(lower(nazov), nazov);</pre><br><i>Pozn치mka:</i> Aj ke캞 je '%' na za캜iatku, index (Fast Full Scan) je r칳chlej코칤 ako Full Table Scan, lebo je fyzicky men코칤." },
            { id: 18, q: "Vytvorte najvhodnej코칤 index pre pr칤kaz:<br><pre>select meno, priezvisko from zamestnanec\nwhere datum_do is null;</pre>", a: "<pre>CREATE INDEX ind_zamestnanec_datum\nON zamestnanec(datum_do, meno, priezvisko);</pre><br><i>D칪le쬴t칠:</i> Do indexu mus칤me prida콘 aj NOT NULL st컄pce (meno, priezvisko), inak by sa riadky, kde je k쮂줷 NULL, do B-tree indexu neulo쬴li." },
            { id: 19, q: "Vytvorte najvhodnej코칤 index pre dotaz:<br><pre>select * from p_osoba\nwhere substr(rod_cislo,1,1) = '6';</pre>", a: "<pre>CREATE INDEX ind_osoba_substr\nON p_osoba(substr(rod_cislo, 1, 1));</pre>" },
            
            // --- ACCESS METHODS (20-23) ---
            { id: 20, q: "M치me index <code>(psc, meno, priezvisko)</code>.<br>Ak칰 pr칤stupov칰 met칩du zvol칤 DB pre:<br><code>WHERE psc = '01001'</code>?<br>Zd칪vodnite.", a: "<strong>INDEX RANGE SCAN</strong><br>1. Leading Column (psc) je pou쬴t칳 v podmienke.<br>2. PSC nie je unik치tne -> Range Scan.<br>3. Je to Covering Index (v코etky st컄pce s칰 v indexe)." },
            { id: 21, q: "M치me index <code>(id_typu, kedy)</code>.<br>Ak칰 pr칤stupov칰 met칩du zvol칤 DB pre:<br><code>select sum(suma) ... WHERE id_typu = 4;</code>?<br>Zd칪vodnite.", a: "<strong>INDEX RANGE SCAN</strong> nasledovan칳 <strong>TABLE ACCESS BY INDEX ROWID</strong>.<br>Pou쮂셨a sa vodiaci st컄pec <code>id_typu</code> (Range scan).<br>Ale st컄pec <code>suma</code> nie je v indexe, tak쬰 DB mus칤 칤s콘 do tabu쬶y pre d치ta." },
            { id: 22, q: "M치me index <code>(nazov, id_postihnutia)</code>.<br>Ak칰 pr칤stupov칰 met칩du zvol칤 DB pre:<br><code>WHERE upper(nazov) = 'ZRAKOVA PORUCHA';</code>?<br>Zd칪vodnite.", a: "<strong>INDEX FAST FULL SCAN</strong><br>Datab치za nem칪쬰 pou쬴콘 strom na vyh쬬danie (pou쬴t치 funkcia UPPER a index nie je funk캜n칳).<br>Ale index obsahuje v코etky potrebn칠 st컄pce a je men코칤 ako tabu쬶a -> pre캜칤ta cel칳 index rad za radom." },
            { id: 23, q: "M치me index <code>(datum_do, datum_od)</code>.<br>Ak칰 met칩du zvol칤 DB pre:<br><code>select datum_od ... WHERE datum_od > sysdate - 30;</code>?", a: "<strong>INDEX FAST FULL SCAN</strong><br>Pre캜o nie Range Scan? Vodiaci st컄pec (datum_do) ch칳ba vo WHERE.<br>Pre캜o nie Table Scan? V코etky 쬴adan칠 st컄pce s칰 v indexe, je efekt칤vnej코ie pre캜칤ta콘 cel칳 index ne cel칰 tabu쬶u." },
            
            // --- INDEX THEORY (24-30) ---
            { id: 24, q: "Vysvetlite princ칤p <strong>Index Range Scan</strong> a podmienky pre pou쬴tie.", a: "<strong>Princ칤p:</strong> Prejde kore켿om a vetvami B-stromu k prv칠mu listu, potom 캜칤ta horizont치lne.<br><strong>Podmienky:</strong><br>1. Mus칤 by콘 pou쬴t칳 vodiaci (prv칳) st컄pec indexu.<br>2. Index je neunik치tny ALEBO oper치tor je rozsahov칳 (<, >, LIKE, BETWEEN)." },
            { id: 25, q: "Kedy sa pou쬴je <strong>Index Unique Scan</strong>?", a: "Pou쬴je sa, ak je zaru캜en칠, 쬰 dotaz vr치ti <strong>maxim치lne jeden riadok</strong>.<br>Podmienky: Oper치tor rovnosti (=) na Primary Key alebo Unique Index." },
            { id: 26, q: "캛o je podstatou met칩dy <strong>Bitmap Index Combine</strong>?", a: "Efekt칤vne vyu쬴tie bitov칳ch oper치ci칤 (AND, OR, NOT) priamo v pam칛ti nad viacer칳mi bitmapov칳mi indexmi predt칳m, ne sa siahne na fyzick칠 d치ta." },
            { id: 27, q: "캛o sp칪sobuje vznik <strong>chained row</strong> a kedy sa zhor코uje?", a: "Vznik치 pri UPDATE, ke캞 sa riadok zv칛캜코칤 tak, 쬰 sa nezmest칤 do p칪vodn칠ho bloku. Vytvor칤 sa link na 캞al코칤 blok.<br>Zhor코uje sa s narastaj칰cim po캜tom UPDATE oper치ci칤 meniacich ve쬶os콘 d치t (fragment치cia)." },
            { id: 28, q: "Ak칳 je rozdiel medzi <strong>Function-based index</strong> a norm치lnym B-tree indexom?", a: "Norm치lny uklad치 skuto캜n칠 hodnoty st컄pca. Function-based uklad치 <strong>v칳sledok funkcie</strong> (napr. UPPER(meno)). Umo쮄갓je vyu쬴콘 index aj ke캞 je vo WHERE pou쬴t치 funkcia." },
            { id: 29, q: "Ak칰 selektivitu preferuje B-tree index a pre캜o?", a: "Preferuje <strong>vysok칰 selektivitu</strong> (vysok칰 kardinalitu/unik치tnos콘).<br>Pri n칤zkej selektivite (ve쬬 duplicitn칳ch hodn칪t) str치ca efektivitu a DB m칪쬰 zvoli콘 Full Table Scan." },
            { id: 30, q: "캛o vyjadruje klauzula <code>parallel n</code> pri defin칤cii indexu?", a: "Ur캜uje, 쬰 pri <strong>vytv치ran칤</strong> indexu sa m치 pou쬴콘 paralelizmus (n vl치kien).<br>D칪sledok: Dotazy vyu쮂셨aj칰ce tento index bud칰 tie inklinova콘 k paraleln칠mu vykon치vaniu." },
            
            // --- LOB THEORY (31-40) ---
            { id: 31, q: "Ak칳 je rozdiel medzi <strong>BLOB</strong> a <strong>BFILE</strong> z h쬬diska ulo쬰nia d치t?", a: "<strong>BLOB (Internal):</strong> D치ta fyzicky vo vn칰tri DB.<br><strong>BFILE (External):</strong> D치ta externe v OS (s칰borov칳 syst칠m), v DB len ukazovate (read-only)." },
            { id: 32, q: "Ak칠 s칰 rozdiely medzi intern칳m (CLOB, BLOB) a extern칳m (BFILE) LOB-om?", a: "<strong>Intern칳:</strong> Podporuje transakcie (ACID), d치ta sa daj칰 modifikova콘.<br><strong>Extern칳:</strong> Read-only, nepodporuje transakcie (COMMIT/ROLLBACK neovplyvn칤 s칰bor)." },
            { id: 33, q: "캛o je <strong>LOB locator</strong>?", a: "Ukazovate na ve쬶칠 d치ta.<br>Pri intern칳ch ukazuje na miesto v DB.<br>Pri BFILE uchov치va cestu k s칰boru.<br>Umo쮄갓je pr치cu s LOBom bez na캜칤tania cel칠ho obsahu do pam칛te." },
            { id: 34, q: "Ktor칠 oper치cie nad LOBmi sp칪sobuj칰 alokovanie nov칠ho segmentu?", a: "Vkladanie d치t cez INSERT alebo UPDATE, resp. <code>DBMS_LOB.LOADFROMFILE</code>.<br>Samotn칳 <code>EMPTY_CLOB()</code> len inicializuje locator na NULL/pr치zdny." },
            { id: 35, q: "Ak칳 je rozdiel medzi <strong>SecureFile</strong> a <strong>BasicFile</strong> LOB z h쬬diska v칳konu?", a: "<strong>SecureFile:</strong> Nov코칤, vy코코칤 v칳kon, Write Gather Cache, variabiln칳 chunk, deduplik치cia, kompresia.<br><strong>BasicFile:</strong> Star코칤, fixn칳 chunk, bez cache." },
            { id: 36, q: "Vymenujte 3 v칳hody SecureFile LOBov.", a: "1. Advanced performance (WGC)<br>2. Advanced security (코ifrovanie)<br>3. Advanced storage optimization (kompresia, deduplik치cia)" },
            { id: 37, q: "Kedy Oracle automaticky komprimuje SecureFile LOB?", a: "Ke캞 je zapnut치 vo쬭a <code>COMPRESS</code> (HIGH/MEDIUM/LOW) a server rozpozn치 pr칤nos kompresie." },
            { id: 38, q: "캛o vyjadruje hodnota <code>RETENTION</code> pri SecureFile LOB?", a: "Nahr치dza PCTVERSION. Ur캜uje spr치vu Undo d치t pre konzistentn칠 캜칤tanie.<br>AUTO: Pod쬬 ve쬶osti Undo tablespace.<br>MAX: Uchov치va 캜o najdlh코ie (pre dlh칠 transakcie)." },
            { id: 39, q: "캛o predstavuje parameter <code>CACHE / NOCACHE</code> pri LOBoch?", a: "Ur캜uje, 캜i id칰 d치ta cez <strong>Buffer Cache</strong> (CACHE - umo쮄갓je logging) alebo priamy z치pis na disk (NOCACHE)." },
            { id: 40, q: "Ak칳 je maxim치lny po캜et otvoren칳ch BFILE objektov v rel치cii?", a: "Definuje to parameter <code>SESSION_MAX_OPEN_FILES</code> (default 10)." },
            
            // --- LOB PACKAGES (41-49) ---
            { id: 41, q: "Pre캜o nemo쬹o pou쬴콘 typ <strong>LONG</strong> vo viacer칳ch st컄pcoch tabu쬶y?", a: "Historick칠 obmedzenie. Uklad치 sa 'inline', 캜o pri 2GB d치tach sp칪sobovalo extr칠mne v칳konnostn칠 probl칠my (re콘azenie)." },
            { id: 42, q: "Rozdiel medzi <code>DBMS_LOB.SUBSTR</code> a SQL <code>SUBSTR</code>?", a: "SQL SUBSTR rob칤 implicitn칰 konverziu na VARCHAR (limit 4000 znakov).<br><code>DBMS_LOB.SUBSTR</code> pracuje priamo s LOB locatorom a dok치쬰 캜칤ta콘 캜asti z GB d치t bez na캜칤tania cel칠ho objektu." },
            { id: 43, q: "Na 캜o sl칰쬴 <code>DBMS_LOB.FILEEXISTS</code>?", a: "Overuje existenciu s칰boru v OS pred pr치cou s n칤m (vr치ti 1 alebo 0). Vytvorenie DIRECTORY objektu toti nekontroluje existenciu cesty." },
            { id: 44, q: "칔loha <code>DBMS_LOB.OPEN</code> pri BFILE?", a: "Otv치ra fyzick칳 s칰bor v OS a men칤 'pas칤vny' odkaz na 'akt칤vny' stream pre 캜칤tanie d치t." },
            { id: 45, q: "캛o rob칤 <code>DBMS_LOB.COMPARE</code>?", a: "Porovn치va dva LOB objekty alebo ich 캜asti. Vr치ti 0 ak s칰 zhodn칠. Efekt칤vne pre ve쬶칠 objekty (nemus칤 캜칤ta콘 cel칠)." },
            { id: 46, q: "Rozdiel medzi READ ONLY a READ WRITE pri <code>DBMS_LOB.OPEN</code>?", a: "<strong>READ ONLY:</strong> Len 캜칤tanie (v쬯y pre BFILE), bez zamykania.<br><strong>READ WRITE:</strong> Pre intern칠 LOBy, modifik치cia. Malo by sa pou쬴콘 s <code>FOR UPDATE</code>." },
            { id: 47, q: "Pre캜o nemo쬹o aktualizova콘 BFILE cez UPDATE?", a: "BFILE je read-only s칰bor v OS. DB nem치 nad n칤m transak캜n칰 kontrolu. UPDATE zmen칤 len locator (cestu), nie obsah s칰boru." },
            { id: 48, q: "Princ칤p <code>DBMS_CRYPTO.ENCRYPT</code> pri LOBoch?", a: "Manu치lne 코ifrovanie v PL/SQL. Vezme LOB, k쮂줷, algoritmus a vr치ti za코ifrovan칳 BLOB." },
            { id: 49, q: "Na 캜o sl칰쬴 <code>DBMS_CRYPTO.HASH</code>?", a: "Vypo캜칤ta 'odtla캜ok' (hash) z LOBu. Pou쮂셨a sa na deduplik치ciu alebo kontrolu integrity d치t." },
            
            // --- JSON (50-61) ---
            { id: 50, q: "Nap칤코te pr칤kaz SELECT, pomocou ktor칠ho prist칰pite ku v코etk칳m knih치m z tabu쬶y <code>kniha_json</code>, ktor칳ch autor za캜칤na na p칤smeno M. Jednotliv칠 knihy s칰 vo form치te JSON.", a: "<pre>select * from kniha_json k\nwhere k.doc.autor like 'M%'</pre>" },
            { id: 51, q: "Nap칤코te pr칤kaz SELECT, ktor칳 vr치ti v코etky n치zvy kn칤h (z <code>kniha_json</code>) vydan칠 po roku 2010. Pou쬴te <code>JSON_VALUE</code> a <code>RETURNING NUMBER</code>.", a: "<pre>SELECT JSON_VALUE(doc, '$.nazov')\nFROM kniha_json\nWHERE JSON_VALUE(doc, '$.rok_vydania' \n  RETURNING NUMBER) > 2010;</pre>" },
            { id: 52, q: "SELECT nad <code>student_json</code>, ktor칳 vr치ti 코tudentov s ro캜n칤kom vy코코칤m ako 2.", a: "<pre>select * from student_json s \nwhere s.student.rocnik > 2;</pre>" },
            { id: 53, q: "SELECT mien 코tudentov z <code>student_json</code>, ktor칤 maj칰 priemer zn치mok men코칤 ne 2.0.", a: "<pre>select json_value(student, '$.meno') \nfrom student_json\nwhere json_value(student, '$.priemer' \n  returning number) < 2.0;</pre>" },
            { id: 54, q: "SELECT v코etk칳ch produktov z <code>produkt_json</code>, ktor칳ch cena je vy코코ia ako 20 eur.", a: "<pre>select * from produkt_json\nwhere json_value(produkt, '$.cena' \n  returning number) > 20;</pre>" },
            { id: 55, q: "SELECT n치zvov produktov z <code>produkt_json</code>, ktor칠 patria do kateg칩rie 'Elektronika'.", a: "<pre>select p.produkt.nazov \nfrom produkt_json p\nwhere p.produkt.kategoria = 'Elektronika';</pre>" },
            { id: 56, q: "SELECT zamestnancov z <code>zamestnanec_json</code>, ktor칤 pracuj칰 na poz칤cii 'Manager'.", a: "<pre>select * from zamestnanec_json\nwhere json_value(zamestnanec, '$.pozicia') \n  = 'Manager';</pre>" },
            { id: 57, q: "SELECT pre pristup k platom zamestnancov vy코코칤m ako 1500 z <code>zamestnanec_json</code>.", a: "<pre>select json_value(zamestnanec, '$.plat')\nfrom zamestnanec_json\nwhere json_value(zamestnanec, '$.plat' \n  returning number) > 1500;</pre>" },
            { id: 58, q: "SELECT objedn치vok z <code>objednavka_json</code>, kde po캜et polo쬴ek > 3.", a: "<pre>select * from objednavka_json o\nwhere o.doc.pocet_poloziek > 3;\n-- alebo cez json_value</pre>" },
            { id: 59, q: "SELECT celkov칳ch cien objedn치vok > 100 z <code>objednavka_json</code>.", a: "<pre>select json_value(doc, '$.celkova_cena')\nfrom objednavka_json\nwhere json_value(doc, '$.celkova_cena' \n  returning number) > 100;</pre>" },
            { id: 60, q: "SELECT z치kazn칤kov z <code>zakaznik_json</code>, ktor칤 maj칰 vek > 30.", a: "<pre>select * from zakaznik_json z\nwhere z.doc.vek > 30;</pre>" },
            { id: 61, q: "SELECT n치zvov filmov z <code>film_json</code>, s hodnoten칤m > 7.5.", a: "<pre>select f.doc.nazov\nfrom film_json f\nwhere f.doc.rating > 7.5;</pre>" },

            // --- GENERAL THEORY (62-69) ---
            { id: 62, q: "Vysvetlite rozdiel medzi LOB typmi: <strong>Inline</strong> vs <strong>Out-of-line</strong> ulo쬰nie.", a: "<div class='answer-text'><strong>Mal칠 LOB d치ta (Inline):</strong> Ukladaj칰 sa priamo v riadku tabu쬶y (ak s칰 do cca 4KB).<br><strong>Ve쬶칠 LOB d치ta (Out-of-line):</strong> Ukladaj칰 sa v samostatn칳ch segmentoch (LOBSEGMENT). V tabu쬶e ost치va len <strong>LOB locator</strong> (ukazovate).</div>" },
            { id: 63, q: "Pop칤코te fyzick칰 코trukt칰ru datab치zy (Bloky, Extenty, Segmenty).", a: "<div class='answer-text'><strong>D치tov칳 blok:</strong> Najmen코ia I/O jednotka.<br><strong>Extent:</strong> Zoskupenie s칰visl칳ch blokov.<br><strong>Segment:</strong> Sada extentov (napr. cel치 tabu쬶a alebo index).<br><strong>ROWID:</strong> Unik치tna fyzick치 adresa riadku (s칰bor, blok, riadok).</div>" },
            { id: 64, q: "캛o je to transakcia a na 캜o sl칰쬴a Redo Logy a Undo segmenty?", a: "<div class='answer-text'><strong>Transakcia:</strong> Logick치 jednotka pr치ce (ACID).<br><strong>Redo Log:</strong> Zapisuje v코etky zmeny pre pr칤pad obnovy (recovery) po v칳padku.<br><strong>Undo:</strong> Uklad치 p칪vodn칠 hodnoty pre mo쬹os콘 ROLLBACK a pre konzistentn칠 캜칤tanie (Read Consistency).</div>" },
            { id: 65, q: "Vysvetlite pam칛콘ov칰 architekt칰ru <strong>SGA</strong> a <strong>Buffer Cache</strong>.", a: "<div class='answer-text'><strong>SGA (System Global Area):</strong> Zdie쬬n치 pam칛콘 in코tancie.<br><strong>Buffer Cache:</strong> 캛as콘 SGA, obsahuje k칩pie d치tov칳ch blokov na캜칤tan칳ch z disku pre r칳chly pr칤stup (minimaliz치cia I/O).<br><strong>Shared Pool:</strong> Obsahuje parsovan칠 SQL pl치ny.</div>" },
            { id: 66, q: "Ak치 je 칰loha optimaliz치tora (CBO)?", a: "<div class='answer-text'>Generuje vykon치vac칤 pl치n na z치klade 코tatist칤k s cie쬺m minimalizova콘 cenu (CPU, I/O). Rozhoduje, 캜i pou쬴콘 <strong>Full Table Scan</strong> alebo <strong>Index Scan</strong>.</div>" },
            { id: 67, q: "Ako Oracle pracuje s XML (Well-formed vs Valid)?", a: "<div class='answer-text'><strong>Well-formed:</strong> Syntakticky spr치vne (p치rov칠 tagy).<br><strong>Valid:</strong> Sp컄켿a definovan칰 코trukt칰ru (XSD/DTD).<br>Oracle typ <code>XMLType</code> automaticky kontroluje well-formedness a umo쮄갓je valid치ciu vo캜i registrovanej XSD sch칠me.</div>" },
            { id: 68, q: "캛o je to <strong>Database Link</strong>?", a: "<div class='answer-text'>Objekt definuj칰ci pripojenie do vzdialenej datab치zy. Umo쮄갓je distribuovan칠 dopyty (napr. <code>tabulka@dblink</code>). 캛asto sa pou쮂셨aj칰 synonym치 na skrytie <code>@dblink</code>.</div>" },
            { id: 69, q: "Vysvetlite skratku <strong>ACID</strong>.", a: "<div class='answer-text'><strong>Atomicity:</strong> V코etko alebo ni캜 (COMMIT/ROLLBACK).<br><strong>Consistency:</strong> Prechod z validn칠ho do validn칠ho stavu (dodr쬬nie constraints).<br><strong>Isolation:</strong> Transakcie sa neovplyv켿uj칰 (Readers don't block writers).<br><strong>Durability:</strong> Potvrden칠 zmeny s칰 trval칠 (Redo Log).</div>" },

            // --- CONNECT BY (70-87) ---
            { id: 70, q: "Pre KA콯D칗 mesiac minul칠ho roka uve캞te po캜et poistencov, ktor칳m v danom mesiaci vzniklo poistenie (<code>dat_od</code>).", a: "<pre>SELECT k.mesiac, COUNT(p.id_poistenca) AS pocet\nFROM\n (SELECT level AS mesiac FROM dual \n  CONNECT BY level <= 12) k\n LEFT JOIN p_poistenie p\n ON EXTRACT(MONTH FROM p.dat_od) = k.mesiac\n AND EXTRACT(YEAR FROM p.dat_od) = \n     EXTRACT(YEAR FROM sysdate) - 1\nGROUP BY k.mesiac\nORDER BY k.mesiac;</pre>" },
            { id: 71, q: "Pre KA콯D칗 mesiac minul칠ho roka uve캞te po캜et poistencov, ktor칳m poistenie zaniklo (<code>dat_do</code>).", a: "<pre>select c.mesiac, count(ID_POISTENCA)\nfrom \n (select level as mesiac from dual \n  connect by level <= 12) c\n LEFT JOIN p_poistenie on \n  (to_char(dat_do, 'MM') = c.mesiac\n   AND extract(year from dat_do) = \n       extract(year from sysdate) - 1)\ngroup by c.mesiac\norder by c.MESIAC;</pre>" },
            { id: 72, q: "Pre KA콯D칗 mesiac minul칠ho roka vyp칤코te po캜et zamestn치vate쬺v, ktor칳m pribudol nov칳 zamestnanec (<code>dat_nastupu</code>).", a: "<pre>with mesiace as (\n select level mesiac from dual\n connect by level <= 12\n) select mesiac, \n  count(distinct ID_ZAMESTNAVATELA) \nfrom MESIACE\nleft join p_zamestnanec on \n (mesiac = extract(month from dat_od)\n AND extract(year from dat_od) = \n     extract(year from sysdate) - 9) --rok\ngroup by mesiac\nORDER BY mesiac;</pre>" },
            { id: 73, q: "Pre KA콯D칗 mesiac minul칠ho roka uve캞te po캜et poistencov, ktor칤 mali platn칳 z치znam (<code>dat_od <= den</code> a z치rove켿 <code>dat_do</code> je NULL alebo platn칠).", a: "<pre>WITH mesiace AS (SELECT level AS mesiac \n FROM dual CONNECT BY level <= 12)\nSELECT m.mesiac, COUNT(p.id_poistenca)\nFROM mesiace m\n LEFT JOIN p_poistenie p ON(\n p.dat_od <= LAST_DAY(TO_DATE(m.mesiac || '.' \n  || (EXTRACT(YEAR FROM SYSDATE) - 1), 'MM.YYYY'))\n AND (p.dat_do IS NULL OR\n p.dat_do >= TO_DATE('01.' || m.mesiac ...\nGROUP BY m.mesiac;</pre>" },
            { id: 74, q: "Pre KA콯D칗 de켿 minul칠ho roka vyp칤코te celkov칳 po캜et pr칤spevkov vyplaten칳ch v danom dni.", a: "<pre>SELECT k.den, COUNT(p.id_poberatela)\nFROM\n (SELECT TRUNC(SYSDATE, 'YYYY') - LEVEL AS den\n  FROM dual CONNECT BY LEVEL <= 366) k\nLEFT JOIN p_prispevky p \n  ON TRUNC(p.kedy) = k.den\nWHERE EXTRACT(YEAR FROM k.den) = \n      EXTRACT(YEAR FROM SYSDATE) - 1\nGROUP BY k.den\nORDER BY k.den;</pre>" },
            { id: 75, q: "Pre KA콯D칗 de켿 v mesiaci APR칈L minul칠ho roka vyp칤코te po캜et zamestnancov, ktor칳m vznikol pracovn칳 pomer.", a: "<pre>with dni as(\n select level as den from dual\n CONNECT BY level <= 30\n) select den, count(ROD_CISLO) from DNI\nleft join p_zamestnanec on(\n extract(day from dat_od) = DEN AND\n extract(year from dat_od) = ... -1\n and extract(month from dat_od) = 4\n) group by den order by den;</pre>" },
            { id: 76, q: "Pre KA콯D칗 de켿 v tre콘om 코tvr콘roku minul칠ho roka vyp칤코te po캜et poistencov, ktor칳m v dan칳 de켿 zaniklo poistenie.", a: "<div class='ai-generated'>丘멆잺 Rie코enie doplnen칠 AI (ch칳balo v PDF)</div><pre>WITH dni AS (\n  SELECT TO_DATE('01.07.' || (EXTRACT(YEAR FROM SYSDATE)-1), 'DD.MM.YYYY') + LEVEL - 1 AS den\n  FROM dual CONNECT BY LEVEL <= 92 -- j칰l-sept\n)\nSELECT d.den, COUNT(p.id_poistenca)\nFROM dni d\nLEFT JOIN p_poistenie p \n  ON p.dat_do = d.den\nGROUP BY d.den;</pre>" },
            { id: 77, q: "Pre KA콯D칗 de켿 minul칠ho roka vyp칤코te po캜et os칪b, ktor칠 mali narodeniny (zhoda de켿 a mesiac).", a: "<div class='ai-generated'>丘멆잺 Rie코enie doplnen칠 AI (ch칳balo v PDF)</div><pre>WITH dni AS (\n  SELECT TRUNC(SYSDATE, 'YYYY') - LEVEL AS den\n  FROM dual CONNECT BY LEVEL <= 366\n)\nSELECT d.den, COUNT(o.rod_cislo)\nFROM dni d\nLEFT JOIN p_osoba o \n  ON TO_CHAR(o.dat_nar, 'MMDD') = TO_CHAR(d.den, 'MMDD')\nWHERE EXTRACT(YEAR FROM d.den) = EXTRACT(YEAR FROM SYSDATE) - 1\nGROUP BY d.den;</pre>" },
            { id: 78, q: "Pre KA콯D칗 mesiac minul칠ho roka vyp칤코te po캜et poberate쬺v s akt칤vnym poberan칤m (interval prekryvu).", a: "<div class='ai-generated'>丘멆잺 Rie코enie doplnen칠 AI (ch칳balo v PDF)</div><pre>WITH mesiace AS (SELECT level AS m FROM dual CONNECT BY level <= 12)\nSELECT m.m, COUNT(p.id_poberatela)\nFROM mesiace m\nLEFT JOIN p_poberatel p ON\n  p.dat_od <= LAST_DAY(...) AND \n  (p.dat_do IS NULL OR p.dat_do >= TO_DATE('01.'||m.m...))\nGROUP BY m.m;</pre>" },
            { id: 79, q: "Pre KA콯D칗 de켿 v M츼JI minul칠ho roka vyp칤코te po캜et pr칤spevkov > 100 EUR.", a: "<div class='ai-generated'>丘멆잺 Rie코enie doplnen칠 AI (ch칳balo v PDF)</div><pre>WITH dni AS (\n SELECT TO_DATE('01.05.'||(EXTRACT(YEAR FROM SYSDATE)-1), 'DD.MM.YYYY') + LEVEL - 1 AS den\n FROM dual CONNECT BY LEVEL <= 31\n)\nSELECT d.den, COUNT(p.id_prispevku)\nFROM dni d\nLEFT JOIN p_prispevky p \n  ON TRUNC(p.kedy) = d.den AND p.suma > 100\nGROUP BY d.den;</pre>" },
            { id: 80, q: "Pre KA콯D칗 mesiac minul칠ho roka vyp칤코te po캜et os칪b naroden칳ch v danom mesiaci.", a: "<div class='ai-generated'>丘멆잺 Rie코enie doplnen칠 AI (ch칳balo v PDF)</div><pre>WITH mesiace AS (SELECT level AS m FROM dual CONNECT BY level <= 12)\nSELECT m.m, COUNT(o.id_osoby)\nFROM mesiace m\nLEFT JOIN p_osoba o \n  ON EXTRACT(MONTH FROM o.dat_nar) = m.m\nGROUP BY m.m;</pre>" },
            { id: 81, q: "Pre KA콯D칗 mesiac minul칠ho roka vyp칤코te po캜et poistencov so zmenou poistenia (vznik alebo z치nik v danom mesiaci).", a: "<div class='ai-generated'>丘멆잺 Rie코enie doplnen칠 AI (ch칳balo v PDF)</div><pre>WITH mesiace AS (SELECT level AS m FROM dual CONNECT BY level <= 12)\nSELECT m.m, COUNT(p.id_poistenca)\nFROM mesiace m\nLEFT JOIN p_poistenie p ON\n  (EXTRACT(MONTH FROM p.dat_od) = m.m AND ...rok...)\n  OR\n  (EXTRACT(MONTH FROM p.dat_do) = m.m AND ...rok...)\nGROUP BY m.m;</pre>" },
            { id: 82, q: "Pre KA콯D칗 de켿 v janu치ri minul칠ho roka vyp칤코te po캜et poistencov s platn칳m poisten칤m.", a: "<div class='ai-generated'>丘멆잺 Rie코enie doplnen칠 AI (ch칳balo v PDF)</div><pre>WITH dni AS (SELECT ... CONNECT BY LEVEL <= 31) -- Januar\nSELECT d.den, COUNT(p.id_poistenca)\nFROM dni d\nLEFT JOIN p_poistenie p ON\n  p.dat_od <= d.den AND (p.dat_do IS NULL OR p.dat_do >= d.den)\nGROUP BY d.den;</pre>" },
            { id: 83, q: "Pre KA콯D칗 mesiac minul칠ho roka vyp칤코te po캜et nov칳ch ZTP.", a: "<div class='ai-generated'>丘멆잺 Rie코enie doplnen칠 AI (ch칳balo v PDF)</div><pre>WITH mesiace AS (SELECT level m FROM dual CONNECT BY level <= 12)\nSELECT m.m, COUNT(z.id_ztp)\nFROM mesiace m\nLEFT JOIN p_ztp z \n  ON EXTRACT(MONTH FROM z.dat_platnosti) = m.m\n  AND EXTRACT(YEAR FROM z.dat_platnosti) = ...\nGROUP BY m.m;</pre>" },
            { id: 84, q: "Pre KA콯D칗 de켿 v DECEMBRI minul칠ho roka vyp칤코te po캜et poberate쬺v, ktor칤 prestali by콘 poberate쬸i.", a: "<div class='ai-generated'>丘멆잺 Rie코enie doplnen칠 AI (ch칳balo v PDF)</div><pre>WITH dni AS (SELECT ... CONNECT BY LEVEL <= 31) -- December\nSELECT d.den, COUNT(p.id_poberatela)\nFROM dni d\nLEFT JOIN p_poberatel p \n  ON p.dat_do = d.den\nGROUP BY d.den;</pre>" },
            { id: 85, q: "Pre KA콯D칗 mesiac minul칠ho roka vyp칤코te po캜et zamestnancov s platnou zmluvou.", a: "<div class='ai-generated'>丘멆잺 Rie코enie doplnen칠 AI (ch칳balo v PDF)</div><pre>WITH mesiace AS (SELECT level m FROM dual CONNECT BY level <= 12)\nSELECT m.m, COUNT(z.id_zamestnanca)\nFROM mesiace m\nLEFT JOIN p_zamestnanec z ON\n  z.dat_nastupu <= LAST_DAY(...) \n  AND (z.dat_ukoncenia IS NULL OR z.dat_ukoncenia >= ...)\nGROUP BY m.m;</pre>" },
            { id: 86, q: "Pre KA콯D칗 de켿 minul칠ho roka vyp칤코te po캜et poistencov, ktor칳m v dan칳 de켿 vzniklo poistenie.", a: "<pre>with dni as (\n select level as den from dual\n CONNECT BY level <= \n  to_number(to_char(to_date('31.12.' || ...\n) select den, count(ID_POISTENCA) from DNI\nleft join p_poistenie on(\n to_number(to_char(dat_od, 'DDD')) = DEN\n ...\n) group by den;</pre>" },
            { id: 87, q: "Pre KA콯D칗 mesiac minul칠ho roka vyp칤코te priemern칰 denn칰 sumu pr칤spevkov.", a: "<div class='ai-generated'>丘멆잺 Rie코enie doplnen칠 AI (ch칳balo v PDF)</div><pre>WITH mesiace AS (SELECT level m FROM dual CONNECT BY level <= 12)\nSELECT m.m, AVG(p.suma)\nFROM mesiace m\nLEFT JOIN p_prispevky p \n  ON EXTRACT(MONTH FROM p.kedy) = m.m\nGROUP BY m.m;</pre>" },
            
            // --- TRANSACTIONS (88-101) ---
            { id: 88, q: "캛o vr치ti posledn칳 select?<br><pre>create table tab1 ( id integer );\ninsert into tab1 values ( 10 );\ninsert into tab1 values ( 20 );\nsavepoint sp1;\ninsert into tab1 values ( 30 );\nrollback;\ninsert into tab1 values ( 40 );\ncommit;\nselect * from tab1;</pre>", a: "<strong>40</strong><br>Preto쬰 <code>ROLLBACK</code> nem치 코pecifikovan칳 savepoint, vr치ti cel칰 transakciu sp칛콘 (zru코칤 10, 20, 30). Potom sa vlo쮂 40 a commitne." },
            { id: 89, q: "캛o vr치ti posledn칳 select?<br><pre>... values (1);\n... values (2);\nsavepoint a;\n... values (3);\nsavepoint b;\n... values (4);\nrollback to a;\n... values (5);\ncommit;\nrollback;\nselect * from tab1;</pre>", a: "<strong>1, 2, 5</strong><br>Inserty 1 a 2 s칰 pred savepointom. Rollback to A zru코칤 3 a 4. Potom sa vlo쮂 5. Commit potvrd칤 1, 2, 5. Posledn칳 rollback u nem치 캜o robi콘." },
            { id: 90, q: "Ak칳 v칳sledok bude vyp칤san칳 (count)?<br><pre>begin\n insert ... (1);\n insert ... (2);\n commit;\n insert ... (3);\n rollback;\n insert ... (4);\nend;\nselect count(*) ...</pre>", a: "<strong>3</strong><br>(Hodnoty: 1, 2, 4).<br>1 a 2 s칰 commitnut칠. 3 je rollbacknut치. 4 je vlo쬰n치 (ale zatia necommitnut치, no v rovnakej session vidite쬹치, alebo ak nasleduje autocommit na konci bloku)." },
            { id: 91, q: "Ak칳 v칳sledok bude vyp칤san칳?<br><pre>begin\n for i in 1..5 loop\n  insert ... (i);\n end loop;\n rollback;\n insert ... (100);\ncommit;\nend;\nselect max(id)...</pre>", a: "<strong>100</strong><br>Cyklus vlo쮂 1..5, ale potom nasleduje <code>ROLLBACK</code>, ktor칳 v코etko zma쬰. Vlo쮂 sa len 100." },
            { id: 92, q: "Ak칳 v칳sledok bude vyp칤san칳?<br><pre>set autocommit on;\n... insert (1);\n... insert (2);\n... insert (3);\nrollback;\n... insert (10);\ncommit;\nselect count(*)...</pre>", a: "<strong>4</strong><br>Pri <code>autocommit on</code> je ka쬯칳 pr칤kaz samostatn치 transakcia. Rollback nem치 캜o vraca콘 (ka쬯칳 insert bol hne캞 commitnut칳).<br>Hodnoty: 1, 2, 3, 10." },
            { id: 93, q: "Ak칳 v칳sledok?<br><pre>for i in 1..6 loop\n insert (i);\n if i = 3 then savepoint sp_mid; end if;\nend loop;\nrollback to sp_mid;\ninsert (100);\ncommit;</pre>", a: "<strong>100</strong> (Pod쬬 PDF slide 21)<br>Pozor na logiku: K칩d v PDF najprv insertne 1, 2, 3. Vytvor칤 savepoint. Potom 4, 5, 6. Rollback to sp_mid vr치ti stav na (1, 2, 3). Potom vlo쮂 100. <br>Wait - PDF slide 21 ukazuje v칳sledok <strong>100</strong> pre `select max(id)`. To znamen치 쬰 rollback vr치til v코etko? Nie, `rollback to sp_mid` zachov치va veci pred savepointom. <br><strong>Oprava pod쬬 PDF:</strong> V칳sledok je 100." },
            { id: 94, q: "캛o vr치ti posledn칳 select?<br><pre>... values (20);\nsavepoint s1;\n... values (30);\n... values (40);\nrollback to s1;\n... values (50);\ncommit;\nselect * ...</pre><br>A potom znova <code>rollback to s1</code>?", a: "V칳sledok selectu: <strong>10, 20, 50</strong>.<br>Pozor: Ak by nasledoval 캞al코칤 <code>rollback to s1</code> po commite, vyhod칤 to <strong>ERROR</strong>, preto쬰 commit zma쬰 v코etky savepointy." },
            { id: 95, q: "Ak칳 v칳sledok?<br><pre>for i in 1..5 loop\n insert (i);\n if mod(i,2) = 1 then commit;\n else rollback; end if;\nend loop;</pre>", a: "<strong>1, 3, 5</strong><br>i=1 (odd) -> commit (1 ulo쬰n칠).<br>i=2 (even) -> insert 2, rollback (2 zru코en칠, 1 ost치va).<br>i=3 (odd) -> insert 3, commit (1, 3 ulo쬰n칠).<br>i=4 -> insert 4, rollback (4 zru코en칠).<br>i=5 -> commit." },
            { id: 96, q: "Proced칰ry a transakcie.<br><pre>Proc1: Loop 1..5, Insert, Commit.<br>Proc2: Proc1, Rollback, Insert 100.<br>Exec Proc2; Commit;</pre>", a: "Count: <strong>6</strong><br>Proc1 m치 commit vo vn칰tri cyklu. Teda 1..5 sa natrvalo ulo쬴a. Rollback v Proc2 u neovplyvn칤 1..5. Vlo쮂 sa 100. V칳sledok: 1, 2, 3, 4, 5, 100." },
            { id: 97, q: "Proced칰ry 2.<br><pre>Proc1: Loop 1..5, Insert, EndLoop, Rollback.<br>Proc2: Proc1, Insert 50, Commit.</pre>", a: "Max(id): <strong>50</strong><br>Proc1 vlo쮂 1..5, ale na konci m치 <code>ROLLBACK</code>. V코etko z Proc1 sa zru코칤. Potom Proc2 vlo쮂 50." },
            { id: 98, q: "Autonomous Transaction.<br><pre>Proc1: PRAGMA AUTONOMOUS... Insert 1, 2, Commit.<br>Proc2: Proc1, Rollback, Insert 10.<br>Exec Proc2;</pre>", a: "Count: <strong>3</strong> (Hodnoty: 1, 2, 10)<br>Proc1 je auton칩mna - jej commit je nez치visl칳. 1 a 2 sa ulo쬴a. Rollback v Proc2 zru코칤 len veci v Proc2 (캜o tam zatia ni캜 nie je). Potom vlo쮂 10." },
            { id: 99, q: "Savepoint v cykle.<br><pre>Loop 1..5, Insert (i). If i=3 then Savepoint sp. EndLoop.<br>Rollback to sp; Commit;</pre>", a: "<strong>1, 2, 3</strong><br>Vlo쮂 1, 2, 3 (SP), 4, 5. Rollback to SP vr치ti stav na 3. 4 a 5 sa zru코ia." },
            { id: 100, q: "Vnoren칠 volania.<br><pre>Proc1: Ins(5), Rollback, Ins(10), Commit.<br>Proc2: Proc1, Rollback, Ins(20), Commit.</pre>", a: "Count: <strong>2</strong> (Hodnoty: 10, 20)<br>Proc1: 5 zru코칤, 10 commitne. <br>Sp칛콘 v Proc2: Rollback zru코칤 len to, 캜o nebolo commitnut칠 (ale 10 u je commitnut치 v Proc1). Potom vlo쮂 20." },
            { id: 101, q: "Auton칩mna s Rollbackom.<br><pre>Proc1: Auton칩mna. Loop 1..3 Ins(i). Rollback.<br>Proc2: Proc1, Ins(99), Commit.</pre>", a: "Count: <strong>1</strong> (Hodnota: 99)<br>Proc1 vlo쮂 1, 2, 3 ale urob칤 Rollback (v r치mci svojej auton칩mnej transakcie). Tak쬰 z Proc1 neostane ni캜. Proc2 vlo쮂 99." }
        ];

        // --- DEFIN칈CIA OKRUHOV PRE TEST (Rozsahy ID) ---
        // Ka쬯칳 objekt reprezentuje jeden okruh, z ktor칠ho sa vyberie 1 n치hodn치 ot치zka
        const testCategories = [
            { min: 1, max: 3 },   // DB Link Insert
            { min: 4, max: 6 },   // DB Link Update
            { min: 7, max: 8 },   // Local Insert
            { min: 9, max: 10 },  // DB Link Delete
            { min: 11, max: 13 }, // Index DDL
            { min: 14, max: 19 }, // Index Design
            { min: 20, max: 23 }, // Access Methods
            { min: 24, max: 30 }, // Index Theory
            { min: 31, max: 40 }, // LOB Theory
            { min: 41, max: 49 }, // LOB Packages
            { min: 50, max: 61 }, // JSON
            { min: 62, max: 69 }, // General Theory
            { min: 70, max: 87 }, // Connect By
            { min: 88, max: 101 } // Transactions
        ];

        // --- LOGIC ---
        let queue = [];
        let currentCard = null;
        let correctCount = 0;
        let incorrectCount = 0;
        let isFlipped = false;
        let currentMode = 'learn'; // 'learn' alebo 'test'

        // UI Elementy
        const mainMenu = document.getElementById('main-menu');
        const gameArea = document.getElementById('game-area');
        const cardElement = document.getElementById('flashcard');
        const qNumEl = document.getElementById('q-num');
        const qTextEl = document.getElementById('q-text');
        const aTextEl = document.getElementById('a-text');
        
        const countRemEl = document.getElementById('count-remaining');
        const countCorEl = document.getElementById('count-correct');
        const countIncEl = document.getElementById('count-incorrect');
        const modeIndicator = document.getElementById('mode-indicator');

        const btnCor = document.getElementById('btn-correct');
        const btnInc = document.getElementById('btn-incorrect');

        // Funkcia na n치hodn칠 premie코anie po쬬 (Fisher-Yates)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // --- RE콯IM 1: U캛ENIE (V코etko zaradom) ---
        function startLearning() {
            currentMode = 'learn';
            // Napln칤me rad indexami 0 a po캜et ot치zok-1
            queue = questions.map((_, index) => index);
            
            setupGameUI("Re쬴m: V코etky karty");
        }

        // --- RE콯IM 2: TEST (1 z ka쬯칠ho okruhu) ---
        function startTest() {
            currentMode = 'test';
            queue = [];

            // Prejdi ka쬯칰 kateg칩riu a vyber 1 n치hodn칠 ID
            testCategories.forEach(cat => {
                const range = cat.max - cat.min + 1;
                const randomId = Math.floor(Math.random() * range) + cat.min;
                // Prevod ID na index po쬬 (ID-1)
                queue.push(randomId - 1);
            });

            // Premie코aj poradie ot치zok v teste, nech nejd칰 pod쬬 t칠m
            shuffleArray(queue);

            setupGameUI("Re쬴m: TEST (14 ot치zok)");
        }

        function setupGameUI(modeText) {
            correctCount = 0;
            incorrectCount = 0;
            modeIndicator.textContent = modeText;
            
            mainMenu.style.display = 'none';
            gameArea.style.display = 'flex';
            document.querySelector('.card-container').style.display = 'block'; // Ensure visible if hidden by finish
            document.getElementById('controls').style.display = 'flex';

            updateStats();
            loadCard();
        }

        function updateStats() {
            countRemEl.textContent = queue.length + (currentCard ? 1 : 0);
            countCorEl.textContent = correctCount;
            countIncEl.textContent = incorrectCount;
        }

        function loadCard() {
            if (queue.length === 0) {
                finish();
                return;
            }

            isFlipped = false;
            cardElement.classList.remove('flipped');
            
            btnCor.style.display = 'none';
            btnInc.style.display = 'none';

            const index = queue.shift();
            currentCard = questions[index];

            qNumEl.textContent = currentCard.id;
            qTextEl.innerHTML = currentCard.q;
            aTextEl.innerHTML = currentCard.a;

            updateStats();
        }

        function flipCard() {
            isFlipped = !isFlipped;
            cardElement.classList.toggle('flipped');

            if (isFlipped) {
                btnCor.style.display = 'inline-block';
                btnInc.style.display = 'inline-block';
            } else {
                btnCor.style.display = 'none';
                btnInc.style.display = 'none';
            }
        }

        cardElement.addEventListener('click', (e) => {
            if (window.getSelection().toString().length === 0) {
                 flipCard();
            }
        });

        function handleAnswer(isCorrect) {
            if (isCorrect) {
                correctCount++;
            } else {
                incorrectCount++;
                // Ak je nespr치vne, vr치time ot치zku na koniec radu (v oboch re쬴moch)
                // Aby sa pou쮂셨ate dou캜il to, 캜o nevedel
                const originalIndex = questions.indexOf(currentCard);
                queue.push(originalIndex);
            }
            
            currentCard = null;
            updateStats();
            loadCard();
        }

        function finish() {
            const container = document.querySelector('.card-container');
            container.innerHTML = `
                <div style="text-align:center; padding: 50px;">
                    <h1 style="color:#2ecc71; font-size: 3rem;">Hotovo!</h1>
                    <p style="font-size:1.2rem;">${currentMode === 'test' ? 'Test dokon캜en칳.' : 'V코etky karty prejden칠.'}</p>
                    <div style="margin-top: 20px; font-size: 1.1rem;">
                        Spr치vne na prv칳 pokus: ${correctCount - incorrectCount} <br>
                        Celkovo pokusov: ${correctCount + incorrectCount}
                    </div>
                    <button class="btn-menu" onclick="location.reload()">N치vrat do menu</button>
                </div>
            `;
            
            document.getElementById('controls').style.display = 'none';
            countRemEl.textContent = 0;
        }

    </script>
</body>
</html>